"()                 begin try                 declare @enable int;                 select top 1 @enable = convert(int,value_in_use) from sys.configurations where name = 'default trace enabled'                 if @enable = 1 --default trace is enabled                 begin                 declare @curr_tracefilename varchar(500);                 declare @base_tracefilename varchar(500);                 declare @indx int ;                 declare @temp_trace table (                 StartTime datetime                 ,       EventSubClass int                 ,       IntegerData int                 );                 declare @path_separator CHAR(1) ;                 set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;                  select @curr_tracefilename = path from sys.traces where is_default = 1 ;                 set @curr_tracefilename = reverse(@curr_tracefilename)                 select @indx  = PATINDEX('%'+@path_separator+'%', @curr_tracefilename)                 set @curr_tracefilename = reverse(@curr_tracefilename)                 set @base_tracefilename = LEFT( @curr_tracefilename, len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  insert into @temp_trace                 select StartTime                 ,       EventSubClass                 ,       IntegerData                 from ::fn_trace_gettable( @base_tracefilename, default )                 where EventClass = 81;                  update @temp_trace set IntegerData = -IntegerData where EventSubClass = 2;                  select   1 as row_no                 ,       StartTime                 ,       EventSubClass                 ,       IntegerData                 ,       case when IntegerData < 0                 then -IntegerData                 else IntegerData                 end ""Absolute""                 from @temp_trace                 where (datediff(dd,StartTime,getdate()) < 7) order by StartTime ;                 end                 else                 begin                 select top 0 1 as row_no, 1 as StartTime , 1 as EventSubClass, 1 as IntegerData, 1 as Absolute                 end                 end try                 begin catch                 select  -100 as row_no                 ,       ERROR_NUMBER()  as StartTime                 ,       ERROR_SEVERITY() as EventSubClass                 ,       ERROR_STATE()  as   IntegerData                 ,       ERROR_MESSAGE() as Absolute                 end catch               ",1031,1029,2,0,0,3093
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",441,258,183,329,0,39733
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",390,228,162,265,0,35167
"with fs as (select database_id, type, CAST ( size as BIGINT ) / 128 size from [master].[sys].[master_files]) select db.name, db.database_id, db.recovery_model_desc, db.state_desc, db.is_in_standby, (SELECT SUM ( CAST ( size as BIGINT ) ) from fs where fs.database_id = db.database_id) DBSizeMB, ag.name as ag_name, ag_rep_states.role_desc, ag_rep_states.operational_state_desc, ag_rep.secondary_role_allow_connections_desc, ls.primary_id, ag.group_id, ag.cluster_type, db.service_broker_guid, is_cdc_enabled from [master].[sys].[databases] db LEFT OUTER JOIN [master].[sys].[availability_databases_cluster] dbc ON db.group_database_id = dbc.group_database_id LEFT OUTER JOIN [master].[sys].[availability_groups] ag ON dbc.group_id = ag.group_id LEFT OUTER JOIN [master].[sys].[dm_hadr_availability_replica_states] ag_rep_states ON db.replica_id = ag_rep_states.replica_id LEFT OUTER JOIN [master].[sys].[availability_replicas] ag_rep ON db.replica_id = ag_rep.replica_id LEFT OUTER JOIN [msdb].[dbo].[log_shipping_monitor_primary] ls ON db.name collate database_default = ls.primary_database collate database_default WHERE source_database_id is NULL",353,273,80,423,0,707
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info; ",197,35,162,20784,400,394
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0   ",162,29,133,18008,366,162
"SELECT ag_rep.group_id, ag_rep.replica_server_name, ag_rep_states.synchronization_health_desc, ag_rep_cluster_nodes.node_name FROM sys.availability_groups ag INNER JOIN sys.availability_replicas ag_rep ON ag.group_id = ag_rep.group_id INNER JOIN sys.dm_hadr_availability_replica_states ag_rep_states on ag.group_id = ag_rep_states.group_id and ag_rep_states.is_local = 1 INNER JOIN sys.dm_hadr_availability_replica_cluster_nodes ag_rep_cluster_nodes on ag.name = ag_rep_cluster_nodes.group_name and ag_rep.replica_server_name = ag_rep_cluster_nodes.replica_server_name",146,112,34,162,0,880
"(@DatabaseName NVarChar(max))begin try   use msdb;  Select distinct t1.name ,       (dense_rank() over (order by backup_start_date desc,t3.backup_set_id))%2 as l1 ,       (dense_rank() over (order by backup_start_date desc,t3.backup_set_id,t6.physical_device_name))%2 as l2 ,       t3.user_name ,       t3.backup_set_id ,       t3.name as backup_name ,       t3.description ,       (datediff( ss,  t3.backup_start_date, t3.backup_finish_date))/60.0 as duration ,       t3.backup_start_date ,       t3.backup_finish_date ,       t3.type as [type] ,       case when (t3.backup_size/1024.0) < 1024 then (t3.backup_size/1024.0)                  when (t3.backup_size/1048576.0) < 1024 then (t3.backup_size/1048576.0)          else (t3.backup_size/1048576.0/1024.0)          end as backup_size  ,       case when (t3.backup_size/1024.0) < 1024 then 'KB'                  when (t3.backup_size/1048576.0) < 1024 then 'MB'          else 'GB'          end as backup_size_unit  ,       t3.first_lsn ,       t3.last_lsn ,       case when t3.differential_base_lsn is null then 'Not Applicable'          else convert( varchar(100),t3.differential_base_lsn)          end as [differential_base_lsn] ,       t6.physical_device_name ,       t6.device_type as [device_type] ,       t3.recovery_model   from sys.databases t1  inner join backupset t3 on (t3.database_name = t1.name )   left outer join backupmediaset t5 on ( t3.media_set_id = t5.media_set_id )  left outer join backupmediafamily t6 on ( t6.media_set_id = t5.media_set_id )  where (t1.name = @DatabaseName)  order by backup_start_date desc,t3.backup_set_id,t6.physical_device_name;   end try  begin catch   select 1 as user_name, 1 as backup_set_id, 1 as backup_name, 1 as description, 1 as duration, 1 as backup_start_date, 1 as backup_finish_date,1 as type, 1 as backup_size, 1 as backup_size_unit ,       ERROR_SEVERITY() as first_lsn ,       ERROR_STATE() as last_lsn ,       1 as differential_base_lsn ,       ERROR_MESSAGE() as physical_device_name ,       1 as device_type, 1 as recovery_model ,       -100 as l1 ,       ERROR_NUMBER() as l2  end catch",138,118,20,8538,0,276
"CREATE   PROCEDURE [dbo].[sp_syscollector_purge_collection_logs]     @reference_date datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     SET NOCOUNT ON      -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))     BEGIN         RAISERROR(14677, -1, -1, 'dc_proxy')         RETURN(1) -- Failure     END      IF (@reference_date IS NULL)     BEGIN         SET @reference_date = GETDATE()     END          -- An expired log record is any record of a collection set that is older than      -- the reference date minus the collection set's days_until_expiration     CREATE TABLE #purged_log_ids (log_id BIGINT, package_execution_id uniqueidentifier)          -- Identify logs to purge based on following criteria     -- a) limit max batch size      -- b) do not delete last log record that is a root log record for a collection set     INSERT INTO #purged_log_ids     SELECT TOP (@delete_batch_size) log_id, package_execution_id     FROM syscollector_execution_log_internal as l     INNER JOIN syscollector_collection_sets s ON l.collection_set_id = s.collection_set_id     WHERE s.days_until_expiration > 0     AND @reference_date >= DATEADD(DAY, s.days_until_expiration, l.finish_time)     AND log_id NOT IN (                         SELECT TOP 1 log_id  from syscollector_execution_log_internal                          WHERE parent_log_id IS NULL                          AND collection_set_id = l.collection_set_id                         ORDER BY start_time DESC                         )      DECLARE @purge_log_count int     SELECT @purge_log_count  = COUNT(log_id)      FROM  #purged_log_ids      -- Delete all ssis log records pertaining to expired logs     DELETE FROM dbo.sysssislog         FROM dbo.sysssislog AS s         INNER JOIN #purged_log_ids AS i ON i.package_execution_id = s.executionid              -- Then delete the actual logs     DELETE FROM syscollector_execution_log_internal         FROM syscollector_execution_log_internal AS l         INNER Join #purged_log_ids AS i ON i.log_id = l.log_id       DROP TABLE #purged_log_ids      -- making sure that delete # record does not exceed given delete batch size     DECLARE @orphaned_record_cleanup_count int     SET @orphaned_record_cleanup_count = @delete_batch_size - @purge_log_count      -- Go for another round to cleanup the orphans     -- Ideally, the log heirarchy guarantees that a finish time by a parent log will always     -- be higher than the finish time of any of its descendants.     -- The purge step however does not delete log records with a null finish time     -- A child log can have a null finish time while its parent is closed if there is an     -- error in execution that causes the log to stay open.     -- If such a child log exists, its parent will be purged leaving it as an orphan          -- get orphan records and all their descendants in a cursor and purge them     DECLARE orphaned_log_cursor INSENSITIVE CURSOR FOR             SELECT TOP (@orphaned_record_cleanup_count) log_id              FROM syscollector_execution_log_internal             WHERE parent_log_id NOT IN (                 SELECT log_id FROM syscollector_execution_log_internal             )             FOR READ ONLY                  DECLARE @log_id BIGINT      -- for every orphan, delete all its remaining tree     -- this is supposedly a very small fraction of the entire log     OPEN orphaned_log_cursor         FETCH orphaned_log_cursor INTO @log_id     WHILE @@FETCH_STATUS = 0     BEGIN         EXEC sp_syscollector_delete_execution_log_tree @log_id = @log_id, @from_collection_set = 0         FETCH orphaned_log_cursor INTO @log_id     END          CLOSE orphaned_log_cursor     DEALLOCATE orphaned_log_cursor END ",111,110,1,46783,90,223
"       SELECT db_id() AS database_id,       COUNT_BIG(*) AS [NumExternalStats]       FROM sys.tables t WITH(nolock) INNER JOIN sys.stats s WITH(nolock) ON t.object_id = s.object_id       WHERE t.is_external=1     ",111,66,45,3704,0,2903
"()                 begin try                 if (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1                 begin                 declare @curr_tracefilename varchar(500) ;                 declare @base_tracefilename varchar(500) ;                 declare @indx int ;                 declare @path_separator CHAR(1) ;                 set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;                  select @curr_tracefilename = path from sys.traces where is_default = 1 ;                 set @curr_tracefilename = reverse(@curr_tracefilename);                 select @indx  = patindex('%'+@path_separator+'%', @curr_tracefilename) ;                 set @curr_tracefilename = reverse(@curr_tracefilename) ;                 set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  select  (dense_rank() over (order by StartTime desc))%2 as l1                 ,       convert(int, EventClass) as EventClass                 ,       DatabaseName                 ,       Filename                 ,       (Duration/1000) as Duration                 ,       StartTime                 ,       EndTime                 ,       (IntegerData*8.0/1024) as ChangeInSize                 from ::fn_trace_gettable( @base_tracefilename, default )                 left outer join sys.databases as d on (d.name = DB_NAME())                 where EventClass >=  92      and EventClass <=  95        and ServerName = @@servername   and DatabaseName = db_name()  and (d.create_date < EndTime)                 order by StartTime desc ;                 end     else                 select -1 as l1, 0 as EventClass, 0 DatabaseName, 0 as Filename, 0 as Duration, 0 as StartTime, 0 as EndTime,0 as ChangeInSize                 end try                 begin catch                 select -100 as l1                 ,       ERROR_NUMBER() as EventClass                 ,       ERROR_SEVERITY() DatabaseName                 ,       ERROR_STATE() as Filename                 ,       ERROR_MESSAGE() as Duration                 ,       1 as StartTime, 1 as EndTime,1 as ChangeInSize                 end catch               ",99,97,2,1286,0,99
"       SELECT       db_id() as database_id,       sm.[is_inlineable] AS InlineableScalarCount,​       sm.[inline_type] AS InlineType,​       COUNT_BIG(*) AS ScalarCount, ​       COUNT_BIG(CASE WHEN sm.[definition] LIKE '%getdate%' OR       sm.[definition] LIKE '%getutcdate%' OR ​       sm.[definition] LIKE '%sysdatetime%' OR​       sm.[definition] LIKE '%sysu​tcdatetime%' OR​       sm.[definition] LIKE '%sysdatetimeoffset%' OR​       sm.[definition] LIKE '%CURRENT_TIMESTAMP%'​       THEN 1       END) AS ScalarCountWithDate       FROM    [sys].[objects] o​       INNER JOIN    [sys].[sql_modules] sm       ON o.[object_id] = sm.[object_id]​       WHERE   o.[type] = 'FN'​       GROUP BY ​       sm.[is_inlineable],​       sm.[inline_type]     ",97,59,38,154,0,8793
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups        SELECT arcn.replica_server_name AS [ReplicaName], cm.member_name AS [NodeName], cm.member_type AS [MemberType], cm.member_state AS [MemberState], ISNULL(cm.number_of_quorum_votes, -1) AS [NumberOfQuorumVotes], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/ReplicaClusterNode[@ReplicaName=' + quotename(arcn.replica_server_name,'''') + ' and @NodeName=' + quotename(cm.member_name,'''') + ']' AS [Urn] FROM #tmpag_availability_groups AS AG INNER JOIN master.sys.dm_hadr_availability_replica_cluster_nodes AS arcn ON arcn.group_name=AG.name LEFT OUTER JOIN master.sys.dm_hadr_cluster_members AS cm ON UPPER(arcn.node_name) = UPPER(cm.member_name) WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups       ",94,76,18,5,0,94
"()begin try  use msdb;  declare @enable int; select @enable = convert(int, value_in_use) from sys.configurations where name = 'default trace enabled'  if @enable = 1   begin          declare @curr_tracefilename varchar(500);         declare @base_tracefilename varchar(500);         declare @status int;          declare @indx int;            declare @temp_trace table (                  Error int         ,       StartTime datetime         ,       HostName sysname collate database_default null         ,       ApplicationName sysname collate database_default  null         ,       LoginName sysname collate database_default null         ,       Severity int         ,       DatabaseName sysname collate database_default null         ,       TextData nvarchar(max) collate database_default          );          declare @path_separator CHAR(1) ;         set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;          select @status=status, @curr_tracefilename=path from sys.traces where is_default = 1 ;         set @curr_tracefilename = reverse(@curr_tracefilename)          select @indx  = patindex('%'+@path_separator+'%', @curr_tracefilename)           set @curr_tracefilename = reverse(@curr_tracefilename)          set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  insert into @temp_trace          select Error         ,       StartTime         ,       HostName         ,       ApplicationName         ,       LoginName         ,       Severity         ,       DatabaseName         ,       TextData           from ::fn_trace_gettable( @base_tracefilename, default )          where substring(TextData, 20, 15) like '%Backup%' and TextData like '%Error%' and ServerName = @@servername ;                    select (row_number() over(order by StartTime desc))%2 as l1         ,       right( right( TextData, len(TextData) - patindex('%BACKUP%',TextData) ) , len(right( TextData, len(TextData) - patindex('%BACKUP%',TextData) )) - patindex('%BACKUP%',right( TextData, len(TextData) - patindex('%BACKUP%',TextData) )) - 10 ) as ErrorMessage         ,       Error         ,       Severity         ,       StartTime         ,       HostName         ,       ApplicationName         ,       LoginName         ,       DatabaseName           from @temp_trace            where DatabaseName = '""  & Parameters!DatabaseName.Value &  ""'           order by StartTime desc  end else  begin          select top 0 1 as ErrorMessage, 1 as Error, 1 as Severity, 1 as StartTime,1 as HostName, 1 as ApplicationName,1 as LoginName, 1 as DatabaseName, 1 as l1  end  end try  begin catch  select ERROR_MESSAGE() as ErrorMessage ,       ERROR_NUMBER() as Error ,       ERROR_SEVERITY() as Severity ,       ERROR_STATE() as StartTime ,       1 as HostName, 1 as ApplicationName,1 as LoginName, 1 as DatabaseName ,       -100 as l1  end catch",87,86,1,0,0,262
"()begin try  use msdb;  declare @enable int; select @enable = convert(int, value_in_use) from sys.configurations where name = 'default trace enabled'  if @enable = 1   begin          declare @curr_tracefilename varchar(500);         declare @base_tracefilename varchar(500);         declare @status int;          declare @indx int;            declare @temp_trace table (                  Error int         ,       StartTime datetime         ,       HostName sysname collate database_default null         ,       ApplicationName sysname collate database_default  null         ,       LoginName sysname collate database_default null         ,       Severity int         ,       DatabaseName sysname collate database_default null         ,       TextData nvarchar(max) collate database_default          );          declare @path_separator CHAR(1) ;         set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;          select @status=status, @curr_tracefilename=path from sys.traces where is_default = 1 ;         set @curr_tracefilename = reverse(@curr_tracefilename)          select @indx  = patindex('%'+@path_separator+'%', @curr_tracefilename)           set @curr_tracefilename = reverse(@curr_tracefilename)          set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  insert into @temp_trace          select Error         ,       StartTime         ,       HostName         ,       ApplicationName         ,       LoginName         ,       Severity         ,       DatabaseName         ,       TextData           from ::fn_trace_gettable( @base_tracefilename, default )          where substring(TextData, 20, 15) like '%Backup%' and TextData like '%Error%' and ServerName = @@servername ;                    select (row_number() over(order by StartTime desc))%2 as l1         ,       right( right( TextData, len(TextData) - patindex('%BACKUP%',TextData) ) , len(right( TextData, len(TextData) - patindex('%BACKUP%',TextData) )) - patindex('%BACKUP%',right( TextData, len(TextData) - patindex('%BACKUP%',TextData) )) - 10 ) as ErrorMessage         ,       Error         ,       Severity         ,       StartTime         ,       HostName         ,       ApplicationName         ,       LoginName         ,       DatabaseName           from @temp_trace            where DatabaseName = '""  & Parameters!DatabaseName.Value &  ""'           order by StartTime desc  end else  begin          select top 0 1 as ErrorMessage, 1 as Error, 1 as Severity, 1 as StartTime,1 as HostName, 1 as ApplicationName,1 as LoginName, 1 as DatabaseName, 1 as l1  end  end try  begin catch  select ERROR_MESSAGE() as ErrorMessage ,       ERROR_NUMBER() as Error ,       ERROR_SEVERITY() as Severity ,       ERROR_STATE() as StartTime ,       1 as HostName, 1 as ApplicationName,1 as LoginName, 1 as DatabaseName ,       -100 as l1  end catch",86,85,1,0,0,260
"()                 begin try                 if (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1                 begin                 declare @curr_tracefilename varchar(500) ;                 declare @base_tracefilename varchar(500) ;                 declare @indx int ;                 declare @path_separator CHAR(1) ;                 set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;                  select @curr_tracefilename = path from sys.traces where is_default = 1 ;                 set @curr_tracefilename = reverse(@curr_tracefilename);                 select @indx  = patindex('%'+@path_separator+'%', @curr_tracefilename) ;                 set @curr_tracefilename = reverse(@curr_tracefilename) ;                 set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  select  (dense_rank() over (order by StartTime desc))%2 as l1                 ,       convert(int, EventClass) as EventClass                 ,       DatabaseName                 ,       Filename                 ,       (Duration/1000) as Duration                 ,       StartTime                 ,       EndTime                 ,       (IntegerData*8.0/1024) as ChangeInSize                 from ::fn_trace_gettable( @base_tracefilename, default )                 left outer join sys.databases as d on (d.name = DB_NAME())                 where EventClass >=  92      and EventClass <=  95        and ServerName = @@servername   and DatabaseName = db_name()  and (d.create_date < EndTime)                 order by StartTime desc ;                 end     else                 select -1 as l1, 0 as EventClass, 0 DatabaseName, 0 as Filename, 0 as Duration, 0 as StartTime, 0 as EndTime,0 as ChangeInSize                 end try                 begin catch                 select -100 as l1                 ,       ERROR_NUMBER() as EventClass                 ,       ERROR_SEVERITY() DatabaseName                 ,       ERROR_STATE() as Filename                 ,       ERROR_MESSAGE() as Duration                 ,       1 as StartTime, 1 as EndTime,1 as ChangeInSize                 end catch               ",82,81,1,4,0,82
"       SELECT       db_id() as database_id,       sm.[is_inlineable] AS InlineableScalarCount,​       sm.[inline_type] AS InlineType,​       COUNT_BIG(*) AS ScalarCount, ​       COUNT_BIG(CASE WHEN sm.[definition] LIKE '%getdate%' OR       sm.[definition] LIKE '%getutcdate%' OR ​       sm.[definition] LIKE '%sysdatetime%' OR​       sm.[definition] LIKE '%sysu​tcdatetime%' OR​       sm.[definition] LIKE '%sysdatetimeoffset%' OR​       sm.[definition] LIKE '%CURRENT_TIMESTAMP%'​       THEN 1       END) AS ScalarCountWithDate       FROM    [sys].[objects] o​       INNER JOIN    [sys].[sql_modules] sm       ON o.[object_id] = sm.[object_id]​       WHERE   o.[type] = 'FN'​       GROUP BY ​       sm.[is_inlineable],​       sm.[inline_type]     ",82,53,29,2215,0,7399
"(@P1 nvarchar(3))with fs as (select database_id, type, CAST ( size as BIGINT ) / 128 size from [master].[sys].[master_files]) select db.name, db.database_id, db.recovery_model_desc, db.state_desc, db.is_in_standby, (SELECT SUM ( CAST ( size as BIGINT ) ) from fs where fs.database_id = db.database_id) DBSizeMB, ag.name as ag_name, ag_rep_states.role_desc, ag_rep_states.operational_state_desc, ag_rep.secondary_role_allow_connections_desc, ls.primary_id, ag.group_id, isnull(ag.cluster_type, 1) as cluster_type, db.service_broker_guid, is_cdc_enabled from [master].[sys].[databases] db LEFT OUTER JOIN [master].[sys].[availability_databases_cluster] dbc ON db.group_database_id = dbc.group_database_id LEFT OUTER JOIN [master].[sys].[availability_groups] ag ON dbc.group_id = ag.group_id LEFT OUTER JOIN [master].[sys].[dm_hadr_availability_replica_states] ag_rep_states ON db.replica_id = ag_rep_states.replica_id LEFT OUTER JOIN [master].[sys].[availability_replicas] ag_rep ON db.replica_id = ag_rep.replica_id LEFT OUTER JOIN [msdb].[dbo].[log_shipping_monitor_primary] ls ON db.name collate database_default = ls.primary_database collate database_default WHERE db.name = @P1",79,62,17,144,0,79
"()begin try select top 10 rank() over(order by (total_worker_time+0.0)/execution_count desc,sql_handle,statement_start_offset ) as row_no ,       (rank() over(order by (total_worker_time+0.0)/execution_count desc,sql_handle,statement_start_offset ))%2 as l1 ,       creation_time ,       last_execution_time  ,       (total_worker_time+0.0)/1000 as total_worker_time ,       (total_worker_time+0.0)/(execution_count*1000) as [AvgCPUTime] ,       total_logical_reads as [LogicalReads] ,       total_logical_writes as [LogicalWrites] ,       execution_count ,       total_logical_reads+total_logical_writes as [AggIO] ,       (total_logical_reads+total_logical_writes)/(execution_count+0.0) as [AvgIO] ,       case when sql_handle IS NULL                 then ' '                 else ( substring(st.text,(qs.statement_start_offset+2)/2,       (case when qs.statement_end_offset = -1         then len(convert(nvarchar(MAX),st.text))*2      else qs.statement_end_offset    end - qs.statement_start_offset) /2  ) )         end as query_text  ,       db_name(st.dbid) as db_name ,       st.objectid as object_id from sys.dm_exec_query_stats  qs cross apply sys.dm_exec_sql_text(sql_handle) st where total_worker_time  > 0  order by [AvgCPUTime] desc end try begin catch select -100 as row_no ,       1 as l1, 1 as create_time,1 as last_execution_time,1 as total_worker_time,1 as AvgCPUTime,1 as LogicalReads,1 as LogicalWrites ,       ERROR_NUMBER() as execution_count ,       ERROR_SEVERITY() as AggIO ,       ERROR_STATE() as AvgIO ,       ERROR_MESSAGE() as query_text ,       0 as db_name ,       0 as object_name end catch",79,56,23,47381,795,159
" 	SELECT 	CASE 		WHEN name like  '%msdtcprx.dll%' THEN 'msdtcprx' 		WHEN name like  '%sqljdbc_xa.dll%' THEN 'sqljdbc_xa' 		ELSE NULL 	END AS LoadedModules, 	COUNT(1) AS ModuleCount         FROM sys.dm_os_loaded_modules WITH (NOLOCK)         WHERE name like  '%msdtcprx.dll%' 	OR name like  '%sqljdbc_xa.dll%'         GROUP BY 	CASE WHEN name like  '%msdtcprx.dll%' THEN 'msdtcprx' 		WHEN name like  '%sqljdbc_xa.dll%' THEN 'sqljdbc_xa' 		ELSE NULL 	END;     ",76,76,0,0,0,6914
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",75,49,26,3682,0,6830
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info;",75,75,0,3692,0,75
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",73,63,10,89027,0,219
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",70,42,28,2338,0,6355
"(@P1 nvarchar(7))with fs as (select database_id, type, CAST ( size as BIGINT ) / 128 size from [master].[sys].[master_files]) select db.name, db.database_id, db.recovery_model_desc, db.state_desc, db.is_in_standby, (SELECT SUM ( CAST ( size as BIGINT ) ) from fs where fs.database_id = db.database_id) DBSizeMB, ag.name as ag_name, ag_rep_states.role_desc, ag_rep_states.operational_state_desc, ag_rep.secondary_role_allow_connections_desc, ls.primary_id, ag.group_id, isnull(ag.cluster_type, 1) as cluster_type, db.service_broker_guid, is_cdc_enabled from [master].[sys].[databases] db LEFT OUTER JOIN [master].[sys].[availability_databases_cluster] dbc ON db.group_database_id = dbc.group_database_id LEFT OUTER JOIN [master].[sys].[availability_groups] ag ON dbc.group_id = ag.group_id LEFT OUTER JOIN [master].[sys].[dm_hadr_availability_replica_states] ag_rep_states ON db.replica_id = ag_rep_states.replica_id LEFT OUTER JOIN [master].[sys].[availability_replicas] ag_rep ON db.replica_id = ag_rep.replica_id LEFT OUTER JOIN [msdb].[dbo].[log_shipping_monitor_primary] ls ON db.name collate database_default = ls.primary_database collate database_default WHERE db.name = @P1",68,54,14,144,0,68
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       i.optimize_for_sequential_key,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       i.optimize_for_sequential_key,       t.object_type,       i.is_disabled     ",66,39,27,927,0,6001
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info; ",65,65,0,3356,0,65
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       i.optimize_for_sequential_key,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       i.optimize_for_sequential_key,       t.object_type,       i.is_disabled     ",63,37,26,928,0,5759
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups               select replica_id, group_id into #tmpardb_availability_replicas from master.sys.availability_replicas              select replica_id, group_database_id, database_name,is_database_joined,is_failover_ready,is_pending_secondary_suspend,recovery_lsn,truncation_lsn into #tmpardb_database_replica_cluster_states from master.sys.dm_hadr_database_replica_cluster_states              select replica_id, is_local into #tmpardb_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id, group_database_id,synchronization_state, is_suspended into #tmpardb_database_replica_states from master.sys.dm_hadr_database_replica_states        SELECT dbcs.database_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityDatabase[@Name=' + quotename(dbcs.database_name,'''') + ']' AS [Urn], ISNULL(dbrs.synchronization_state, 0) AS [SynchronizationState], ISNULL(dbrs.is_suspended, 0) AS [IsSuspended], ISNULL(dbcs.is_database_joined, 0) AS [IsJoined] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpardb_availability_replicas AS AR ON AR.group_id=AG.group_id INNER JOIN #tmpardb_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1 INNER JOIN #tmpardb_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id LEFT OUTER JOIN #tmpardb_database_replica_states AS dbrs ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpardb_availability_replicas              DROP TABLE #tmpardb_database_replica_cluster_states              DROP TABLE #tmpardb_availability_replica_states              DROP TABLE #tmpardb_database_replica_states              drop table #tmpag_availability_groups       ",62,45,17,254,1,62
" CREATE   PROCEDURE autoadmin_fetch_system_flags AS BEGIN 	BEGIN TRANSACTION 		DECLARE @value NVARCHAR(MAX)  		SELECT @value = value FROM autoadmin_system_flags WHERE LOWER(name) = LOWER(N'SSMBackup2WAEverConfigured') 		 		IF (LOWER(ISNULL(@value, '')) <> N'true') 		BEGIN 			DECLARE @is_configured BIT 			SET @is_configured = 0 			 			IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_db_config(NULL) WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_instance_config() WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_db_config(NULL) WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_instance_config() WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			 			IF (@is_configured = 1) 			BEGIN 				MERGE autoadmin_system_flags AS target 				USING (SELECT LOWER(N'SSMBackup2WAEverConfigured') as name) AS source 				ON source.name = target.name 				WHEN MATCHED THEN UPDATE SET target.value = N'true' 				WHEN NOT MATCHED THEN INSERT VALUES (N'SSMBackup2WAEverConfigured', N'true'); 			END 		END 	COMMIT TRANSACTION 	     SELECT name, 	value  	FROM autoadmin_system_flags END ",59,59,0,527,3,59
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",57,43,14,81203,0,404
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",52,52,0,0,0,157
" DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",51,51,0,0,0,154
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",50,37,13,90,1,202
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0   ",49,49,0,2678,0,49
"       SELECT ISNULL(AVG(c),0) AS [XTPAvgNumOfIndexes],       ISNULL(MAX(c),0) AS [XTPMaxNumOfIndexes], db_id() AS database_id       FROM (SELECT COUNT_BIG(*) AS c       FROM sys.indexes i WITH(nolock) JOIN sys.tables t WITH(nolock) ON i.object_id=t.object_id WHERE t.is_memory_optimized=1       GROUP BY i.object_id) a     ",47,26,21,551,0,4304
"       SELECT ISNULL(AVG(c),0) AS [XTPAvgNumOfIndexes],       ISNULL(MAX(c),0) AS [XTPMaxNumOfIndexes], db_id() AS database_id       FROM (SELECT COUNT_BIG(*) AS c       FROM sys.indexes i WITH(nolock) JOIN sys.tables t WITH(nolock) ON i.object_id=t.object_id WHERE t.is_memory_optimized=1       GROUP BY i.object_id) a     ",47,26,21,541,0,4238
" CREATE   PROCEDURE autoadmin_fetch_system_flags AS BEGIN 	BEGIN TRANSACTION 		DECLARE @value NVARCHAR(MAX)  		SELECT @value = value FROM autoadmin_system_flags WHERE LOWER(name) = LOWER(N'SSMBackup2WAEverConfigured') 		 		IF (LOWER(ISNULL(@value, '')) <> N'true') 		BEGIN 			DECLARE @is_configured BIT 			SET @is_configured = 0 			 			IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_db_config(NULL) WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_instance_config() WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_db_config(NULL) WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_instance_config() WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			 			IF (@is_configured = 1) 			BEGIN 				MERGE autoadmin_system_flags AS target 				USING (SELECT LOWER(N'SSMBackup2WAEverConfigured') as name) AS source 				ON source.name = target.name 				WHEN MATCHED THEN UPDATE SET target.value = N'true' 				WHEN NOT MATCHED THEN INSERT VALUES (N'SSMBackup2WAEverConfigured', N'true'); 			END 		END 	COMMIT TRANSACTION 	     SELECT name, 	value  	FROM autoadmin_system_flags END ",45,45,0,275,3,45
"       SELECT db_id() AS database_id, o.[type] as ModuleType, COUNT_BIG(*) as ModuleCount       FROM sys.objects AS o WITH(nolock)       WHERE o.type in ('AF', 'F', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TA', 'TF', 'TR', 'X', 'C', 'D', 'PG', 'SN', 'SO', 'SQ', 'TT', 'UQ', 'V')       GROUP BY o.[type]     ",40,25,15,124,0,3687
"       WITH CTE AS (       SELECT DISTINCT i.object_id oid, i.index_id iid       FROM sys.indexes i WITH(nolock)       JOIN sys.index_columns ic WITH(nolock) ON i.object_id = ic.object_id       JOIN sys.columns c WITH(nolock) ON ic.column_id = c.column_id AND c.object_id = i.object_id       WHERE c.system_type_id = 43 AND c.user_type_id = 43 -- only datetimeoffset columns       AND ic.key_ordinal != 0 -- only key columns       )       SELECT COUNT_BIG(*) AS [NumDatetimeoffsetCols], db_id() AS database_id       FROM CTE     ",39,23,16,553,0,3587
"SELECT P.*, P.ID AS ProjectID, A.ID AS AuditeeUnitID, P.Name AS ProjectName, D.DEPT_NAME AS DepartmentName, PR.Name AS ProcessName, PO.Name AS PortionName  FROM PROJECT P INNER JOIN AUDITEEUNIT A ON P.AuditeeUnitID = A.ID LEFT JOIN DEPARTMENT D ON A.DepartmentID = D.ID LEFT JOIN PROCESS PR ON A.ProcessID = PR.ID LEFT JOIN PORTION PO ON A.PortionID = PO.ID WHERE A.Year = 2021 AND A.TypeID = 3 AND A.CreatedDepartmentID = 3087 ORDER BY PO.Name, P.ActualStartDate",39,28,11,4871,0,39
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",36,35,1,6261,74,109
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1)) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",35,26,9,81,0,70
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",34,27,7,85,2,104
"SELECT P.*, P.ID AS ProjectID, A.ID AS AuditeeUnitID, P.Name AS ProjectName, D.DEPT_NAME AS DepartmentName, PR.Name AS ProcessName, PO.Name AS PortionName  FROM PROJECT P INNER JOIN AUDITEEUNIT A ON P.AuditeeUnitID = A.ID LEFT JOIN DEPARTMENT D ON A.DepartmentID = D.ID LEFT JOIN PROCESS PR ON A.ProcessID = PR.ID LEFT JOIN PORTION PO ON A.PortionID = PO.ID WHERE A.Year = 2019 AND A.TypeID = 3 ORDER BY PO.Name, P.ActualStartDate",34,25,9,4575,0,34
"       select 1 as name, -- Temp DB       case mf.type_desc       when 'ROWS' then 1       when 'LOG' then 2       end as 'type',       CAST(SUM(num_of_reads) as nvarchar(128)) as total_num_of_reads,       CAST(SUM(num_of_bytes_read) as nvarchar(128)) as total_num_of_bytes_read,       CAST(SUM(io_stall_read_ms) as nvarchar(128)) as total_io_stall_read_ms,       CAST(SUM(num_of_writes) as nvarchar(128)) as total_num_of_writes,       CAST(SUM(num_of_bytes_written) as nvarchar(128)) as total_num_of_bytes_written,       CAST(SUM(io_stall_write_ms) as nvarchar(128)) as total_io_stall_write_ms,       COUNT_BIG(*) as total       from sys.dm_io_virtual_file_stats(NULL, NULL) fs, sys.master_files mf       where fs.database_id = mf.database_id and fs.file_id = mf.file_id and fs.database_id = 2 and (fs.num_of_reads != 0 OR fs.num_of_writes != 0)       group by mf.name, mf.type, mf.type_desc        UNION ALL        select 2 as name, -- User DBs       case mf.type_desc       when 'ROWS' then 1       when 'LOG' then 2       end as 'type',       CAST(SUM(num_of_reads) as nvarchar(128)) as total_num_of_reads,       CAST(SUM(num_of_bytes_read) as nvarchar(128)) as total_num_of_bytes_read,       CAST(SUM(io_stall_read_ms) as nvarchar(128)) as total_io_stall_read_ms,       CAST(SUM(num_of_writes) as nvarchar(128)) as total_num_of_writes,       CAST(SUM(num_of_bytes_written) as nvarchar(128)) as total_num_of_bytes_written,       CAST(SUM(io_stall_write_ms) as nvarchar(128)) as total_io_stall_write_ms,       COUNT_BIG(*) as total       from sys.dm_io_virtual_file_stats(NULL, NULL) fs, sys.master_files mf       where fs.database_id = mf.database_id and fs.file_id = mf.file_id and fs.database_id > 4 and (fs.num_of_reads != 0 OR fs.num_of_writes != 0)       group by mf.type, mf.type_desc        UNION ALL        select 3 as name, -- System DBs       case mf.type_desc       when 'ROWS' then 1       when 'LOG' then 2       end as 'type',       CAST(SUM(num_of_reads) as nvarchar(128)) as total_num_of_reads,       CAST(SUM(num_of_bytes_read) as nvarchar(128)) as total_num_of_bytes_read,       CAST(SUM(io_stall_read_ms) as nvarchar(128)) as total_io_stall_read_ms,       CAST(SUM(num_of_writes) as nvarchar(128)) as total_num_of_writes,       CAST(SUM(num_of_bytes_written) as nvarchar(128)) as total_num_of_bytes_written,       CAST(SUM(io_stall_write_ms) as nvarchar(128)) as total_io_stall_write_ms,       COUNT_BIG(*) as total       from sys.dm_io_virtual_file_stats(NULL, NULL) fs, sys.master_files mf WITH(nolock)       where fs.database_id = mf.database_id and fs.file_id = mf.file_id and (fs.database_id = 1 OR fs.database_id = 3 OR fs.database_id = 4) and (fs.num_of_reads != 0 OR fs.num_of_writes != 0)       group by mf.type, mf.type_desc      ",30,30,0,111,0,153
"       SELECT db_id() AS database_id, o.[type] as ModuleType, COUNT_BIG(*) as ModuleCount       FROM sys.objects AS o WITH(nolock)       WHERE o.type in ('AF', 'F', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TA', 'TF', 'TR', 'X', 'C', 'D', 'PG', 'SN', 'SO', 'SQ', 'TT', 'UQ', 'V')       GROUP BY o.[type]     ",30,19,11,92,0,2762
" CREATE   PROCEDURE autoadmin_fetch_system_flags AS BEGIN 	BEGIN TRANSACTION 		DECLARE @value NVARCHAR(MAX)  		SELECT @value = value FROM autoadmin_system_flags WHERE LOWER(name) = LOWER(N'SSMBackup2WAEverConfigured') 		 		IF (LOWER(ISNULL(@value, '')) <> N'true') 		BEGIN 			DECLARE @is_configured BIT 			SET @is_configured = 0 			 			IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_db_config(NULL) WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_instance_config() WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_db_config(NULL) WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_instance_config() WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			 			IF (@is_configured = 1) 			BEGIN 				MERGE autoadmin_system_flags AS target 				USING (SELECT LOWER(N'SSMBackup2WAEverConfigured') as name) AS source 				ON source.name = target.name 				WHEN MATCHED THEN UPDATE SET target.value = N'true' 				WHEN NOT MATCHED THEN INSERT VALUES (N'SSMBackup2WAEverConfigured', N'true'); 			END 		END 	COMMIT TRANSACTION 	     SELECT name, 	value  	FROM autoadmin_system_flags END ",27,27,0,202,3,27
"SELECT P.*, P.ID AS ProjectID, A.ID AS AuditeeUnitID, P.Name AS ProjectName, D.DEPT_NAME AS DepartmentName, PR.Name AS ProcessName, PO.Name AS PortionName  FROM PROJECT P INNER JOIN AUDITEEUNIT A ON P.AuditeeUnitID = A.ID LEFT JOIN DEPARTMENT D ON A.DepartmentID = D.ID LEFT JOIN PROCESS PR ON A.ProcessID = PR.ID LEFT JOIN PORTION PO ON A.PortionID = PO.ID WHERE A.Year = 2019 AND A.TypeID = 3 AND A.CreatedDepartmentID = 3087 ORDER BY PO.Name, P.ActualStartDate",27,21,6,2672,0,380
"         create table #tmp_sp_get_sqlagent_properties         (auto_start int null, msx_server_name sysname null, sqlagent_type int null, startup_account nvarchar(255) null, sqlserver_restart int null, jobhistory_max_rows int null, jobhistory_max_rows_per_job int null, errorlog_file nvarchar(255) null, errorlogging_level int null, error_recipient nvarchar(30) null, monitor_autostart int null, local_host_server sysname null, job_shutdown_timeout int null, cmdexec_account varbinary(64) null, regular_connections int null, host_login_name sysname null, host_login_password varbinary(512) null, login_timeout int null, idle_cpu_percent int null, idle_cpu_duration int null, oem_errorlog int null, sysadmin_only int null, email_profile nvarchar(64) null, email_save_in_sent_folder int null, cpu_poller_enabled int null, replace_alert_tokens_enabled int null)         insert into #tmp_sp_get_sqlagent_properties(auto_start, msx_server_name, sqlagent_type, startup_account, sqlserver_restart, jobhistory_max_rows, jobhistory_max_rows_per_job, errorlog_file, errorlogging_level, error_recipient, monitor_autostart, local_host_server, job_shutdown_timeout, cmdexec_account, regular_connections, host_login_name, host_login_password, login_timeout, idle_cpu_percent, idle_cpu_duration, oem_errorlog, sysadmin_only, email_profile, email_save_in_sent_folder, cpu_poller_enabled, replace_alert_tokens_enabled)         exec msdb.dbo.sp_get_sqlagent_properties                  declare @DatabaseMailProfile nvarchar(255)         exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output'                  declare @AgentMailType int         exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'UseDatabaseMail', @param = @AgentMailType OUT, @no_output = N'no_output'                  declare @ServiceStartMode int         set @ServiceStartMode = 2         EXEC master.sys.xp_instance_regread 'HKEY_LOCAL_MACHINE', 'SYSTEM\CurrentControlSet\Services\SQLSERVERAGENT', N'Start', @ServiceStartMode OUTPUT                  declare @ServiceAccount nvarchar(512)         EXEC master.sys.xp_instance_regread 'HKEY_LOCAL_MACHINE', 'SYSTEM\CurrentControlSet\Services\SQLSERVERAGENT', N'ObjectName', @ServiceAccount OUTPUT                  declare @AgtGroup nvarchar(512)         exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\Setup', N'AGTGroup', @AgtGroup OUTPUT          SELECT CAST(serverproperty(N'Servername') AS sysname) AS [Name], ISNULL(tsgsp.msx_server_name,N'') AS [MsxServerName], tsgsp.sqlagent_type AS [JobServerType], CAST(tsgsp.sqlserver_restart AS bit) AS [SqlServerRestart], CAST(tsgsp.monitor_autostart AS bit) AS [SqlAgentRestart], tsgsp.jobhistory_max_rows AS [MaximumHistoryRows], tsgsp.jobhistory_max_rows_per_job AS [MaximumJobHistoryRows], tsgsp.errorlog_file AS [ErrorLogFile], tsgsp.errorlogging_level AS [AgentLogLevel], ISNULL(tsgsp.error_recipient,N'') AS [NetSendRecipient], tsgsp.job_shutdown_timeout AS [AgentShutdownWaitTime], ISNULL(tsgsp.email_profile,N'') AS [SqlAgentMailProfile], CAST(tsgsp.email_save_in_sent_folder AS bit) AS [SaveInSentFolder], CAST(tsgsp.oem_errorlog AS bit) AS [WriteOemErrorLog], CAST(tsgsp.cpu_poller_enabled AS bit) AS [IsCpuPollingEnabled], tsgsp.idle_cpu_percent AS [IdleCpuPercentage], tsgsp.idle_cpu_duration AS [IdleCpuDuration], tsgsp.login_timeout AS [LoginTimeout], ISNULL(tsgsp.host_login_name,N'') AS [HostLoginName], ISNULL(tsgsp.local_host_server,N'') AS [LocalHostAlias], CAST(tsgsp.auto_start AS bit) AS [SqlAgentAutoStart], CAST(tsgsp.replace_alert_tokens_enabled AS bit) AS [ReplaceAlertTokensEnabled], ISNULL(@DatabaseMailProfile,N'') AS [DatabaseMailProfile], ISNULL(@AgentMailType, 0) AS [AgentMailType], CAST(1 AS bit) AS [SysAdminOnly], @ServiceStartMode AS [ServiceStartMode], ISNULL(@ServiceAccount,N'') AS [ServiceAccount], ISNULL(suser_sname(sid_binary(ISNULL(@AgtGroup,N''))),N'') AS [AgentDomainGroup] FROM #tmp_sp_get_sqlagent_properties AS tsgsp  drop table #tmp_sp_get_sqlagent_properties          ",24,8,16,29,1,192
"()           declare @ms_now bigint            select @ms_now = ms_ticks from sys.dm_os_sys_info;            select top 15 record_id,           dateadd(ms, -1 * (@ms_now - [timestamp]), GetDate()) as EventTime,           SQLProcessUtilization,           SystemIdle,           100 - SystemIdle - SQLProcessUtilization as OtherProcessUtilization           from (           select           record.value('(./Record/@id)[1]', 'int') as record_id,           record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') as SystemIdle,           record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') as SQLProcessUtilization,           timestamp           from (           select timestamp, convert(xml, record) as record           from sys.dm_os_ring_buffers           where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'           and record like '%SystemHealth%') as x 		) as y  	order by record_id desc",23,23,0,0,0,70
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT udf.name AS [Name], udf.object_id AS [ID], udf.create_date AS [CreateDate], udf.modify_date AS [DateLastModified], ISNULL(sudf.name, N'') AS [Owner], CAST(case when udf.principal_id is null then 1 else 0 end AS bit) AS [IsSchemaOwned], SCHEMA_NAME(udf.schema_id) AS [Schema], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], usrt.name AS [DataType], s1ret_param.name AS [DataTypeSchema], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], CASE WHEN usrt.is_table_type = 1 THEN N'structured' ELSE N'' END AS [UserType], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id,N'ExecIsAnsiNullsOn'),0) AS bit) AS [AnsiNullsStatus], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], case when amudf.object_id is null then N'' else asmbludf.name end AS [AssemblyName], case when amudf.object_id is null then N'' else amudf.assembly_class end AS [ClassName], case when amudf.object_id is null then N'' else amudf.assembly_method end AS [MethodName], CAST(case when amudf.object_id is null then CAST(smudf.null_on_null_input AS bit) else amudf.null_on_null_input end AS bit) AS [ReturnsNullOnNullInput], case when amudf.object_id is null then case isnull(smudf.execute_as_principal_id, -1) when -1 then 1 when -2 then 2 else 3 end else case isnull(amudf.execute_as_principal_id, -1) when -1 then 1 when -2 then 2 else 3 end end AS [ExecutionContext], case when amudf.object_id is null then ISNULL(user_name(smudf.execute_as_principal_id),N'') else ISNULL(user_name(amudf.execute_as_principal_id), N'') end AS [ExecutionContextPrincipal], CAST(OBJECTPROPERTYEX(udf.object_id, N'IsDeterministic') AS bit) AS [IsDeterministic], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id,N'ExecIsQuotedIdentOn'),0) AS bit) AS [QuotedIdentifierStatus], ret_param.name AS [TableVariableName], ISNULL(sm.uses_native_compilation,0) AS [IsNativelyCompiled], CAST(ISNULL(sm.inline_type,0) AS bit) AS [InlineType], CAST(ISNULL(sm.is_inlineable,0) AS bit) AS [IsInlineable], ISNULL(smudf.definition, ssmudf.definition) AS [Definition] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.database_principals AS sudf ON sudf.principal_id = ISNULL(udf.principal_id, (OBJECTPROPERTY(udf.object_id, 'OwnerId'))) LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.assembly_modules AS amudf ON amudf.object_id = udf.object_id LEFT OUTER JOIN sys.assemblies AS asmbludf ON asmbludf.assembly_id = amudf.assembly_id LEFT OUTER JOIN sys.all_sql_modules AS sm ON sm.object_id = udf.object_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))and(udf.name=@_msparam_1 and SCHEMA_NAME(udf.schema_id)=@_msparam_2)",23,23,0,116,0,23
" CREATE   PROCEDURE autoadmin_fetch_system_flags AS BEGIN 	BEGIN TRANSACTION 		DECLARE @value NVARCHAR(MAX)  		SELECT @value = value FROM autoadmin_system_flags WHERE LOWER(name) = LOWER(N'SSMBackup2WAEverConfigured') 		 		IF (LOWER(ISNULL(@value, '')) <> N'true') 		BEGIN 			DECLARE @is_configured BIT 			SET @is_configured = 0 			 			IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_db_config(NULL) WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 container_url FROM managed_backup.fn_backup_instance_config() WHERE container_url IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_db_config(NULL) WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			ELSE IF EXISTS (SELECT TOP 1 credential_name FROM smart_admin.fn_backup_instance_config() WHERE credential_name IS NOT NULL) 			BEGIN 				SET @is_configured = 1	 			END 			 			IF (@is_configured = 1) 			BEGIN 				MERGE autoadmin_system_flags AS target 				USING (SELECT LOWER(N'SSMBackup2WAEverConfigured') as name) AS source 				ON source.name = target.name 				WHEN MATCHED THEN UPDATE SET target.value = N'true' 				WHEN NOT MATCHED THEN INSERT VALUES (N'SSMBackup2WAEverConfigured', N'true'); 			END 		END 	COMMIT TRANSACTION 	     SELECT name, 	value  	FROM autoadmin_system_flags END ",22,22,0,202,2,22
"       SELECT COUNT_BIG(*) AS NumOfNodes FROM [sys].[dm_hadr_cluster_members] WHERE member_type = 0     ",22,20,2,0,0,2017
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",20,20,0,20,0,20
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",20,19,1,4183,40,140
"       SELECT database_id, database_guid,       CASE       WHEN db_name(database_id) LIKE '%WideWorldImportersDW%' THEN 'WideWorldImportersDW'       WHEN db_name(database_id) LIKE '%WideWorldImporters%' THEN 'WideWorldImporters'       WHEN db_name(database_id) LIKE '%AdventureWorks2016CTP3%' THEN 'AdventureWorks2016CTP3'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2016CTP3%' THEN 'AdventureWorksDW2016CTP3'       WHEN db_name(database_id) LIKE '%AdventureWorks2014%' THEN 'AdventureWorks2014'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2014%' THEN 'AdventureWorksDW2014'       WHEN db_name(database_id) LIKE '%AdventureWorks2012%' THEN 'AdventureWorks2012'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2012%' THEN 'AdventureWorksDW2012'       WHEN db_name(database_id) LIKE '%AdventureWorks2008%' THEN 'AdventureWorks2008'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2008%' THEN 'AdventureWorksDW2008'       WHEN db_name(database_id) LIKE '%AdventureWorksDW%' THEN 'AdventureWorksDW'       WHEN db_name(database_id) LIKE '%AdventureWorks%' THEN 'AdventureWorks'       WHEN db_name(database_id) LIKE '%ReportServerTempDB%' THEN 'ReportServerTempDB'       WHEN db_name(database_id) LIKE '%ReportServer%' THEN 'ReportServer'       WHEN db_name(database_id) LIKE '%WSS_Content%' THEN 'WSS_Content'       WHEN db_name(database_id) LIKE '%MDW%' THEN 'MDW'       WHEN db_name(database_id) LIKE '%MicrosoftDynamicsAX_baseline%' THEN 'MicrosoftDynamicsAX_baseline'       WHEN db_name(database_id) LIKE '%MicrosoftDynamicsAX%' THEN 'MicrosoftDynamicsAX'       WHEN db_name(database_id) = 'master' THEN 'master'       WHEN db_name(database_id) = 'msdb' THEN 'msdb'       WHEN db_name(database_id) = 'tempdb' THEN 'tempdb'       WHEN db_name(database_id) = 'model' THEN 'model'       WHEN db_name(database_id) LIKE '%SharePoint_Config%' THEN 'SharePoint_Config'       WHEN db_name(database_id) LIKE '%SharePoint_AdminContent%' THEN 'SharePoint_AdminContent'       WHEN db_name(database_id) LIKE '%AppManagement%' THEN 'AppManagement'       WHEN db_name(database_id) LIKE '%Bdc_Service_DB%' THEN 'Bdc_Service_DB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_DB%' THEN 'Search_Service_Application_DB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_AnalyticsReportingStoreDB%' THEN 'Search_Service_Application_AnalyticsReportingStoreDB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_CrawlStoreDB%' THEN 'Search_Service_Application_CrawlStoreDB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_LinkStoreDB%' THEN 'Search_Service_Application_LinkStoreDB'       WHEN db_name(database_id) LIKE '%Secure_Store_Service_DB%' THEN 'Secure_Store_Service_DB'       WHEN db_name(database_id) LIKE '%SharePoint_Logging%' THEN 'SharePoint_Logging'       WHEN db_name(database_id) LIKE '%SettingsServiceDB%' THEN 'SettingsServiceDB'       WHEN db_name(database_id) LIKE '%User Profile Service Application_ProfileDB%' THEN 'User Profile Service Application_ProfileDB'       WHEN db_name(database_id) LIKE '%User Profile Service Application_SyncDB%' THEN 'User Profile Service Application_SyncDB'       WHEN db_name(database_id) LIKE '%User Profile Service Application_SocialDB%' THEN 'User Profile Service Application_SocialDB'       WHEN db_name(database_id) LIKE '%WordAutomationServices%' THEN 'WordAutomationServices'       WHEN db_name(database_id) LIKE '%Managed Metadata Service Application_Metadata%' THEN 'Managed Metadata Service Application_Metadata'       WHEN db_name(database_id) LIKE '%SharePoint Translation Services%' THEN 'SharePoint Translation Services'       WHEN db_name(database_id) LIKE '%ProjectWebApp%' THEN 'ProjectWebApp'       WHEN db_name(database_id) LIKE '%DefaultPowerPivotServiceApplicationDB%' THEN 'DefaultPowerPivotServiceApplicationDB'       WHEN db_name(database_id) LIKE '%PerformancePoint Service%' THEN 'PerformancePoint Service'       WHEN db_name(database_id) LIKE '%SessionStateService%' THEN 'SessionStateService'       WHEN db_name(database_id) = 'SSISDB' THEN 'SSISDB'       WHEN db_name(database_id) = 'DQS_MAIN' THEN 'DQS_MAIN'       ELSE 'Other'       END AS default_database_class       FROM sys.database_recovery_status WITH(nolock)     ",19,10,9,20,0,1795
SELECT target_data 									FROM sys.dm_xe_session_targets xet WITH(nolock) 									JOIN sys.dm_xe_sessions xes WITH(nolock) 									ON xes.address = xet.event_session_address 									WHERE xes.name = 'telemetry_xevents' 									AND xet.target_name = 'ring_buffer',19,17,2,0,0,513004
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",19,15,4,252,1,58
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",19,15,4,265,0,77
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1)) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",18,15,3,262,0,37
"       SELECT DB_ID() AS database_id,       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       COUNT_BIG(*) AS NumTables,       is_node,       is_edge       FROM sys.tables WITH(nolock)       GROUP BY       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       is_node,       is_edge     ",17,11,6,974,0,1603
"       select counter_name, cntr_value from sys.dm_os_performance_counters where object_name like '%External Scripts%'     ",17,17,0,0,0,1586
"       select counter_name, cntr_value from sys.dm_os_performance_counters where object_name like '%JSON Doc Stats%'     ",17,17,0,0,0,1564
"       SELECT         db_id() AS [database_id],         COUNT(*) AS [UpdatableLedgerTableCount]       FROM         sys.tables       WHERE         ledger_type = 2 AND is_dropped_ledger_table = 0     ",16,11,5,584,0,1529
"         DECLARE @msticks bigint, @mstickstime datetime, @LastHour datetime                 SELECT @mstickstime = GETDATE(), @msticks = ms_ticks from sys.dm_os_sys_info                 SELECT @LastHour = DATEADD(HOUR, -1, @mstickstime);                  WITH Quartiles AS (                 SELECT DISTINCT                     CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) EventDate,                        CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114) AS [EventTime],                        PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS MedianSQLCPU                            ,                        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS Q3SQLCPU                      ,                        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS Q1SQLCPU                   FROM (                     SELECT timestamp, CONVERT (xml, record) AS 'record'                     FROM sys.dm_os_ring_buffers                     WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'                       AND record LIKE '%<SystemHealth>%'                             ) AS t                      WHERE DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)) = DATEPART(HOUR, @LastHour)                      AND CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE) = CAST(@LastHour AS DATE)               ),               SimpleStats AS (                 SELECT                     CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) EventDate,                        CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114) AS [EventTime],                     MAX(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [MaxSQLCPU],                        MIN(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [MinSQLCPU],                        AVG(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [AvgSQLCPU]                   FROM (                     SELECT timestamp, CONVERT (xml, record) AS 'record'                     FROM sys.dm_os_ring_buffers                     WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'                       AND record LIKE '%<SystemHealth>%'                             ) AS t               WHERE DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)) = DATEPART(HOUR, @LastHour)                      AND CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE) = CAST(@LastHour AS DATE)               GROUP BY                      CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) ,                      CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)               )               SELECT                      ss.EventDate AS EventDate,                      ss.EventTime AS EventTime,                      ss.MaxSQLCPU,                      ss.MinSQLCPU,                      ss.AvgSQLCPU,                      q.MedianSQLCPU,                      q.Q1SQLCPU,                      q.Q3SQLCPU               FROM SimpleStats ss                      INNER JOIN Quartiles q                            ON q.EventDate = ss.EventDate                            AND q.EventTime = ss.EventTime      ",16,16,0,781,0,36478
"       SELECT         db_id() AS [database_id],         COUNT(*) AS [AppendOnlyLedgerTableCount]       FROM         sys.tables       WHERE         ledger_type = 3 AND is_dropped_ledger_table = 0     ",16,11,5,584,0,1502
"       select COUNT_BIG(*) AS [NumReplicaPerAG]       from sys.dm_hadr_availability_replica_states where group_id in       (select group_id from sys.dm_hadr_availability_replica_states WITH(nolock) where is_local = 1 and role = 1) group by group_id     ",16,13,3,69,0,1501
"       SELECT replica_id, group_id, is_local, role, operational_state, recovery_health, synchronization_health, connected_state, last_connect_error_number, last_connect_error_timestamp FROM sys.dm_hadr_availability_replica_states WITH(nolock)     ",16,14,2,82,0,1477
"()                 begin try                 select  object_name                 ,       counter_name                 ,       convert(varchar(10),cntr_value) as cntr_value                 from sys.dm_os_performance_counters                 where ( (object_name like '%Manager%') and (counter_name = 'Memory Grants Pending' or counter_name='Memory Grants Outstanding' ))                 end try                 begin catch                 select top 0 0 as object_name, 0 as counter_name, 0 as cntr_value                 end catch               ",16,16,0,0,0,48
"       select       group_id,       replica_id,       availability_mode,       failover_mode,       primary_role_allow_connections,       secondary_role_allow_connections,       LEN(ISNULL(read_only_routing_url, '')) as read_only_routing_url_length,       seeding_mode,       session_timeout       from sys.availability_replicas WITH(nolock) where group_id in       (select group_id from sys.dm_hadr_availability_replica_states WITH(nolock) where is_local = 1 and role = 1)     ",15,12,3,98,0,78
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",15,12,3,184,0,60
"       SELECT         db_id() AS [database_id],         CASE           WHEN EXISTS (             SELECT *             FROM sys.tables             WHERE ledger_type in (2,3) AND is_dropped_ledger_table = 0)           THEN 1           ELSE 0           END AS [IsLedger]     ",14,9,5,72,0,1343
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",14,14,0,0,0,44
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups               select replica_id, group_id into #tmpardb_availability_replicas from master.sys.availability_replicas              select replica_id, group_database_id, database_name,is_database_joined,is_failover_ready,is_pending_secondary_suspend,recovery_lsn,truncation_lsn into #tmpardb_database_replica_cluster_states from master.sys.dm_hadr_database_replica_cluster_states              select replica_id, is_local into #tmpardb_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id, group_database_id,synchronization_state, is_suspended into #tmpardb_database_replica_states from master.sys.dm_hadr_database_replica_states        SELECT dbcs.database_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityDatabase[@Name=' + quotename(dbcs.database_name,'''') + ']' AS [Urn], ISNULL(dbrs.synchronization_state, 0) AS [SynchronizationState], ISNULL(dbrs.is_suspended, 0) AS [IsSuspended], ISNULL(dbcs.is_database_joined, 0) AS [IsJoined] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpardb_availability_replicas AS AR ON AR.group_id=AG.group_id INNER JOIN #tmpardb_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1 INNER JOIN #tmpardb_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id LEFT OUTER JOIN #tmpardb_database_replica_states AS dbrs ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpardb_availability_replicas              DROP TABLE #tmpardb_database_replica_cluster_states              DROP TABLE #tmpardb_availability_replica_states              DROP TABLE #tmpardb_database_replica_states              drop table #tmpag_availability_groups       ",14,12,2,94,0,14
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",14,12,2,185,0,43
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1)) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",13,11,2,184,0,27
"       SELECT DB_ID() AS database_id,       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       COUNT_BIG(*) AS NumTables,       is_node,       is_edge       FROM sys.tables WITH(nolock)       GROUP BY       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       is_node,       is_edge     ",13,9,4,840,0,1232
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states                select TMIL.group_id, count(*) as is_managed_instance_link into #tmp_managed_instance_link from sys.availability_replicas AS TMIL where TMIL.endpoint_url LIKE '%Server=%' and (select count(*) from sys.availability_replicas as A1 where A1.group_id = TMIL.group_id) = 2 group by TMIL.group_id having count(*) = 1        SELECT AG.name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' AS [Urn], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], CAST(ISNULL(MIL.is_managed_instance_link, 0) & ISNULL(AG.is_distributed, 0) AS bit) AS [IsManagedInstanceLink], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 LEFT OUTER JOIN #tmp_managed_instance_link AS MIL ON AG.group_id = MIL.group_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmp_managed_instance_link      ",13,11,2,98,0,13
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states          SELECT AG.name AS [Name], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states      ",13,11,2,98,1,13
"       SELECT         db_id() AS [database_id],         COUNT(*) AS [UpdatableLedgerTableCount]       FROM         sys.tables       WHERE         ledger_type = 2 AND is_dropped_ledger_table = 0     ",13,9,4,602,0,1191
"       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states                select TMIL.group_id, count(*) as is_managed_instance_link into #tmp_managed_instance_link from sys.availability_replicas AS TMIL where TMIL.endpoint_url LIKE '%Server=%' and (select count(*) from sys.availability_replicas as A1 where A1.group_id = TMIL.group_id) = 2 group by TMIL.group_id having count(*) = 1        SELECT AG.name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' AS [Urn], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], CAST(ISNULL(MIL.is_managed_instance_link, 0) & ISNULL(AG.is_distributed, 0) AS bit) AS [IsManagedInstanceLink], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 LEFT OUTER JOIN #tmp_managed_instance_link AS MIL ON AG.group_id = MIL.group_id ORDER BY [Name] ASC        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmp_managed_instance_link      ",13,11,2,99,1,52
"       SELECT         db_id() AS [database_id],         COUNT(*) AS [AppendOnlyLedgerTableCount]       FROM         sys.tables       WHERE         ledger_type = 3 AND is_dropped_ledger_table = 0     ",13,9,4,602,0,1178
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states          SELECT AG.name AS [Name], AG.group_id AS [UniqueId], ISNULL(AG.automated_backup_preference, 4) AS [AutomatedBackupPreference], ISNULL(AG.failure_condition_level, 6) AS [FailureConditionLevel], ISNULL(AG.health_check_timeout, -1) AS [HealthCheckTimeout], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], AR2.replica_metadata_id AS [ID], CAST(ISNULL(AG.basic_features, 0) AS bit) AS [BasicAvailabilityGroup], CAST(ISNULL(AG.db_failover, 0) AS bit) AS [DatabaseHealthTrigger], CAST(ISNULL(AG.dtc_support, 0) AS bit) AS [DtcSupportEnabled], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], ISNULL(AG.required_synchronized_secondaries_to_commit, 0) AS [RequiredSynchronizedSecondariesToCommit], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states      ",12,10,2,98,0,25
"SELECT P.*, P.ID AS ProjectID, A.ID AS AuditeeUnitID, P.Name AS ProjectName, D.DEPT_NAME AS DepartmentName, PR.Name AS ProcessName, PO.Name AS PortionName  FROM PROJECT P INNER JOIN AUDITEEUNIT A ON P.AuditeeUnitID = A.ID LEFT JOIN DEPARTMENT D ON A.DepartmentID = D.ID LEFT JOIN PROCESS PR ON A.ProcessID = PR.ID LEFT JOIN PORTION PO ON A.PortionID = PO.ID WHERE A.Year = 2019 AND A.TypeID = 1 ORDER BY D.DEPT_NAME, P.ActualStartDate",12,10,2,1085,0,12
"       SELECT         db_id() AS [database_id],         CASE           WHEN EXISTS (             SELECT *             FROM sys.tables             WHERE ledger_type in (2,3) AND is_dropped_ledger_table = 0)           THEN 1           ELSE 0           END AS [IsLedger]     ",12,8,4,158,0,1108
FETCH API_CURSOR00000000000004DF ,12,12,0,11805,0,24
FETCH API_CURSOR00000000000004B3 ,12,12,0,11642,0,72
"       SELECT quorum_type_desc FROM [sys].[dm_hadr_cluster]     ",12,11,1,0,0,1084
"       select       group_id,       automated_backup_preference AS [BackupPreference],       failure_condition_level,       health_check_timeout,       dtc_support,       db_failover,       is_distributed,       required_synchronized_secondaries_to_commit,       cluster_type,       sequence_number, 	  is_contained       from sys.availability_groups where group_id in       (select group_id from sys.dm_hadr_availability_replica_states WITH(nolock) where is_local = 1 and role = 1)     ",12,9,3,71,0,1084
"         declare @HkeyLocal nvarchar(18)         declare @ServicesRegPath nvarchar(34)         declare @SqlServiceRegPath sysname         declare @BrowserServiceRegPath sysname         declare @MSSqlServerRegPath nvarchar(31)         declare @InstanceNamesRegPath nvarchar(59)         declare @InstanceRegPath sysname         declare @SetupRegPath sysname         declare @NpRegPath sysname         declare @TcpRegPath sysname         declare @RegPathParams sysname         declare @FilestreamRegPath sysname          select @HkeyLocal=N'HKEY_LOCAL_MACHINE'          -- Instance-based paths         select @MSSqlServerRegPath=N'SOFTWARE\Microsoft\MSSQLServer'         select @InstanceRegPath=@MSSqlServerRegPath + N'\MSSQLServer'         select @FilestreamRegPath=@InstanceRegPath + N'\Filestream'         select @SetupRegPath=@MSSqlServerRegPath + N'\Setup'         select @RegPathParams=@InstanceRegPath+'\Parameters'          -- Services         select @ServicesRegPath=N'SYSTEM\CurrentControlSet\Services'         select @SqlServiceRegPath=@ServicesRegPath + N'\MSSQLSERVER'         select @BrowserServiceRegPath=@ServicesRegPath + N'\SQLBrowser'          -- InstanceId setting         select @InstanceNamesRegPath=N'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'          -- Network settings         select @NpRegPath=@InstanceRegPath + N'\SuperSocketNetLib\Np'         select @TcpRegPath=@InstanceRegPath + N'\SuperSocketNetLib\Tcp'                  declare @SmoAuditLevel int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'AuditLevel', @SmoAuditLevel OUTPUT                  declare @NumErrorLogs int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'NumErrorLogs', @NumErrorLogs OUTPUT                  declare @SmoLoginMode int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'LoginMode', @SmoLoginMode OUTPUT                  declare @SmoMailProfile nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'MailAccountName', @SmoMailProfile OUTPUT                  declare @BackupDirectory nvarchar(512)         if 1=isnull(cast(SERVERPROPERTY('IsLocalDB') as bit), 0)         select @BackupDirectory=cast(SERVERPROPERTY('instancedefaultdatapath') as nvarchar(512))         else         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'BackupDirectory', @BackupDirectory OUTPUT                  declare @SmoPerfMonMode int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'Performance', @SmoPerfMonMode OUTPUT          if @SmoPerfMonMode is null         begin         set @SmoPerfMonMode = 1000         end                  declare @InstallSqlDataDir nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLDataRoot', @InstallSqlDataDir OUTPUT                  declare @MasterPath nvarchar(512)         declare @LogPath nvarchar(512)         declare @ErrorLog nvarchar(512)         declare @ErrorLogPath nvarchar(512)         declare @Slash varchar = convert(varchar, serverproperty('PathSeparator'))         select @MasterPath=substring(physical_name, 1, len(physical_name) - charindex(@Slash, reverse(physical_name))) from master.sys.database_files where file_id = 1         select @LogPath=substring(physical_name, 1, len(physical_name) - charindex(@Slash, reverse(physical_name))) from master.sys.database_files where file_id = 2         select @ErrorLog=cast(SERVERPROPERTY(N'errorlogfilename') as nvarchar(512))         select @ErrorLogPath=IIF(@ErrorLog IS NULL, N'', substring(@ErrorLog, 1, len(@ErrorLog) - charindex(@Slash, reverse(@ErrorLog))))                  declare @SmoRoot nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLPath', @SmoRoot OUTPUT                  declare @ServiceStartMode int         EXEC master.sys.xp_instance_regread @HkeyLocal, @SqlServiceRegPath, N'Start', @ServiceStartMode OUTPUT                  declare @ServiceAccount nvarchar(512)         EXEC master.sys.xp_instance_regread @HkeyLocal, @SqlServiceRegPath, N'ObjectName', @ServiceAccount OUTPUT                  declare @NamedPipesEnabled int         exec master.dbo.xp_instance_regread @HkeyLocal, @NpRegPath, N'Enabled', @NamedPipesEnabled OUTPUT                  declare @TcpEnabled int         EXEC master.sys.xp_instance_regread @HkeyLocal, @TcpRegPath, N'Enabled', @TcpEnabled OUTPUT                  declare @InstallSharedDirectory nvarchar(512)         EXEC master.sys.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLPath', @InstallSharedDirectory OUTPUT                  declare @SqlGroup nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLGroup', @SqlGroup OUTPUT                  declare @FilestreamLevel int         exec master.dbo.xp_instance_regread @HkeyLocal, @FilestreamRegPath, N'EnableLevel', @FilestreamLevel OUTPUT                  declare @FilestreamShareName nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @FilestreamRegPath, N'ShareName', @FilestreamShareName OUTPUT                  declare @cluster_name nvarchar(128)         declare @quorum_type tinyint         declare @quorum_state tinyint         BEGIN TRY         SELECT @cluster_name = cluster_name,         @quorum_type = quorum_type,         @quorum_state = quorum_state         FROM sys.dm_hadr_cluster         END TRY         BEGIN CATCH           IF(ERROR_NUMBER() NOT IN (297,300, 15562, 371))         BEGIN         THROW         END         END CATCH         SELECT @SmoAuditLevel AS [AuditLevel], ISNULL(@NumErrorLogs, -1) AS [NumberOfLogFiles], (case when @SmoLoginMode < 3 then @SmoLoginMode else 9 end) AS [LoginMode], ISNULL(@SmoMailProfile,N'') AS [MailProfile], @BackupDirectory AS [BackupDirectory], @SmoPerfMonMode AS [PerfMonMode], ISNULL(@InstallSqlDataDir,N'') AS [InstallDataDirectory], CAST(@@SERVICENAME AS sysname) AS [ServiceName], @ErrorLogPath AS [ErrorLogPath], @SmoRoot AS [RootDirectory], CAST(case when 'a' <> 'A' then 1 else 0 end AS bit) AS [IsCaseSensitive], @@MAX_PRECISION AS [MaxPrecision], CAST(FULLTEXTSERVICEPROPERTY('IsFullTextInstalled') AS bit) AS [IsFullTextInstalled], SERVERPROPERTY(N'ProductVersion') AS [VersionString], CAST(SERVERPROPERTY(N'Edition') AS sysname) AS [Edition], CAST(SERVERPROPERTY(N'ProductLevel') AS sysname) AS [ProductLevel], CAST(ISNULL(SERVERPROPERTY(N'ProductUpdateLevel'), N'') AS sysname) AS [ProductUpdateLevel], CAST(SERVERPROPERTY('IsSingleUser') AS bit) AS [IsSingleUser], CAST(SERVERPROPERTY('EngineEdition') AS int) AS [EngineEdition], convert(sysname, serverproperty(N'collation')) AS [Collation], CAST(ISNULL(SERVERPROPERTY('IsClustered'), 0) AS bit) AS [IsClustered], CAST(ISNULL(SERVERPROPERTY(N'MachineName'), N'') AS sysname) AS [NetName], ISNULL(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS'),N'') AS [ComputerNamePhysicalNetBIOS], ISNULL(@ServiceStartMode,2) AS [ServiceStartMode], @LogPath AS [MasterDBLogPath], @MasterPath AS [MasterDBPath], SERVERPROPERTY('instancedefaultdatapath') AS [DefaultFile], SERVERPROPERTY('instancedefaultlogpath') AS [DefaultLog], SERVERPROPERTY(N'ResourceVersion') AS [ResourceVersionString], SERVERPROPERTY(N'ResourceLastUpdateDateTime') AS [ResourceLastUpdateDateTime], SERVERPROPERTY(N'CollationID') AS [CollationID], SERVERPROPERTY(N'ComparisonStyle') AS [ComparisonStyle], SERVERPROPERTY(N'SqlCharSet') AS [SqlCharSet], SERVERPROPERTY(N'SqlCharSetName') AS [SqlCharSetName], SERVERPROPERTY(N'SqlSortOrder') AS [SqlSortOrder], SERVERPROPERTY(N'SqlSortOrderName') AS [SqlSortOrderName], SERVERPROPERTY(N'BuildClrVersion') AS [BuildClrVersionString], ISNULL(@ServiceAccount,N'') AS [ServiceAccount], CAST(@NamedPipesEnabled AS bit) AS [NamedPipesEnabled], CAST(@TcpEnabled AS bit) AS [TcpEnabled], ISNULL(@InstallSharedDirectory,N'') AS [InstallSharedDirectory], ISNULL(suser_sname(sid_binary(ISNULL(@SqlGroup,N''))),N'') AS [SqlDomainGroup], case when 1=msdb.dbo.fn_syspolicy_is_automation_enabled() and exists (select * from msdb.dbo.syspolicy_system_health_state  where target_query_expression_with_id like 'Server%' ) then 1 else 0 end AS [PolicyHealthState], @FilestreamLevel AS [FilestreamLevel], ISNULL(@FilestreamShareName,N'') AS [FilestreamShareName], -1 AS [TapeLoadWaitTime], CAST(SERVERPROPERTY(N'IsHadrEnabled') AS bit) AS [IsHadrEnabled], SERVERPROPERTY(N'HADRManagerStatus') AS [HadrManagerStatus], ISNULL(@cluster_name, '') AS [ClusterName], ISNULL(@quorum_type, 4) AS [ClusterQuorumType], ISNULL(@quorum_state, 3) AS [ClusterQuorumState], SUSER_SID(@ServiceAccount, 0) AS [ServiceAccountSid], CAST(SERVERPROPERTY('IsPolyBaseInstalled') AS bit) AS [IsPolyBaseInstalled], CAST(         serverproperty(N'Servername')        AS sysname) AS [Name], CAST(         ISNULL(serverproperty(N'instancename'),N'')        AS sysname) AS [InstanceName], CAST(0x0001 AS int) AS [Status], SERVERPROPERTY('PathSeparator') AS [PathSeparator], 0 AS [IsContainedAuthentication], CAST(null AS int) AS [ServerType]",11,10,1,0,0,93
"CREATE   PROCEDURE sp_sqlagent_has_server_access   @login_name         sysname = NULL,   @job_id             uniqueidentifier = NULL, -- if this is not null, @login_name will be ignored!   @is_sysadmin_member INT     = NULL OUTPUT AS BEGIN   DECLARE @has_server_access BIT   DECLARE @is_sysadmin       BIT   DECLARE @actual_login_name sysname   -- Set only when login_name is actually found. It will be zero when @actual_login_name is (unknown).   DECLARE @login_found BIT   DECLARE @cachedate         DATETIME    SET NOCOUNT ON    SELECT @cachedate = NULL    -- remove expired entries from the cache   DELETE msdb.dbo.syscachedcredentials   WHERE  DATEDIFF(MINUTE, cachedate, GETDATE()) >= 29    -- query the cache   SELECT  @is_sysadmin = is_sysadmin_member,           @has_server_access = has_server_access,           @cachedate = cachedate   FROM    msdb.dbo.syscachedcredentials   WHERE   login_name = @login_name   AND     DATEDIFF(MINUTE, cachedate, GETDATE()) < 29    IF (@cachedate IS NOT NULL)   BEGIN     -- no output variable     IF (@is_sysadmin_member IS NULL)     BEGIN       -- Return result row       SELECT has_server_access = @has_server_access,              is_sysadmin       = @is_sysadmin,              actual_login_name = @login_name       RETURN     END     ELSE     BEGIN       SELECT @is_sysadmin_member = @is_sysadmin       RETURN     END   END -- select from cache    -- Set defaults   SELECT @has_server_access = 0   SELECT @is_sysadmin = 0   SELECT @actual_login_name = FORMATMESSAGE(14205)   SELECT @login_found = 0      -- If @job_id was set, get the current name associated with the job owner sid.   if (@job_id IS NOT NULL)   BEGIN 	SELECT @login_name = dbo.SQLAGENT_SUSER_SNAME(owner_sid) 	FROM msdb.dbo.sysjobs_view 	WHERE @job_id = job_id      -- If the job_id is invalid, return error     IF (@login_name IS NULL)     BEGIN       RETURN 1;     END    END   IF (@login_name IS NULL)   BEGIN     SELECT has_server_access = 1,            is_sysadmin       = IS_SRVROLEMEMBER(N'sysadmin'),            actual_login_name = SUSER_SNAME()     RETURN   END    IF (@login_name LIKE '%\%')   BEGIN     -- Handle the LocalSystem account ('NT AUTHORITY\SYSTEM') as a special case     IF (UPPER(@login_name collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')     BEGIN       IF (EXISTS (SELECT *                   FROM master.dbo.syslogins                   WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')))       BEGIN         SELECT @has_server_access = hasaccess,                @is_sysadmin = sysadmin,                @actual_login_name = loginname         FROM master.dbo.syslogins         WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')          SET @login_found = 1       END       ELSE       IF (EXISTS (SELECT *                   FROM master.dbo.syslogins                   WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')))       BEGIN         SELECT @has_server_access = hasaccess,                @is_sysadmin = sysadmin,                @actual_login_name = loginname         FROM master.dbo.syslogins         WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')          SET @login_found = 1       END     END     ELSE     BEGIN       -- Check if the NT login has been explicitly denied access       IF (EXISTS (SELECT *                   FROM master.dbo.syslogins                   WHERE (loginname = @login_name)                     AND (denylogin = 1)))       BEGIN         SELECT @has_server_access = 0,                @is_sysadmin = sysadmin,                @actual_login_name = loginname         FROM master.dbo.syslogins         WHERE (loginname = @login_name)          SET @login_found = 1       END       ELSE       BEGIN         -- declare table variable for storing results         DECLARE @xp_results TABLE         (         account_name      sysname      COLLATE database_default NOT NULL PRIMARY KEY,         type              NVARCHAR(10) COLLATE database_default NOT NULL,         privilege         NVARCHAR(10) COLLATE database_default NOT NULL,         mapped_login_name sysname      COLLATE database_default NOT NULL,         permission_path   sysname      COLLATE database_default NULL         )          -- Call xp_logininfo to determine server access         INSERT INTO @xp_results         EXECUTE master.dbo.xp_logininfo @login_name          IF (SELECT COUNT(*) FROM @xp_results) > 0         BEGIN           SET @has_server_access = 1           SET @login_found = 1         END          SELECT @actual_login_name = mapped_login_name,                @is_sysadmin = CASE UPPER(privilege collate SQL_Latin1_General_CP1_CS_AS)                                 WHEN 'ADMIN' THEN 1                                 ELSE 0                              END         FROM @xp_results       END     END     -- Only cache the NT logins to approximate the behavior of Sql Server and Windows (see bug 323287)     -- update the cache only if something is found     IF  (UPPER(@actual_login_name collate SQL_Latin1_General_CP1_CS_AS) <> '(UNKNOWN)')     BEGIN       -- Procedure starts its own transaction.       BEGIN TRANSACTION;        -- Modify database.       -- use a try catch login to prevent any error when trying       -- to insert/update syscachedcredentials table       -- no need to fail since the job owner has been validated       BEGIN TRY         IF EXISTS (SELECT * FROM msdb.dbo.syscachedcredentials WITH (TABLOCKX) WHERE login_name = @login_name)         BEGIN           UPDATE msdb.dbo.syscachedcredentials           SET    has_server_access = @has_server_access,                 is_sysadmin_member = @is_sysadmin,                 cachedate = GETDATE()           WHERE  login_name = @login_name         END         ELSE         BEGIN           INSERT INTO msdb.dbo.syscachedcredentials(login_name, has_server_access, is_sysadmin_member)           VALUES(@login_name, @has_server_access, @is_sysadmin)         END         END TRY         BEGIN CATCH             -- If an error occurred we want to ignore it         END CATCH          -- The procedure must commit the transaction it started.         COMMIT TRANSACTION;     END    END   ELSE   BEGIN     -- Standard login     IF (EXISTS (SELECT *                 FROM master.dbo.syslogins                 WHERE (loginname = @login_name)))     BEGIN       SELECT @has_server_access = hasaccess,              @is_sysadmin = sysadmin,              @actual_login_name = loginname       FROM master.dbo.syslogins       WHERE (loginname = @login_name)        SET @login_found = 1     END   END    IF (@is_sysadmin_member IS NULL)     -- Return result row     SELECT has_server_access = @has_server_access,            is_sysadmin       = @is_sysadmin,            actual_login_name = @actual_login_name,            login_found       = @login_found   ELSE     -- output variable only     SELECT @is_sysadmin_member = @is_sysadmin END ",11,10,1,140,0,26981
FETCH API_CURSOR0000000000000392 ,11,11,0,10641,0,346
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas          SELECT AR.replica_server_name AS [Name] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              drop table #tmpag_availability_groups       ",11,9,2,174,1,22
FETCH API_CURSOR00000000000003A2 ,11,11,0,10580,0,157
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups        SELECT AG.name AS [Name] FROM #tmpag_availability_groups AS AG WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups      ",11,9,2,174,1,33
" CREATE   PROCEDURE [dbo].[sp_syscollector_event_oncollectionbegin]     @collection_set_id int,     @mode smallint = NULL,     @operator nvarchar(128) = NULL,     @log_id bigint OUTPUT AS BEGIN     SET NOCOUNT ON      -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))     BEGIN         RAISERROR(14677, -1, -1, 'dc_proxy')         RETURN(1) -- Failure     END      -- Verify parameters     --      -- Check the collection_set_id     IF (@collection_set_id IS NULL)     BEGIN         RAISERROR(14606, -1, -1, '@collection_set_id')         RETURN (1)     END     ELSE IF (NOT EXISTS (SELECT collection_set_id FROM dbo.syscollector_collection_sets WHERE collection_set_id = @collection_set_id))     BEGIN         DECLARE @collection_set_id_as_char VARCHAR(36)         SELECT @collection_set_id_as_char = CONVERT(VARCHAR(36), @collection_set_id)          RAISERROR(14262, -1, -1, '@collection_set_id', @collection_set_id_as_char)         RETURN (1)     END       -- Default operator to currently logged in user     SET @operator = NULLIF(LTRIM(RTRIM(@operator)), '')     SET @operator = ISNULL(@operator, suser_sname())      -- Default mode to Collection     SET @mode = ISNULL(@mode, 0)      -- Find the parent log id.     -- It will be a log entry for the same collection set, with no parent and not finished     DECLARE @parent_log_id bigint     SELECT TOP 1 @parent_log_id = log_id FROM dbo.syscollector_execution_log_internal          WHERE collection_set_id = @collection_set_id          AND parent_log_id IS NULL         AND (@mode = 1 OR finish_time IS NULL)         ORDER BY start_time DESC      -- Insert the log record     --     INSERT INTO dbo.syscollector_execution_log_internal (         parent_log_id,          collection_set_id,          collection_item_id,         start_time,         last_iteration_time,         finish_time,         runtime_execution_mode,         [status],         operator,         package_id,         package_execution_id,         failure_message     ) VALUES (         @parent_log_id,         @collection_set_id,         NULL,         GETDATE(),         NULL,         NULL,         @mode,         0, -- Running         @operator,         NULL,         NULL,         NULL     )      SET @log_id = SCOPE_IDENTITY()                          RETURN (0) END ",10,10,0,5896,0,685
"       SELECT       ISNULL(sum(memory_allocated_for_table_kb+memory_allocated_for_indexes_kb) ,0) AS total_memory_allocated_for_user_data_kb, db_id() AS database_id       FROM sys.dm_db_xtp_table_memory_stats WITH(nolock)     ",10,5,5,21,0,960
FETCH API_CURSOR0000000000000337 ,10,10,0,9438,0,146
"       SELECT       ISNULL(sum(memory_allocated_for_table_kb+memory_allocated_for_indexes_kb) ,0) AS total_memory_allocated_for_user_data_kb, db_id() AS database_id       FROM sys.dm_db_xtp_table_memory_stats WITH(nolock)     ",10,5,5,20,0,934
