CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_text]
    @duration smallint = NULL,
    @end_time datetime = NULL,
    @delete_batch_size int = 500
AS
BEGIN
    PRINT 'Begin purging orphaned records in snapshots.notable_query_text Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())

    DECLARE @stop_purge int

    -- Delete orphaned rows from snapshots.notable_query_text.  Query texts are not deleted by the generic purge 
    -- process that deletes other data (above) because query text rows are not tied to a particular snapshot ID. 
    -- Purging  query text table as a special case, by looking for plans that 
    -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these 
    -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and 
    -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).  
    DECLARE @rows_affected int;
    -- set expected rows affected as delete batch size
    SET @rows_affected = @delete_batch_size;

    SELECT qt.[sql_handle]
    INTO #tmp_notable_query_text
    FROM snapshots.notable_query_text AS qt
    WHERE NOT EXISTS (
        SELECT snapshot_id 
        FROM snapshots.query_stats AS qs
        WHERE qs.[sql_handle] = qt.[sql_handle])

    WHILE (@rows_affected = @delete_batch_size)
    BEGIN
        -- Deleting TOP N orphaned rows in query text table by joining info from temp table
        -- This is done to speed up delete query. 
        DELETE TOP (@delete_batch_size) snapshots.notable_query_text 
         FROM snapshots.notable_query_text AS qt, #tmp_notable_query_text AS tmp
        WHERE tmp.[sql_handle] = qt.[sql_handle]
        
        SET @rows_affected = @@ROWCOUNT;
        IF(@rows_affected > 0)
        BEGIN
            RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_text', 0, 1, @rows_affected) WITH NOWAIT;
        END

        -- Check if the execution of the stored proc exceeded the @duration specified
        IF (@duration IS NOT NULL)
        BEGIN
            IF (GETUTCDATE()>=@end_time)
            BEGIN
                PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';
                BREAK
            END
        END

        -- Check if somebody wanted to stop the purge operation
        SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]
        IF (@stop_purge > 0)
        BEGIN
            PRINT 'Stopping purge. Detected a user request to stop purge.';
            BREAK
        END
    END;

    PRINT 'End purging orphaned records in snapshots.notable_query_text Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())

END

,247702,247692,10,66578707,0,247702
CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_plan]
    @duration smallint = NULL,
    @end_time datetime = NULL,
    @delete_batch_size int = 500
AS
BEGIN
    PRINT 'Begin purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())

    DECLARE @stop_purge int

    -- Delete orphaned rows from snapshots.notable_query_plan.  Query plans are not deleted by the generic purge 
    -- process that deletes other data (above) because query plan rows are not tied to a particular snapshot ID. 
    -- Purging query plans table  as a special case, by looking for plans that 
    -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these 
    -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and 
    -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).  
    DECLARE @rows_affected int;
    -- set expected rows affected as delete batch size
    SET @rows_affected = @delete_batch_size;
    
    -- select set of orphaned query plans to be deleted into a temp table 
    SELECT qp.[sql_handle],
        qp.plan_handle,
        qp.plan_generation_num,
        qp.statement_start_offset,
        qp.statement_end_offset,
        qp.creation_time
    INTO #tmp_notable_query_plan
    FROM snapshots.notable_query_plan AS qp 
    WHERE NOT EXISTS (
        SELECT snapshot_id 
        FROM snapshots.query_stats AS qs
        WHERE qs.[sql_handle] = qp.[sql_handle] AND qs.plan_handle = qp.plan_handle 
            AND qs.plan_generation_num = qp.plan_generation_num 
            AND qs.statement_start_offset = qp.statement_start_offset 
            AND qs.statement_end_offset = qp.statement_end_offset 
            AND qs.creation_time = qp.creation_time)

    WHILE (@rows_affected = @delete_batch_size)
    BEGIN
        -- Deleting TOP N orphaned rows in query plan table by joining info from temp table variable
        -- This is done to speed up delete query. 
        DELETE TOP (@delete_batch_size) snapshots.notable_query_plan 
        FROM snapshots.notable_query_plan AS qp , #tmp_notable_query_plan AS tmp
        WHERE tmp.[sql_handle] = qp.[sql_handle] 
            AND tmp.plan_handle = qp.plan_handle 
            AND tmp.plan_generation_num = qp.plan_generation_num 
            AND tmp.statement_start_offset = qp.statement_start_offset 
            AND tmp.statement_end_offset = qp.statement_end_offset 
            AND tmp.creation_time = qp.creation_time
        
        SET @rows_affected = @@ROWCOUNT;
        IF(@rows_affected > 0)
        BEGIN
            RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_plan', 0, 1, @rows_affected) WITH NOWAIT;
        END

        -- Check if the execution of the stored proc exceeded the @duration specified
        IF (@duration IS NOT NULL)
        BEGIN
            IF (GETUTCDATE()>=@end_time)
            BEGIN
                PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';
                BREAK
            END
        END

        -- Check if somebody wanted to stop the purge operation
        SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]
        IF (@stop_purge > 0)
        BEGIN
            PRINT 'Stopping purge. Detected a user request to stop purge.';
            BREAK
        END
    END;
    
    PRINT 'End purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())
END

,2432,2416,16,146003,4,2432
CREATE PROCEDURE [dbo].[sp_syscollector_purge_collection_logs]
    @reference_date datetime = NULL
AS
BEGIN
    SET NOCOUNT ON

    -- Security check (role membership)
    IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))
    BEGIN
        RAISERROR(14677, -1, -1, 'dc_proxy')
        RETURN(1) -- Failure
    END

    IF (@reference_date IS NULL)
    BEGIN
        SET @reference_date = GETDATE()
    END
    
    -- An expired log record is any record of a collection set that is older than 
    -- the reference date minus the collection set's days_until_expiration
    CREATE TABLE #purged_log_ids (log_id BIGINT)
    
    INSERT INTO #purged_log_ids
    SELECT log_id
    FROM syscollector_execution_log_internal as l
    INNER JOIN syscollector_collection_sets s ON l.collection_set_id = s.collection_set_id
    WHERE s.days_until_expiration > 0
    AND @reference_date >= DATEADD(DAY, s.days_until_expiration, l.finish_time)

    -- Delete all ssis log records pertaining to expired logs
    DELETE FROM dbo.sysssislog
        FROM dbo.sysssislog AS s
        INNER JOIN dbo.syscollector_execution_log_internal AS l ON (l.package_execution_id = s.executionid)
        INNER JOIN #purged_log_ids AS i ON i.log_id = l.log_id
        
    -- Then delete the actual logs
    DELETE FROM syscollector_execution_log_internal
        FROM syscollector_execution_log_internal AS l
        INNER Join #purged_log_ids AS i ON i.log_id = l.log_id

    DROP TABLE #purged_log_ids
    -- Go for another round to cleanup the orphans
    -- Ideally, the log heirarchy guarantees that a finish time by a parent log will always
    -- be higher than the finish time of any of its descendants.
    -- The purge step however does not delete log records with a null finish time
    -- A child log can have a null finish time while its parent is closed if there is an
    -- error in execution that causes the log to stay open.
    -- If such a child log exists, its parent will be purged leaving it as an orphan
    
    -- get orphan records and all their descendants in a cursor and purge them
    DECLARE orphaned_log_cursor INSENSITIVE CURSOR FOR
            SELECT log_id 
            FROM syscollector_execution_log_internal
            WHERE parent_log_id NOT IN (
                SELECT log_id FROM syscollector_execution_log_internal
            )
            FOR READ ONLY
            
    DECLARE @log_id BIGINT

    -- for every orphan, delete all its remaining tree
    -- this is supposedly a very small fraction of the entire log
    OPEN orphaned_log_cursor    
    FETCH orphaned_log_cursor INTO @log_id
    WHILE @@FETCH_STATUS = 0
    BEGIN
        EXEC sp_syscollector_delete_execution_log_tree @log_id = @log_id, @from_collection_set = 0
        FETCH orphaned_log_cursor INTO @log_id
    END
    
    CLOSE orphaned_log_cursor
    DEALLOCATE orphaned_log_cursor
END
,728,295,433,52084,19,288371
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT
SCHEMA_NAME(sp.schema_id) AS [Schema],
sp.name AS [Name],
sp.object_id AS [ID],
CAST(
 case 
    when sp.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = sp.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType],
CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted]
FROM
sys.all_objects AS sp
LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id
WHERE
(sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2)
ORDER BY
[Schema] ASC,[Name] ASC,549,118,431,81329,0,549
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT
SCHEMA_NAME(sp.schema_id) AS [Schema],
sp.name AS [Name],
sp.object_id AS [ID],
CAST(
 case 
    when sp.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = sp.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType],
CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted]
FROM
sys.all_objects AS sp
LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id
WHERE
(sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2)
ORDER BY
[Schema] ASC,[Name] ASC,414,103,311,80314,0,414
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT
SCHEMA_NAME(sp.schema_id) AS [Schema],
sp.name AS [Name],
sp.object_id AS [ID],
CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType],
CAST(
 case 
    when sp.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = sp.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted]
FROM
sys.all_objects AS sp
LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id
WHERE
(sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2)
ORDER BY
[Schema] ASC,[Name] ASC,408,119,289,79996,0,2042
SELECT
    DB_NAME (database_id) as [Database Name],
    name as [Database File Name],
    [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'
            WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'
            ELSE Type_Desc END,
    size*8/1024 as 'Size (MB)',
    physical_name as [Database_File_Location]
FROM sys.master_files
ORDER BY 1,3

IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL
    DROP TABLE #space

CREATE TABLE #space (
      database_id INT PRIMARY KEY
    , data_used_size DECIMAL(18,2)
    , log_used_size DECIMAL(18,2)
)

DECLARE @SQL NVARCHAR(MAX)

SELECT @SQL = STUFF((
    SELECT '
    USE [' + d.name + ']
    INSERT INTO #space (database_id, data_used_size, log_used_size)
    SELECT
          DB_ID()
        , SUM(CASE WHEN [type] = 0 THEN space_used END)
        , SUM(CASE WHEN [type] = 1 THEN space_used END)
    FROM (
        SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)
        FROM sys.database_files s
        GROUP BY s.[type]
    ) t;'
    FROM sys.databases d
    WHERE d.[state] = 0
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')

EXEC sys.sp_executesql @SQL

SELECT
      d.database_id
    , d.name
    , d.state_desc
    , d.recovery_model_desc
    , t.total_size
    , t.data_size
    , s.data_used_size
    , t.log_size
    , s.log_used_size
    , bu.full_last_date
    , bu.full_size
    , bu.log_last_date
    , bu.log_size
FROM (
    SELECT
          database_id
        , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))
    FROM sys.master_files
    GROUP BY database_id
) t
JOIN sys.databases d ON d.database_id = t.database_id
LEFT JOIN #space s ON d.database_id = s.database_id
LEFT JOIN (
    SELECT
          database_name
        , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)
        , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)
        , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)
        , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)
    FROM (
        SELECT
              s.database_name
            , s.[type]
            , s.backup_finish_date
            , backup_size =
                        CAST(CASE WHEN s.backup_size = s.compressed_backup_size
                                    THEN s.backup_size
                                    ELSE s.compressed_backup_size
                        END / 1048576.0 AS DECIMAL(18,2))
            , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)
        FROM msdb.dbo.backupset s
        WHERE s.[type] IN ('D', 'L')
    ) f
    WHERE f.RowNum = 1
    GROUP BY f.database_name
) bu ON d.name = bu.database_name
ORDER BY t.total_size DESC

SELECT 
    req.session_id
    , req.total_elapsed_time AS duration_ms
    , req.cpu_time AS cpu_time_ms
    , req.total_elapsed_time - req.cpu_time AS wait_time
    , req.logical_reads
    , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1, 
       ((CASE statement_end_offset
           WHEN -1
           THEN DATALENGTH(ST.text)  
           ELSE req.statement_end_offset
         END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '), 
      1, 512)  AS statement_text  
FROM sys.dm_exec_requests AS req
    CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST
ORDER BY total_elapsed_time DESC;

SELECT top 100 t.text,
     (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,
     (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,
     ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,
     qs.total_logical_reads / qs.execution_count AS avg_logical_reads,
     qs.total_logical_writes / qs.execution_count AS avg_writes,
     (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions
FROM sys.dm_exec_query_stats qs
     CROSS apply sys.Dm_exec_sql_text (sql_handle) t
-- WHERE t.text like '<Your Query>%'
-- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped.
ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC

--Deadlock sql check
SELECT
    session_id,
    start_time, 
    [status],
    command,
    blocking_session_id,
    wait_type,
    wait_time,
    open_transaction_count,
    transaction_id,
    total_elapsed_time,
    Definition = CAST(text AS VARCHAR(MAX))
FROM
    SYS.DM_EXEC_REQUESTS
    CROSS APPLY sys.dm_exec_sql_text(sql_handle) 
WHERE blocking_session_id != 0


,254,254,0,87,0,1274

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=27 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,445,447,546,543,544,545,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,507,508,509,510,511,512,547,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=27 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=27 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,233,232,1,16914,0,1866
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT
SCHEMA_NAME(sp.schema_id) AS [Schema],
sp.name AS [Name],
sp.object_id AS [ID],
CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType],
CAST(
 case 
    when sp.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = sp.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted]
FROM
sys.all_objects AS sp
LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id
WHERE
(sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2)
ORDER BY
[Schema] ASC,[Name] ASC,233,114,119,86022,0,1165

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=28 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,445,447,546,543,544,545,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,507,508,509,510,511,512,547,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=28 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=28 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,213,213,0,16900,0,1711

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,543,544,545,561,562,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,507,508,509,510,511,512,547,563,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,212,197,15,15876,0,212
SELECT
    DB_NAME (database_id) as [Database Name],
    name as [Database File Name],
    [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'
            WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'
            ELSE Type_Desc END,
    size*8/1024 as 'Size (MB)',
    physical_name as [Database_File_Location]
FROM sys.master_files
ORDER BY 1,3

IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL
    DROP TABLE #space

CREATE TABLE #space (
      database_id INT PRIMARY KEY
    , data_used_size DECIMAL(18,2)
    , log_used_size DECIMAL(18,2)
)

DECLARE @SQL NVARCHAR(MAX)

SELECT @SQL = STUFF((
    SELECT '
    USE [' + d.name + ']
    INSERT INTO #space (database_id, data_used_size, log_used_size)
    SELECT
          DB_ID()
        , SUM(CASE WHEN [type] = 0 THEN space_used END)
        , SUM(CASE WHEN [type] = 1 THEN space_used END)
    FROM (
        SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)
        FROM sys.database_files s
        GROUP BY s.[type]
    ) t;'
    FROM sys.databases d
    WHERE d.[state] = 0
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')

EXEC sys.sp_executesql @SQL

SELECT
      d.database_id
    , d.name
    , d.state_desc
    , d.recovery_model_desc
    , t.total_size
    , t.data_size
    , s.data_used_size
    , t.log_size
    , s.log_used_size
    , bu.full_last_date
    , bu.full_size
    , bu.log_last_date
    , bu.log_size
FROM (
    SELECT
          database_id
        , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))
    FROM sys.master_files
    GROUP BY database_id
) t
JOIN sys.databases d ON d.database_id = t.database_id
LEFT JOIN #space s ON d.database_id = s.database_id
LEFT JOIN (
    SELECT
          database_name
        , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)
        , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)
        , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)
        , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)
    FROM (
        SELECT
              s.database_name
            , s.[type]
            , s.backup_finish_date
            , backup_size =
                        CAST(CASE WHEN s.backup_size = s.compressed_backup_size
                                    THEN s.backup_size
                                    ELSE s.compressed_backup_size
                        END / 1048576.0 AS DECIMAL(18,2))
            , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)
        FROM msdb.dbo.backupset s
        WHERE s.[type] IN ('D', 'L')
    ) f
    WHERE f.RowNum = 1
    GROUP BY f.database_name
) bu ON d.name = bu.database_name
ORDER BY t.total_size DESC

SELECT 
    req.session_id
    , req.total_elapsed_time AS duration_ms
    , req.cpu_time AS cpu_time_ms
    , req.total_elapsed_time - req.cpu_time AS wait_time
    , req.logical_reads
    , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1, 
       ((CASE statement_end_offset
           WHEN -1
           THEN DATALENGTH(ST.text)  
           ELSE req.statement_end_offset
         END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '), 
      1, 512)  AS statement_text  
FROM sys.dm_exec_requests AS req
    CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST
ORDER BY total_elapsed_time DESC;

SELECT top 100 t.text,
     (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,
     (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,
     ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,
     qs.total_logical_reads / qs.execution_count AS avg_logical_reads,
     qs.total_logical_writes / qs.execution_count AS avg_writes,
     (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions
FROM sys.dm_exec_query_stats qs
     CROSS apply sys.Dm_exec_sql_text (sql_handle) t
-- WHERE t.text like '<Your Query>%'
-- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped.
ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC

--Deadlock sql check
SELECT
    session_id,
    start_time, 
    [status],
    command,
    blocking_session_id,
    wait_type,
    wait_time,
    open_transaction_count,
    transaction_id,
    total_elapsed_time,
    Definition = CAST(text AS VARCHAR(MAX))
FROM
    SYS.DM_EXEC_REQUESTS
    CROSS APPLY sys.dm_exec_sql_text(sql_handle) 
WHERE blocking_session_id != 0

,204,204,0,104,0,204
CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_plan]
    @duration smallint = NULL,
    @end_time datetime = NULL,
    @delete_batch_size int = 500
AS
BEGIN
    PRINT 'Begin purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())

    DECLARE @stop_purge int

    -- Delete orphaned rows from snapshots.notable_query_plan.  Query plans are not deleted by the generic purge 
    -- process that deletes other data (above) because query plan rows are not tied to a particular snapshot ID. 
    -- Purging query plans table  as a special case, by looking for plans that 
    -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these 
    -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and 
    -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).  
    DECLARE @rows_affected int;
    -- set expected rows affected as delete batch size
    SET @rows_affected = @delete_batch_size;
    
    -- select set of orphaned query plans to be deleted into a temp table 
    SELECT qp.[sql_handle],
        qp.plan_handle,
        qp.plan_generation_num,
        qp.statement_start_offset,
        qp.statement_end_offset,
        qp.creation_time
    INTO #tmp_notable_query_plan
    FROM snapshots.notable_query_plan AS qp 
    WHERE NOT EXISTS (
        SELECT snapshot_id 
        FROM snapshots.query_stats AS qs
        WHERE qs.[sql_handle] = qp.[sql_handle] AND qs.plan_handle = qp.plan_handle 
            AND qs.plan_generation_num = qp.plan_generation_num 
            AND qs.statement_start_offset = qp.statement_start_offset 
            AND qs.statement_end_offset = qp.statement_end_offset 
            AND qs.creation_time = qp.creation_time)

    WHILE (@rows_affected = @delete_batch_size)
    BEGIN
        -- Deleting TOP N orphaned rows in query plan table by joining info from temp table variable
        -- This is done to speed up delete query. 
        DELETE TOP (@delete_batch_size) snapshots.notable_query_plan 
        FROM snapshots.notable_query_plan AS qp , #tmp_notable_query_plan AS tmp
        WHERE tmp.[sql_handle] = qp.[sql_handle] 
            AND tmp.plan_handle = qp.plan_handle 
            AND tmp.plan_generation_num = qp.plan_generation_num 
            AND tmp.statement_start_offset = qp.statement_start_offset 
            AND tmp.statement_end_offset = qp.statement_end_offset 
            AND tmp.creation_time = qp.creation_time
        
        SET @rows_affected = @@ROWCOUNT;
        IF(@rows_affected > 0)
        BEGIN
            RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_plan', 0, 1, @rows_affected) WITH NOWAIT;
        END

        -- Check if the execution of the stored proc exceeded the @duration specified
        IF (@duration IS NOT NULL)
        BEGIN
            IF (GETUTCDATE()>=@end_time)
            BEGIN
                PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';
                BREAK
            END
        END

        -- Check if somebody wanted to stop the purge operation
        SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]
        IF (@stop_purge > 0)
        BEGIN
            PRINT 'Stopping purge. Detected a user request to stop purge.';
            BREAK
        END
    END;
    
    PRINT 'End purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())
END

,187,33,154,7156,1764,187

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,543,544,545,561,562,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,507,508,509,510,511,512,547,563,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 117
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 117
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,173,173,0,15795,0,173

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.DriverID IN (55) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,141,141,0,11616,0,1128

	   SELECT 
	   Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate) as DriverName	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.CategoryID IN (14,16,17,18) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) ,135,135,0,12211,0,406

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.CategoryID IN (14,16,17,18) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,131,131,0,12211,0,394

CREATE PROC [dbo].[sp_syscollector_snapshot_dm_exec_query_stats_internal]
  @include_system_databases bit = 1
AS
BEGIN
    SET NOCOUNT ON

    DECLARE @p1 datetime
    SET @p1 = GETDATE()

    SELECT 
        [sql_handle],
        statement_start_offset,
        statement_end_offset,
        -- Use ISNULL here and in other columns to handle in-progress queries that are not yet in sys.dm_exec_query_stats.  
        -- These values only come from sys.dm_exec_query_stats. If the plan does not show up in sys.dm_exec_query_stats 
        -- (first execution of a still-in-progress query, visible in sys.dm_exec_requests), these values will be NULL. 
        MAX (plan_generation_num) AS plan_generation_num,
        plan_handle,
        MIN (creation_time) AS creation_time, 
        MAX (last_execution_time) AS last_execution_time,
        SUM (execution_count) AS execution_count,
        SUM (total_worker_time) AS total_worker_time,
        MIN (min_worker_time) AS min_worker_time,           -- NULLable
        MAX (max_worker_time) AS max_worker_time,
        SUM (total_physical_reads) AS total_physical_reads,
        MIN (min_physical_reads) AS min_physical_reads,     -- NULLable
        MAX (max_physical_reads) AS max_physical_reads,
        SUM (total_logical_writes) AS total_logical_writes,
        MIN (min_logical_writes) AS min_logical_writes,     -- NULLable
        MAX (max_logical_writes) AS max_logical_writes,
        SUM (total_logical_reads) AS total_logical_reads,
        MIN (min_logical_reads) AS min_logical_reads,       -- NULLable
        MAX (max_logical_reads) AS max_logical_reads,
        SUM (total_clr_time) AS total_clr_time,
        MIN (min_clr_time) AS min_clr_time,                 -- NULLable
        MAX (max_clr_time) AS max_clr_time,
        SUM (total_elapsed_time) AS total_elapsed_time,
        MIN (min_elapsed_time) AS min_elapsed_time,         -- NULLable
        MAX (max_elapsed_time) AS max_elapsed_time,
        @p1 AS collection_time
    FROM
    (
        SELECT  
            [sql_handle],
            statement_start_offset,
            statement_end_offset,
            plan_generation_num,
            plan_handle,
            creation_time,
            last_execution_time,
            execution_count,
            total_worker_time,
            min_worker_time,
            max_worker_time,
            total_physical_reads,
            min_physical_reads,
            max_physical_reads,
            total_logical_writes,
            min_logical_writes,
            max_logical_writes,
            total_logical_reads,
            min_logical_reads,
            max_logical_reads,
            total_clr_time,
            min_clr_time,
            max_clr_time,
            total_elapsed_time,
            min_elapsed_time,
            max_elapsed_time 
        FROM sys.dm_exec_query_stats AS q
        -- Temporary workaround for VSTS #91422.  This should be removed if/when sys.dm_exec_query_stats reflects in-progress queries. 
        UNION ALL 
        SELECT 
            r.[sql_handle],
            r.statement_start_offset,
            r.statement_end_offset,
            ISNULL (qs.plan_generation_num, 0) AS plan_generation_num,
            r.plan_handle,
            ISNULL (qs.creation_time, r.start_time) AS creation_time,
            r.start_time AS last_execution_time,
            1 AS execution_count,
            -- dm_exec_requests shows CPU time as ms, while dm_exec_query_stats 
            -- uses microseconds.  Convert ms to us. 
            r.cpu_time * CAST(1000 as bigint) AS total_worker_time,
            qs.min_worker_time,     -- min should not be influenced by in-progress queries
            r.cpu_time * CAST(1000 as bigint) AS max_worker_time,
            r.reads AS total_physical_reads,
            qs.min_physical_reads,  -- min should not be influenced by in-progress queries
            r.reads AS max_physical_reads,
            r.writes AS total_logical_writes,
            qs.min_logical_writes,  -- min should not be influenced by in-progress queries
            r.writes AS max_logical_writes,
            r.logical_reads AS total_logical_reads,
            qs.min_logical_reads,   -- min should not be influenced by in-progress queries
            r.logical_reads AS max_logical_reads,
            qs.total_clr_time,      -- CLR time is not available in dm_exec_requests
            qs.min_clr_time,        -- CLR time is not available in dm_exec_requests
            qs.max_clr_time,        -- CLR time is not available in dm_exec_requests
            -- dm_exec_requests shows elapsed time as ms, while dm_exec_query_stats 
            -- uses microseconds.  Convert ms to us. 
            r.total_elapsed_time * CAST(1000 as bigint) AS total_elapsed_time,
            qs.min_elapsed_time,    -- min should not be influenced by in-progress queries
            r.total_elapsed_time * CAST(1000 as bigint) AS max_elapsed_time
        FROM sys.dm_exec_requests AS r 
        LEFT OUTER JOIN sys.dm_exec_query_stats AS qs ON r.plan_handle = qs.plan_handle AND r.statement_start_offset = qs.statement_start_offset 
            AND r.statement_end_offset = qs.statement_end_offset 
        WHERE r.sql_handle IS NOT NULL 
    ) AS query_stats 
    OUTER APPLY sys.dm_exec_sql_text (sql_handle) AS sql
    WHERE (@include_system_databases = 1 OR ([sql].dbid > 4 AND [sql].dbid < 32767))
    GROUP BY [sql_handle], plan_handle, statement_start_offset, statement_end_offset 
    ORDER BY [sql_handle], plan_handle, statement_start_offset, statement_end_offset
END
,121,116,5,1569,0,1675259

create procedure sys.sp_tables
(
    @table_name         nvarchar(384)   = null,
    @table_owner        nvarchar(384)   = null,
    @table_qualifier    sysname = null,
    @table_type         varchar(100) = null,
    @fUsePattern        bit = 1 -- To allow users to explicitly disable all pattern matching.
)
as
    declare @type1      varchar(3)
    declare @qual_name  nvarchar(517) -- [schema].[table]
    declare @table_id   int

    if @table_qualifier = '%' and @table_owner = '' and @table_name = ''
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #1:  enumerate databases when owner and name are blank but qualifier is explicitly "%".'
        select
            TABLE_QUALIFIER = convert(sysname,d.name),
            TABLE_OWNER     = convert(sysname,null),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),null),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.databases d
        where
            d.name <> 'model' -- eliminate MODEL database
        order by 1
        return
    end

    if @table_qualifier = '' and @table_owner = '%' and @table_name = ''
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #2:  enumerate owners when qualifier and name are blank but owner is explicitly "%".
        select distinct
            TABLE_QUALIFIER = convert(sysname,null),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),null),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.all_objects o
        where
            o.type in ('S','U','V')  -- limit columns to tables and views only
        order by 2
        return
    end

    if @table_qualifier = '' and @table_owner = '' and @table_name = '' and @table_type = '%'
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #3:  enumerate table types when qualifier, owner and name are blank but table type is explicitly "%".'
        select
            TABLE_QUALIFIER = convert(sysname,null),
            TABLE_OWNER     = convert(sysname,null),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLETABLE       VIEW',(c.column_id-1)*12+1,12))),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.all_objects o,
            sys.all_columns c
        where
            o.object_id = c.object_id and o.object_id = object_id('sysusers') and
            c.column_id <= 3 -- ISSUE - what is this for ???
        return
    end

    --
    -- End of special features - do normal processing.
    --

    if @table_qualifier is not null
    begin
        if db_name() <> @table_qualifier
        begin
            if @table_qualifier = ''
            begin  -- If empty qualifier supplied, force an empty result set.
                select @table_name = ''
                select @table_owner = ''
            end
            else
            begin   -- If qualifier doesn't match current database.
                raiserror (15250, -1,-1)
                return
            end
        end
    end
    select @table_qualifier = null -- it's not needed anymore

    if @table_type is null
    begin   -- Select all ODBC supported table types.
        select @type1 = 'SUV'
    end
    else
    begin
        -- TableType is case sensitive if CS server.
        if (charindex('''SYSTEM TABLE''',@table_type) <> 0)
            select @type1 = 'S' -- Add System Tables.
        else
            select @type1 = ''
        if (charindex('''TABLE''',@table_type) <> 0)
            select @type1 = @type1 + 'U' -- Add User Tables.
        if (charindex('''VIEW''',@table_type) <> 0)
            select @type1 = @type1 + 'V' -- Add Views.
    end

    if @table_name is not null
    begin
        if (@table_owner is null) and (charindex('%', @table_name) = 0)
        begin   -- If owner not specified and table contains wildchar.
            if exists
            (
                select
                        *
                from
                        sys.all_objects o
                where
                        o.schema_id = schema_id() and
                        o.object_id = object_id(@table_name) and
                        o.type in ('U','V','S')
            )
            begin   -- Override supplied owner w/owner of table.
                select @table_owner = schema_name()
            end
        end
    end

    select @qual_name = isnull(quotename(@table_owner), '') + '.' + quotename(@table_name)
    select @table_id = object_id(@qual_name)

    if (@fUsePattern = 1) -- Does the user want it?
    begin
        if ((isnull(charindex('%', @table_name),0) = 0) and
            (isnull(charindex('_', @table_name),0) = 0) and
            (isnull(charindex('%', @table_owner),0) = 0) and
            (isnull(charindex('_', @table_owner),0) = 0) and
            (@table_id is not null))
        begin
            select @fUsePattern = 0 -- not a single wild char, so go the fast way.
        end
    end

    if @fUsePattern = 0
    begin
        /* -- Debug output, do not remove it.
        print '*************'
        print 'There is NO pattern matching.'
        print @fUsePattern
        print isnull(@table_name, '@table_name = null')
        print isnull(@table_owner, '@table_owner = null')
        print isnull(@table_type, '@table_type = null')
        print isnull(@type1, '@type1 = null')
        print '*************'
        */
        select
            TABLE_QUALIFIER = convert(sysname,db_name()),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,o.name),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLE            TABLE       VIEW       ',
                                        (ascii(o.type)-83)*12+1,12))  -- 'S'=0,'U'=2,'V'=3
                                     ),
            REMARKS = convert(varchar(254),null)    -- Remarks are NULL.

        from
            sys.all_objects o

        where
            o.object_id = @table_id and
            o.type in ('S','U','V') and
            has_perms_by_name(@qual_name, 'object', 'select') = 1 and
            charindex(substring(o.type,1,1),@type1) <> 0 -- Only desired types.
        order by 4, 1, 2, 3
    end
    else
    begin
        /* -- Debug output, do not remove it.
        print '*************'
        print 'THERE IS pattern matching!'
        print @fUsePattern
        print isnull(@table_name, '@table_name = null')
        print isnull(@table_owner, '@table_owner = null')
        print isnull(@table_type, '@table_type = null')
        print isnull(@type1, '@type1 = null')
        print '*************'
        */
        select
            TABLE_QUALIFIER = convert(sysname,db_name()),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,o.name),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLE            TABLE       VIEW       ',
                                              (ascii(o.type)-83)*12+1,
                                              12))  -- 'S'=0,'U'=2,'V'=3
                                     ),
            REMARKS = convert(varchar(254),null)    -- Remarks are NULL.

        from
            sys.all_objects o

        where
            o.type in ('S','U','V') and
            has_perms_by_name(quotename(schema_name(o.schema_id)) + '.' + quotename(o.name),
                              'object',
                              'select') = 1 and
            charindex(substring(o.type,1,1),@type1) <> 0 and -- Only desired types.
            (@table_name  is NULL or o.name like @table_name) and
            (@table_owner is NULL or schema_name(o.schema_id) like @table_owner)
        order by 4, 1, 2, 3
    end
,116,115,1,15654,0,116
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(udf.schema_id) AS [Schema],
udf.name AS [Name],
udf.object_id AS [ID],
(case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType],
CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType],
CAST(
 case 
    when udf.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = udf.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted],
CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound],
usrt.name AS [DataType]
FROM
sys.all_objects AS udf
LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id
LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id
WHERE
(udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))
ORDER BY
[Schema] ASC,[Name] ASC,89,15,74,1283,0,89
CREATE PROCEDURE [core].[sp_purge_data]
    @retention_days smallint = NULL,
    @instance_name sysname = NULL,
    @collection_set_uid uniqueidentifier = NULL,
    @duration smallint = NULL,
    @delete_batch_size int = 500
AS
BEGIN
    -- Security check (role membership)
    IF (NOT (ISNULL(IS_MEMBER(N'mdw_admin'), 0) = 1) AND NOT (ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0) = 1))
    BEGIN
        RAISERROR(14677, 16, -1, 'mdw_admin')
        RETURN(1) -- Failure
    END

    -- Validate parameters
    IF ((@retention_days IS NOT NULL) AND (@retention_days < 0))
    BEGIN
        RAISERROR(14200, -1, -1, '@retention_days')
        RETURN(1) -- Failure
    END

    IF ((@duration IS NOT NULL) AND (@duration < 0))
    BEGIN
        RAISERROR(14200, -1, -1, '@duration')
        RETURN(1) -- Failure
    END

    -- This table will contain a record if somebody requests purge to stop
    -- If user requested us to purge data - we reset the content of it - and proceed with purge
    -- If somebody in a different session wants purge operations to stop he adds a record
    -- that we will discover while purge in progress
    --
    -- We dont clear this flag when we exit since multiple purge operations with differnet
    -- filters may proceed, and we want all of them to stop.
    DELETE FROM [core].[purge_info_internal]

    SET @instance_name = NULLIF(LTRIM(RTRIM(@instance_name)), N'')

    -- Calculate the time when the operation should stop (NULL otherwise)
    DECLARE @end_time datetime
    IF (@duration IS NOT NULL)
    BEGIN
        SET @end_time = DATEADD(minute, @duration, GETUTCDATE())
    END

    -- Declare table that will be used to find what are the valid
    -- candidate snapshots that could be selected for purge
    DECLARE @purge_candidates table
    (
        snapshot_id int NOT NULL,
        snapshot_time datetime NOT NULL,
        instance_name sysname NOT NULL,
        collection_set_uid uniqueidentifier NOT NULL
    )

    -- Find candidates that match the retention_days criteria (if specified)
    IF (@retention_days IS NULL)
    BEGIN
        -- User did not specified a value for @retention_days, therfore we
        -- will use the default expiration day as marked in the source info
        INSERT INTO @purge_candidates
        SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid
        FROM core.snapshots s
        WHERE (GETUTCDATE() >= s.valid_through)
    END
    ELSE
    BEGIN
        -- User specified a value for @retention_days, we will use this overriden value
        -- when deciding what means old enough to qualify for purge this overrides
        -- the days_until_expiration value specified in the source_info_internal table
        INSERT INTO @purge_candidates
        SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid
        FROM core.snapshots s
        WHERE GETUTCDATE() >= DATEADD(DAY, @retention_days, s.snapshot_time)
    END

    -- Determine which is the oldest snapshot, from the list of candidates
    DECLARE oldest_snapshot_cursor CURSOR FORWARD_ONLY READ_ONLY FOR
    SELECT p.snapshot_id, p.instance_name, p.collection_set_uid
    FROM @purge_candidates p
    WHERE 
        ((@instance_name IS NULL) or (p.instance_name = @instance_name)) AND
        ((@collection_set_uid IS NULL) or (p.collection_set_uid = @collection_set_uid))
    ORDER BY p.snapshot_time ASC    

    OPEN oldest_snapshot_cursor

    DECLARE @stop_purge int
    DECLARE @oldest_snapshot_id int
    DECLARE @oldest_instance_name sysname
    DECLARE @oldest_collection_set_uid uniqueidentifier

    FETCH NEXT FROM oldest_snapshot_cursor
    INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid

    -- As long as there are snapshots that matched the time criteria
    WHILE @@FETCH_STATUS = 0
    BEGIN

        -- Filter out records that do not match the other filter crieria
        IF ((@instance_name IS NULL) or (@oldest_instance_name = @instance_name))
        BEGIN

            -- There was no filter specified for instance_name or the instance matches the filter
            IF ((@collection_set_uid IS NULL) or (@oldest_collection_set_uid = @collection_set_uid))
            BEGIN

                -- There was no filter specified for the collection_set_uid or the collection_set_uid matches the filter
                BEGIN TRANSACTION tran_sp_purge_data

                -- Purge data associated with this snapshot. Note: deleting this snapshot
                -- triggers cascade delete in all warehouse tables based on the foreign key 
                -- relationship to snapshots table

                -- Cascade cleanup of all data related referencing oldest snapshot
                DELETE core.snapshots_internal
                FROM core.snapshots_internal s
                WHERE s.snapshot_id = @oldest_snapshot_id

                COMMIT TRANSACTION tran_sp_purge_data

                PRINT 'Snapshot #' + CONVERT(VARCHAR, @oldest_snapshot_id) + ' purged.';
            END

        END

        -- Check if the execution of the stored proc exceeded the @duration specified
        IF (@duration IS NOT NULL)
        BEGIN
            IF (GETUTCDATE()>=@end_time)
            BEGIN
                PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';
                BREAK
            END
        END

        -- Check if somebody wanted to stop the purge operation
        SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]
        IF (@stop_purge > 0)
        BEGIN
                PRINT 'Stopping purge. Detected a user request to stop purge.';
            BREAK
        END

        -- Move to next oldest snapshot
        FETCH NEXT FROM oldest_snapshot_cursor
        INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid

    END

    CLOSE oldest_snapshot_cursor
    DEALLOCATE oldest_snapshot_cursor

    -- delete orphaned query plans
    EXEC [core].[sp_purge_orphaned_notable_query_plan] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size

    -- delete orphaned query text
    EXEC [core].[sp_purge_orphaned_notable_query_text] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size
       
END
,72,52,20,69973,280,6698
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(udf.schema_id) AS [Schema],
udf.name AS [Name],
udf.object_id AS [ID],
(case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType],
CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType],
CAST(
 case 
    when udf.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = udf.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted],
CAST(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound') AS bit) AS [IsSchemaBound],
usrt.name AS [DataType],
ISNULL(baset.name, N'') AS [SystemType],
CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length],
CAST(ret_param.precision AS int) AS [NumericPrecision],
CAST(ret_param.scale AS int) AS [NumericScale],
ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace],
ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema],
ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint],
sret_param.name AS [DataTypeSchema]
FROM
sys.all_objects AS udf
LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id
LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id
LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1)) 
LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id
LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id
LEFT OUTER JOIN sys.schemas AS sret_param ON sret_param.schema_id = usrt.schema_id
WHERE
(udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))
ORDER BY
[Schema] ASC,[Name] ASC,65,17,48,1514,0,326
CREATE PROCEDURE [core].[sp_purge_data]
    @retention_days smallint = NULL,
    @instance_name sysname = NULL,
    @collection_set_uid uniqueidentifier = NULL,
    @duration smallint = NULL,
    @delete_batch_size int = 500
AS
BEGIN
    -- Security check (role membership)
    IF (NOT (ISNULL(IS_MEMBER(N'mdw_admin'), 0) = 1) AND NOT (ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0) = 1))
    BEGIN
        RAISERROR(14677, 16, -1, 'mdw_admin')
        RETURN(1) -- Failure
    END

    -- Validate parameters
    IF ((@retention_days IS NOT NULL) AND (@retention_days < 0))
    BEGIN
        RAISERROR(14200, -1, -1, '@retention_days')
        RETURN(1) -- Failure
    END

    IF ((@duration IS NOT NULL) AND (@duration < 0))
    BEGIN
        RAISERROR(14200, -1, -1, '@duration')
        RETURN(1) -- Failure
    END

    -- This table will contain a record if somebody requests purge to stop
    -- If user requested us to purge data - we reset the content of it - and proceed with purge
    -- If somebody in a different session wants purge operations to stop he adds a record
    -- that we will discover while purge in progress
    --
    -- We dont clear this flag when we exit since multiple purge operations with differnet
    -- filters may proceed, and we want all of them to stop.
    DELETE FROM [core].[purge_info_internal]

    SET @instance_name = NULLIF(LTRIM(RTRIM(@instance_name)), N'')

    -- Calculate the time when the operation should stop (NULL otherwise)
    DECLARE @end_time datetime
    IF (@duration IS NOT NULL)
    BEGIN
        SET @end_time = DATEADD(minute, @duration, GETUTCDATE())
    END

    -- Declare table that will be used to find what are the valid
    -- candidate snapshots that could be selected for purge
    DECLARE @purge_candidates table
    (
        snapshot_id int NOT NULL,
        snapshot_time datetime NOT NULL,
        instance_name sysname NOT NULL,
        collection_set_uid uniqueidentifier NOT NULL
    )

    -- Find candidates that match the retention_days criteria (if specified)
    IF (@retention_days IS NULL)
    BEGIN
        -- User did not specified a value for @retention_days, therfore we
        -- will use the default expiration day as marked in the source info
        INSERT INTO @purge_candidates
        SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid
        FROM core.snapshots s
        WHERE (GETUTCDATE() >= s.valid_through)
    END
    ELSE
    BEGIN
        -- User specified a value for @retention_days, we will use this overriden value
        -- when deciding what means old enough to qualify for purge this overrides
        -- the days_until_expiration value specified in the source_info_internal table
        INSERT INTO @purge_candidates
        SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid
        FROM core.snapshots s
        WHERE GETUTCDATE() >= DATEADD(DAY, @retention_days, s.snapshot_time)
    END

    -- Determine which is the oldest snapshot, from the list of candidates
    DECLARE oldest_snapshot_cursor CURSOR FORWARD_ONLY READ_ONLY FOR
    SELECT p.snapshot_id, p.instance_name, p.collection_set_uid
    FROM @purge_candidates p
    WHERE 
        ((@instance_name IS NULL) or (p.instance_name = @instance_name)) AND
        ((@collection_set_uid IS NULL) or (p.collection_set_uid = @collection_set_uid))
    ORDER BY p.snapshot_time ASC    

    OPEN oldest_snapshot_cursor

    DECLARE @stop_purge int
    DECLARE @oldest_snapshot_id int
    DECLARE @oldest_instance_name sysname
    DECLARE @oldest_collection_set_uid uniqueidentifier

    FETCH NEXT FROM oldest_snapshot_cursor
    INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid

    -- As long as there are snapshots that matched the time criteria
    WHILE @@FETCH_STATUS = 0
    BEGIN

        -- Filter out records that do not match the other filter crieria
        IF ((@instance_name IS NULL) or (@oldest_instance_name = @instance_name))
        BEGIN

            -- There was no filter specified for instance_name or the instance matches the filter
            IF ((@collection_set_uid IS NULL) or (@oldest_collection_set_uid = @collection_set_uid))
            BEGIN

                -- There was no filter specified for the collection_set_uid or the collection_set_uid matches the filter
                BEGIN TRANSACTION tran_sp_purge_data

                -- Purge data associated with this snapshot. Note: deleting this snapshot
                -- triggers cascade delete in all warehouse tables based on the foreign key 
                -- relationship to snapshots table

                -- Cascade cleanup of all data related referencing oldest snapshot
                DELETE core.snapshots_internal
                FROM core.snapshots_internal s
                WHERE s.snapshot_id = @oldest_snapshot_id

                COMMIT TRANSACTION tran_sp_purge_data

                PRINT 'Snapshot #' + CONVERT(VARCHAR, @oldest_snapshot_id) + ' purged.';
            END

        END

        -- Check if the execution of the stored proc exceeded the @duration specified
        IF (@duration IS NOT NULL)
        BEGIN
            IF (GETUTCDATE()>=@end_time)
            BEGIN
                PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';
                BREAK
            END
        END

        -- Check if somebody wanted to stop the purge operation
        SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]
        IF (@stop_purge > 0)
        BEGIN
                PRINT 'Stopping purge. Detected a user request to stop purge.';
            BREAK
        END

        -- Move to next oldest snapshot
        FETCH NEXT FROM oldest_snapshot_cursor
        INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid

    END

    CLOSE oldest_snapshot_cursor
    DEALLOCATE oldest_snapshot_cursor

    -- delete orphaned query plans
    EXEC [core].[sp_purge_orphaned_notable_query_plan] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size

    -- delete orphaned query text
    EXEC [core].[sp_purge_orphaned_notable_query_text] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size
       
END
,64,59,5,4045,8,64
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(udf.schema_id) AS [Schema],
udf.name AS [Name],
udf.object_id AS [ID],
(case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType],
CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType],
CAST(
 case 
    when udf.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = udf.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted],
CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound],
usrt.name AS [DataType]
FROM
sys.all_objects AS udf
LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id
LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id
WHERE
(udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))
ORDER BY
[Schema] ASC,[Name] ASC,61,16,45,1626,0,61
select * from Hrcy_BusinessUnit,58,12,46,6084,0,116

	   SELECT 
	   Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate) as DriverName	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(278,448,449,450,451,452,453,454,455,514,515,516,517) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) ,50,50,0,4033,0,150

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.CategoryID IN (-2,6,7,8,23) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,45,45,0,4425,0,182
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(udf.schema_id) AS [Schema],
udf.name AS [Name],
udf.object_id AS [ID],
(case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType],
CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType],
CAST(
 case 
    when udf.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = udf.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject],
CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted],
CAST(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound') AS bit) AS [IsSchemaBound],
usrt.name AS [DataType],
ISNULL(baset.name, N'') AS [SystemType],
CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length],
CAST(ret_param.precision AS int) AS [NumericPrecision],
CAST(ret_param.scale AS int) AS [NumericScale],
ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace],
ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema],
ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint],
sret_param.name AS [DataTypeSchema]
FROM
sys.all_objects AS udf
LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id
LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id
LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id
LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1)) 
LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id
LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id
LEFT OUTER JOIN sys.schemas AS sret_param ON sret_param.schema_id = usrt.schema_id
WHERE
(udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))
ORDER BY
[Schema] ASC,[Name] ASC,44,23,21,2121,0,220

	   SELECT 
	   Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate) as DriverName	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.CategoryID IN (-2,6,7,8,23) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) ,43,43,0,4144,0,129

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(278,448,449,450,451,452,453,454,455,514,515,516,517) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,41,41,0,4033,0,125

create procedure sys.sp_tables
(
    @table_name         nvarchar(384)   = null,
    @table_owner        nvarchar(384)   = null,
    @table_qualifier    sysname = null,
    @table_type         varchar(100) = null,
    @fUsePattern        bit = 1 -- To allow users to explicitly disable all pattern matching.
)
as
    declare @type1      varchar(3)
    declare @qual_name  nvarchar(517) -- [schema].[table]
    declare @table_id   int

    if @table_qualifier = '%' and @table_owner = '' and @table_name = ''
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #1:  enumerate databases when owner and name are blank but qualifier is explicitly "%".'
        select
            TABLE_QUALIFIER = convert(sysname,d.name),
            TABLE_OWNER     = convert(sysname,null),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),null),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.databases d
        where
            d.name <> 'model' -- eliminate MODEL database
        order by 1
        return
    end

    if @table_qualifier = '' and @table_owner = '%' and @table_name = ''
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #2:  enumerate owners when qualifier and name are blank but owner is explicitly "%".
        select distinct
            TABLE_QUALIFIER = convert(sysname,null),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),null),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.all_objects o
        where
            o.type in ('S','U','V')  -- limit columns to tables and views only
        order by 2
        return
    end

    if @table_qualifier = '' and @table_owner = '' and @table_name = '' and @table_type = '%'
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #3:  enumerate table types when qualifier, owner and name are blank but table type is explicitly "%".'
        select
            TABLE_QUALIFIER = convert(sysname,null),
            TABLE_OWNER     = convert(sysname,null),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLETABLE       VIEW',(c.column_id-1)*12+1,12))),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.all_objects o,
            sys.all_columns c
        where
            o.object_id = c.object_id and o.object_id = object_id('sysusers') and
            c.column_id <= 3 -- ISSUE - what is this for ???
        return
    end

    --
    -- End of special features - do normal processing.
    --

    if @table_qualifier is not null
    begin
        if db_name() <> @table_qualifier
        begin
            if @table_qualifier = ''
            begin  -- If empty qualifier supplied, force an empty result set.
                select @table_name = ''
                select @table_owner = ''
            end
            else
            begin   -- If qualifier doesn't match current database.
                raiserror (15250, -1,-1)
                return
            end
        end
    end
    select @table_qualifier = null -- it's not needed anymore

    if @table_type is null
    begin   -- Select all ODBC supported table types.
        select @type1 = 'SUV'
    end
    else
    begin
        -- TableType is case sensitive if CS server.
        if (charindex('''SYSTEM TABLE''',@table_type) <> 0)
            select @type1 = 'S' -- Add System Tables.
        else
            select @type1 = ''
        if (charindex('''TABLE''',@table_type) <> 0)
            select @type1 = @type1 + 'U' -- Add User Tables.
        if (charindex('''VIEW''',@table_type) <> 0)
            select @type1 = @type1 + 'V' -- Add Views.
    end

    if @table_name is not null
    begin
        if (@table_owner is null) and (charindex('%', @table_name) = 0)
        begin   -- If owner not specified and table contains wildchar.
            if exists
            (
                select
                        *
                from
                        sys.all_objects o
                where
                        o.schema_id = schema_id() and
                        o.object_id = object_id(@table_name) and
                        o.type in ('U','V','S')
            )
            begin   -- Override supplied owner w/owner of table.
                select @table_owner = schema_name()
            end
        end
    end

    select @qual_name = isnull(quotename(@table_owner), '') + '.' + quotename(@table_name)
    select @table_id = object_id(@qual_name)

    if (@fUsePattern = 1) -- Does the user want it?
    begin
        if ((isnull(charindex('%', @table_name),0) = 0) and
            (isnull(charindex('_', @table_name),0) = 0) and
            (isnull(charindex('%', @table_owner),0) = 0) and
            (isnull(charindex('_', @table_owner),0) = 0) and
            (@table_id is not null))
        begin
            select @fUsePattern = 0 -- not a single wild char, so go the fast way.
        end
    end

    if @fUsePattern = 0
    begin
        /* -- Debug output, do not remove it.
        print '*************'
        print 'There is NO pattern matching.'
        print @fUsePattern
        print isnull(@table_name, '@table_name = null')
        print isnull(@table_owner, '@table_owner = null')
        print isnull(@table_type, '@table_type = null')
        print isnull(@type1, '@type1 = null')
        print '*************'
        */
        select
            TABLE_QUALIFIER = convert(sysname,db_name()),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,o.name),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLE            TABLE       VIEW       ',
                                        (ascii(o.type)-83)*12+1,12))  -- 'S'=0,'U'=2,'V'=3
                                     ),
            REMARKS = convert(varchar(254),null)    -- Remarks are NULL.

        from
            sys.all_objects o

        where
            o.object_id = @table_id and
            o.type in ('S','U','V') and
            has_perms_by_name(@qual_name, 'object', 'select') = 1 and
            charindex(substring(o.type,1,1),@type1) <> 0 -- Only desired types.
        order by 4, 1, 2, 3
    end
    else
    begin
        /* -- Debug output, do not remove it.
        print '*************'
        print 'THERE IS pattern matching!'
        print @fUsePattern
        print isnull(@table_name, '@table_name = null')
        print isnull(@table_owner, '@table_owner = null')
        print isnull(@table_type, '@table_type = null')
        print isnull(@type1, '@type1 = null')
        print '*************'
        */
        select
            TABLE_QUALIFIER = convert(sysname,db_name()),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,o.name),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLE            TABLE       VIEW       ',
                                              (ascii(o.type)-83)*12+1,
                                              12))  -- 'S'=0,'U'=2,'V'=3
                                     ),
            REMARKS = convert(varchar(254),null)    -- Remarks are NULL.

        from
            sys.all_objects o

        where
            o.type in ('S','U','V') and
            has_perms_by_name(quotename(schema_name(o.schema_id)) + '.' + quotename(o.name),
                              'object',
                              'select') = 1 and
            charindex(substring(o.type,1,1),@type1) <> 0 and -- Only desired types.
            (@table_name  is NULL or o.name like @table_name) and
            (@table_owner is NULL or schema_name(o.schema_id) like @table_owner)
        order by 4, 1, 2, 3
    end
,40,40,0,3587,0,40

create procedure sys.sp_tables
(
    @table_name         nvarchar(384)   = null,
    @table_owner        nvarchar(384)   = null,
    @table_qualifier    sysname = null,
    @table_type         varchar(100) = null,
    @fUsePattern        bit = 1 -- To allow users to explicitly disable all pattern matching.
)
as
    declare @type1      varchar(3)
    declare @qual_name  nvarchar(517) -- [schema].[table]
    declare @table_id   int

    if @table_qualifier = '%' and @table_owner = '' and @table_name = ''
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #1:  enumerate databases when owner and name are blank but qualifier is explicitly "%".'
        select
            TABLE_QUALIFIER = convert(sysname,d.name),
            TABLE_OWNER     = convert(sysname,null),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),null),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.databases d
        where
            d.name <> 'model' -- eliminate MODEL database
        order by 1
        return
    end

    if @table_qualifier = '' and @table_owner = '%' and @table_name = ''
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #2:  enumerate owners when qualifier and name are blank but owner is explicitly "%".
        select distinct
            TABLE_QUALIFIER = convert(sysname,null),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),null),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.all_objects o
        where
            o.type in ('S','U','V')  -- limit columns to tables and views only
        order by 2
        return
    end

    if @table_qualifier = '' and @table_owner = '' and @table_name = '' and @table_type = '%'
    begin
        -- Debug output, do not remove it.
        -- print 'Special feature #3:  enumerate table types when qualifier, owner and name are blank but table type is explicitly "%".'
        select
            TABLE_QUALIFIER = convert(sysname,null),
            TABLE_OWNER     = convert(sysname,null),
            TABLE_NAME      = convert(sysname,null),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLETABLE       VIEW',(c.column_id-1)*12+1,12))),
            REMARKS         = convert(varchar(254),null)    -- Remarks are NULL.
        from
            sys.all_objects o,
            sys.all_columns c
        where
            o.object_id = c.object_id and o.object_id = object_id('sysusers') and
            c.column_id <= 3 -- ISSUE - what is this for ???
        return
    end

    --
    -- End of special features - do normal processing.
    --

    if @table_qualifier is not null
    begin
        if db_name() <> @table_qualifier
        begin
            if @table_qualifier = ''
            begin  -- If empty qualifier supplied, force an empty result set.
                select @table_name = ''
                select @table_owner = ''
            end
            else
            begin   -- If qualifier doesn't match current database.
                raiserror (15250, -1,-1)
                return
            end
        end
    end
    select @table_qualifier = null -- it's not needed anymore

    if @table_type is null
    begin   -- Select all ODBC supported table types.
        select @type1 = 'SUV'
    end
    else
    begin
        -- TableType is case sensitive if CS server.
        if (charindex('''SYSTEM TABLE''',@table_type) <> 0)
            select @type1 = 'S' -- Add System Tables.
        else
            select @type1 = ''
        if (charindex('''TABLE''',@table_type) <> 0)
            select @type1 = @type1 + 'U' -- Add User Tables.
        if (charindex('''VIEW''',@table_type) <> 0)
            select @type1 = @type1 + 'V' -- Add Views.
    end

    if @table_name is not null
    begin
        if (@table_owner is null) and (charindex('%', @table_name) = 0)
        begin   -- If owner not specified and table contains wildchar.
            if exists
            (
                select
                        *
                from
                        sys.all_objects o
                where
                        o.schema_id = schema_id() and
                        o.object_id = object_id(@table_name) and
                        o.type in ('U','V','S')
            )
            begin   -- Override supplied owner w/owner of table.
                select @table_owner = schema_name()
            end
        end
    end

    select @qual_name = isnull(quotename(@table_owner), '') + '.' + quotename(@table_name)
    select @table_id = object_id(@qual_name)

    if (@fUsePattern = 1) -- Does the user want it?
    begin
        if ((isnull(charindex('%', @table_name),0) = 0) and
            (isnull(charindex('_', @table_name),0) = 0) and
            (isnull(charindex('%', @table_owner),0) = 0) and
            (isnull(charindex('_', @table_owner),0) = 0) and
            (@table_id is not null))
        begin
            select @fUsePattern = 0 -- not a single wild char, so go the fast way.
        end
    end

    if @fUsePattern = 0
    begin
        /* -- Debug output, do not remove it.
        print '*************'
        print 'There is NO pattern matching.'
        print @fUsePattern
        print isnull(@table_name, '@table_name = null')
        print isnull(@table_owner, '@table_owner = null')
        print isnull(@table_type, '@table_type = null')
        print isnull(@type1, '@type1 = null')
        print '*************'
        */
        select
            TABLE_QUALIFIER = convert(sysname,db_name()),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,o.name),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLE            TABLE       VIEW       ',
                                        (ascii(o.type)-83)*12+1,12))  -- 'S'=0,'U'=2,'V'=3
                                     ),
            REMARKS = convert(varchar(254),null)    -- Remarks are NULL.

        from
            sys.all_objects o

        where
            o.object_id = @table_id and
            o.type in ('S','U','V') and
            has_perms_by_name(@qual_name, 'object', 'select') = 1 and
            charindex(substring(o.type,1,1),@type1) <> 0 -- Only desired types.
        order by 4, 1, 2, 3
    end
    else
    begin
        /* -- Debug output, do not remove it.
        print '*************'
        print 'THERE IS pattern matching!'
        print @fUsePattern
        print isnull(@table_name, '@table_name = null')
        print isnull(@table_owner, '@table_owner = null')
        print isnull(@table_type, '@table_type = null')
        print isnull(@type1, '@type1 = null')
        print '*************'
        */
        select
            TABLE_QUALIFIER = convert(sysname,db_name()),
            TABLE_OWNER     = convert(sysname,schema_name(o.schema_id)),
            TABLE_NAME      = convert(sysname,o.name),
            TABLE_TYPE      = convert(varchar(32),
                                        rtrim(substring('SYSTEM TABLE            TABLE       VIEW       ',
                                              (ascii(o.type)-83)*12+1,
                                              12))  -- 'S'=0,'U'=2,'V'=3
                                     ),
            REMARKS = convert(varchar(254),null)    -- Remarks are NULL.

        from
            sys.all_objects o

        where
            o.type in ('S','U','V') and
            has_perms_by_name(quotename(schema_name(o.schema_id)) + '.' + quotename(o.name),
                              'object',
                              'select') = 1 and
            charindex(substring(o.type,1,1),@type1) <> 0 and -- Only desired types.
            (@table_name  is NULL or o.name like @table_name) and
            (@table_owner is NULL or schema_name(o.schema_id) like @table_owner)
        order by 4, 1, 2, 3
    end
,34,34,0,3309,0,34
Select MUG.userGroupID,MUG.UserRightCode,MUG.GroupName,MUG.GroupDescription,CAL.CalID,CAL.PersonID,Person.FirstName,Person.LastName,Person.Email1,Person.Email2,UsrLogin.usrlog, CAL.PeriodID From Mas_UserGroups MUG inner join CAL_UserAuthen CAL on MUG.UserRightCode=CAL.UserRightCode Left join Profile_Personal Person on Person.PersonID=CAL.PersonID and Person.IsDelete=0  Left join Profile_userLogin UsrLogin ON UsrLogin.personID=Person.PersonID and UsrLogin.IsActive=1 and UsrLogin.IsDelete=0 Where MUG.Deletable=0 and MUG.SWCode='RM05' Order by CAL.PersonID, MUG.UserRightCode,31,10,21,2548,0,62
CREATE PROCEDURE [dbo].[sp_syscollector_purge_collection_logs]
    @reference_date datetime = NULL
AS
BEGIN
    SET NOCOUNT ON

    -- Security check (role membership)
    IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))
    BEGIN
        RAISERROR(14677, -1, -1, 'dc_proxy')
        RETURN(1) -- Failure
    END

    IF (@reference_date IS NULL)
    BEGIN
        SET @reference_date = GETDATE()
    END
    
    -- An expired log record is any record of a collection set that is older than 
    -- the reference date minus the collection set's days_until_expiration
    CREATE TABLE #purged_log_ids (log_id BIGINT)
    
    INSERT INTO #purged_log_ids
    SELECT log_id
    FROM syscollector_execution_log_internal as l
    INNER JOIN syscollector_collection_sets s ON l.collection_set_id = s.collection_set_id
    WHERE s.days_until_expiration > 0
    AND @reference_date >= DATEADD(DAY, s.days_until_expiration, l.finish_time)

    -- Delete all ssis log records pertaining to expired logs
    DELETE FROM dbo.sysssislog
        FROM dbo.sysssislog AS s
        INNER JOIN dbo.syscollector_execution_log_internal AS l ON (l.package_execution_id = s.executionid)
        INNER JOIN #purged_log_ids AS i ON i.log_id = l.log_id
        
    -- Then delete the actual logs
    DELETE FROM syscollector_execution_log_internal
        FROM syscollector_execution_log_internal AS l
        INNER Join #purged_log_ids AS i ON i.log_id = l.log_id

    DROP TABLE #purged_log_ids
    -- Go for another round to cleanup the orphans
    -- Ideally, the log heirarchy guarantees that a finish time by a parent log will always
    -- be higher than the finish time of any of its descendants.
    -- The purge step however does not delete log records with a null finish time
    -- A child log can have a null finish time while its parent is closed if there is an
    -- error in execution that causes the log to stay open.
    -- If such a child log exists, its parent will be purged leaving it as an orphan
    
    -- get orphan records and all their descendants in a cursor and purge them
    DECLARE orphaned_log_cursor INSENSITIVE CURSOR FOR
            SELECT log_id 
            FROM syscollector_execution_log_internal
            WHERE parent_log_id NOT IN (
                SELECT log_id FROM syscollector_execution_log_internal
            )
            FOR READ ONLY
            
    DECLARE @log_id BIGINT

    -- for every orphan, delete all its remaining tree
    -- this is supposedly a very small fraction of the entire log
    OPEN orphaned_log_cursor    
    FETCH orphaned_log_cursor INTO @log_id
    WHILE @@FETCH_STATUS = 0
    BEGIN
        EXEC sp_syscollector_delete_execution_log_tree @log_id = @log_id, @from_collection_set = 0
        FETCH orphaned_log_cursor INTO @log_id
    END
    
    CLOSE orphaned_log_cursor
    DEALLOCATE orphaned_log_cursor
END
,22,21,1,4083,1,8075
SELECT [ICProfile].[MonitorConclusion] AS [MonitorConclusion],
  [ICProfile].[Monitoring] AS [Monitoring]
FROM [dbo].[ICProfile] [ICProfile]
GROUP BY [ICProfile].[MonitorConclusion],
  [ICProfile].[Monitoring],21,15,6,33,0,21
Select MUG.userGroupID,MUG.UserRightCode,MUG.GroupName,MUG.GroupDescription,CAL.CalID,CAL.PersonID,Person.FirstName,Person.LastName,Person.Email1,Person.Email2,UsrLogin.usrlog, CAL.PeriodID From Mas_UserGroups MUG inner join CAL_UserAuthen CAL on MUG.UserRightCode=CAL.UserRightCode Left join Profile_Personal Person on Person.PersonID=CAL.PersonID and Person.IsDelete=0  Left join Profile_userLogin UsrLogin ON UsrLogin.personID=Person.PersonID and UsrLogin.IsActive=1 and UsrLogin.IsDelete=0 Where MUG.Deletable=0 and MUG.SWCode='IC05' Order by CAL.PersonID, MUG.UserRightCode,19,6,13,1663,0,38
CREATE   PROCEDURE sp_delete_backuphistory
  @oldest_date datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @backup_set_id TABLE      (backup_set_id INT)
  DECLARE @media_set_id TABLE       (media_set_id INT)
  DECLARE @restore_history_id TABLE (restore_history_id INT)

  INSERT INTO @backup_set_id (backup_set_id)
  SELECT DISTINCT backup_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @media_set_id (media_set_id)
  SELECT DISTINCT media_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @restore_history_id (restore_history_id)
  SELECT DISTINCT restore_history_id
  FROM msdb.dbo.restorehistory
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)

  BEGIN TRANSACTION

  DELETE FROM msdb.dbo.backupfile
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupfilegroup
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefile
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefilegroup
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorehistory
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupset
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediafamily
  FROM msdb.dbo.backupmediafamily bmf
  WHERE bmf.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bmf.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediaset
  FROM msdb.dbo.backupmediaset bms
  WHERE bms.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bms.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  COMMIT TRANSACTION
  RETURN

Quit:
  ROLLBACK TRANSACTION

END
,18,15,3,7740,160,18

	   SELECT 
	   Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate) as DriverName	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(455) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) ,18,18,0,1822,0,56

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(455) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,18,18,0,1822,0,54
CREATE PROCEDURE [dbo].[sp_ssis_getpackage]
  @name sysname,
  @folderid uniqueidentifier
AS
  DECLARE @sid varbinary(85)
  DECLARE @isencrypted bit
  DECLARE @readrolesid varbinary(85)
  DECLARE @readrole nvarchar(128)
  --// Check security, if the row exists
  SELECT @sid = [ownersid], @readrolesid = [readrolesid] FROM sysssispackages WHERE [name] = @name AND [folderid] = @folderid
  IF @sid IS NOT NULL
  BEGIN
      IF @readrolesid IS NOT NULL
      BEGIN
          SELECT @readrole = [name] FROM sys.database_principals WHERE [type] = 'R' AND [sid] = @readrolesid
          IF @readrole IS NULL SET @readrole = 'db_ssisadmin'
      END
      IF @readrole IS NOT NULL
      BEGIN
          IF (IS_MEMBER(@readrole)<>1) AND (IS_MEMBER('db_ssisadmin')<>1) AND (IS_SRVROLEMEMBER('sysadmin')<>1)
          BEGIN
              IF (IS_MEMBER('db_ssisltduser')<>1) OR (@sid<>SUSER_SID())
              BEGIN
                  RAISERROR (14307, -1, -1, @name)
                  RETURN 1  -- Failure
              END
          END
      END
      ELSE
      BEGIN
          IF (IS_MEMBER('db_ssisadmin')<>1) AND (IS_SRVROLEMEMBER('sysadmin')<>1) AND (IS_MEMBER('db_ssisoperator')<>1)
          BEGIN
              IF (IS_MEMBER('db_ssisltduser')<>1) OR (@sid<>SUSER_SID())
              BEGIN
                  RAISERROR (14586, -1, -1, @name)
                  RETURN 1  -- Failure
              END
          END
      END
  END

  SELECT
      packagedata
  FROM
      sysssispackages
  WHERE
      [name] = @name AND
      [folderid] = @folderid
,18,13,5,346,0,1147571

SET NOCOUNT ON
SELECT 
    pm.physical_memory_in_use_kb            AS sql_physical_memory_in_use_kb, 
    pm.large_page_allocations_kb            AS sql_large_page_allocations_kb, 
    pm.locked_page_allocations_kb           AS sql_locked_page_allocations_kb, 
    pm.total_virtual_address_space_kb       AS sql_total_virtual_address_space_kb, 
    pm.virtual_address_space_reserved_kb    AS sql_virtual_address_space_reserved_kb, 
    pm.virtual_address_space_committed_kb   AS sql_virtual_address_space_committed_kb, 
    pm.virtual_address_space_available_kb   AS sql_virtual_address_space_available_kb, 
    pm.page_fault_count                     AS sql_page_fault_count, 
    pm.memory_utilization_percentage        AS sql_memory_utilization_percentage, 
    pm.available_commit_limit_kb            AS sql_available_commit_limit_kb, 
    pm.process_physical_memory_low          AS sql_process_physical_memory_low, 
    pm.process_virtual_memory_low           AS sql_process_virtual_memory_low, 
    
    sm.total_physical_memory_kb             AS system_total_physical_memory_kb, 
    sm.available_physical_memory_kb         AS system_available_physical_memory_kb, 
    sm.total_page_file_kb                   AS system_total_page_file_kb, 
    sm.available_page_file_kb               AS system_available_page_file_kb, 
    sm.system_cache_kb                      AS system_cache_kb, 
    sm.kernel_paged_pool_kb                 AS system_kernel_paged_pool_kb, 
    sm.kernel_nonpaged_pool_kb              AS system_kernel_nonpaged_pool_kb, 
    sm.system_high_memory_signal_state      AS system_high_memory_signal_state, 
    sm.system_low_memory_signal_state       AS system_low_memory_signal_state, 
    
    si.bpool_commit_target                  AS bpool_commit_target, 
    si.bpool_committed                      AS bpool_committed, 
    si.bpool_visible                        AS bpool_visible
FROM sys.dm_os_process_memory AS pm
CROSS JOIN sys.dm_os_sys_memory AS sm   -- single-row DMV
CROSS JOIN sys.dm_os_sys_info AS si;    -- single-row DMV
,18,18,0,0,0,7481779
CREATE PROCEDURE sp_maintplan_delete_log
    @plan_id        UNIQUEIDENTIFIER    = NULL,
    @subplan_id     UNIQUEIDENTIFIER    = NULL,
    @oldest_time    DATETIME            = NULL
AS
BEGIN
    -- @plan_id and @subplan_id must be both NULL or only one exclusively set
   IF (@plan_id IS NOT NULL) AND (@subplan_id IS NOT NULL)
   BEGIN
      RAISERROR(12980, -1, -1, '@plan_id', '@subplan_id')
      RETURN(1)
   END

   --Scenario 1: User wants to delete all logs
   --Scenario 2: User wants to delete all logs older than X date
   --Scenario 3: User wants to delete all logs for a given plan
   --Scenario 4: User wants to delete all logs for a specific subplan
   --Scenario 5: User wants to delete all logs for a given plan older than X date
   --Scenario 6: User wants to delete all logs for a specific subplan older than X date

   -- Special case 1: Delete all logs
   IF (@plan_id IS NULL) AND (@subplan_id IS NULL) AND (@oldest_time IS NULL)
   BEGIN
      DELETE msdb.dbo.sysmaintplan_logdetail
      DELETE msdb.dbo.sysmaintplan_log
      RETURN (0)
   END

   DELETE msdb.dbo.sysmaintplan_log 
    WHERE ( task_detail_id in 
            (SELECT task_detail_id 
             FROM msdb.dbo.sysmaintplan_log 
             WHERE ((@plan_id IS NULL)     OR (plan_id = @plan_id)) AND 
                   ((@subplan_id IS NULL)  OR (subplan_id = @subplan_id)) AND 
                   ((@oldest_time IS NULL) OR (start_time < @oldest_time))) )

    RETURN (0)
END
,17,13,4,5729,719,17
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000))
            create table #tempbackup (database_name nvarchar(128), [type] char(1), backup_finish_date datetime)
            insert into #tempbackup select database_name, [type], max(backup_finish_date) from msdb..backupset where [type] = 'D' or [type] = 'L' or [type]='I' group by database_name, [type]
          


                create table #tmp_sp_db_vardecimal_storage_format (dbname sysname null, vardecimal_enabled varchar(3) null)
                if exists (select o.object_id from sys.system_objects o where o.name=N'sp_db_vardecimal_storage_format')
                begin
                insert into #tmp_sp_db_vardecimal_storage_format exec sys.sp_db_vardecimal_storage_format
                end
            


        DECLARE @is_policy_automation_enabled bit
        SET @is_policy_automation_enabled  = (SELECT CONVERT(bit, current_value)
                                              FROM msdb.dbo.syspolicy_configuration
                                              WHERE name = 'Enabled')
      


SELECT
dtb.name AS [Name],
(select count(*) from master.dbo.sysprocesses p where dtb.database_id=p.dbid) AS [ActiveConnections],
dtb.is_auto_close_on AS [AutoClose],
dtb.is_auto_shrink_on AS [AutoShrink],
dtb.compatibility_level AS [CompatibilityLevel],
dtb.create_date AS [CreateDate],
CAST(0 AS float) AS [DataSpaceUsage],
CAST(0 AS bit) AS [DboLogin],
N'' AS [DefaultFileGroup],
'' AS [DefaultSchema],
dtb.database_id AS [ID],
CAST(0 AS float) AS [IndexSpaceUsage],
CAST(has_dbaccess(dtb.name) AS bit) AS [IsAccessible],
CAST(0 AS bit) AS [IsDbAccessAdmin],
CAST(0 AS bit) AS [IsDbBackupOperator],
CAST(0 AS bit) AS [IsDbDatareader],
CAST(0 AS bit) AS [IsDbDatawriter],
CAST(0 AS bit) AS [IsDbDdlAdmin],
CAST(0 AS bit) AS [IsDbDenyDatareader],
CAST(0 AS bit) AS [IsDbDenyDatawriter],
CAST(0 AS bit) AS [IsDbOwner],
CAST(0 AS bit) AS [IsDbSecurityAdmin],
dtb.is_fulltext_enabled AS [IsFullTextEnabled],
CAST(case when dtb.name in ('master','model','msdb','tempdb') then 1 else dtb.is_distributor end AS bit) AS [IsSystemObject],
(select backup_finish_date from #tempbackup where type = @_msparam_0 and database_name = dtb.name) AS [LastBackupDate],
(select backup_finish_date from #tempbackup where type = @_msparam_1 and database_name = dtb.name) AS [LastDifferentialBackupDate],
(select backup_finish_date from #tempbackup where type = @_msparam_2 and database_name = dtb.name) AS [LastLogBackupDate],
suser_sname(dtb.owner_sid) AS [Owner],
df.physical_name AS [PrimaryFilePath],
(dtb.is_published*1+dtb.is_subscribed*2+dtb.is_merge_published*4) AS [ReplicationOptions],
CAST(0 AS float) AS [Size],
CAST(0 AS float) AS [SpaceAvailable],

            case
            when dtb.collation_name is null then 0x200
            else 0
            end |
            case
            when 1 = dtb.is_in_standby then 0x40
            else 0
            end |
            case dtb.state
            when 1 then 0x2
            when 2 then 0x8
            when 3 then 0x4
            when 4 then 0x10
            when 5 then 0x100
            when 6 then 0x20
            else 1
            end
           AS [Status],
'' AS [UserName],
dtb.is_ansi_null_default_on AS [AnsiNullDefault],
dtb.is_ansi_nulls_on AS [AnsiNullsEnabled],
dtb.is_ansi_padding_on AS [AnsiPaddingEnabled],
dtb.is_ansi_warnings_on AS [AnsiWarningsEnabled],
dtb.is_arithabort_on AS [ArithmeticAbortEnabled],
dtb.is_auto_create_stats_on AS [AutoCreateStatisticsEnabled],
dtb.is_auto_update_stats_on AS [AutoUpdateStatisticsEnabled],
CAST(CHARINDEX(N'_CS_', dtb.collation_name) AS bit) AS [CaseSensitive],
dtb.is_cursor_close_on_commit_on AS [CloseCursorsOnCommitEnabled],
dtb.collation_name AS [Collation],
dtb.is_concat_null_yields_null_on AS [ConcatenateNullYieldsNull],
dtb.is_db_chaining_on AS [DatabaseOwnershipChaining],
CAST(( case LOWER(convert( nvarchar(128), DATABASEPROPERTYEX(dtb.name, 'Updateability'))) when 'read_write' then 1 else 0 end) AS bit) AS [IsUpdateable],
dtb.is_local_cursor_default AS [LocalCursorsDefault],
dtb.is_numeric_roundabort_on AS [NumericRoundAbortEnabled],
dtb.page_verify_option AS [PageVerify],
dtb.is_quoted_identifier_on AS [QuotedIdentifiersEnabled],
dtb.is_read_only AS [ReadOnly],
dtb.recovery_model AS [RecoveryModel],
dtb.is_recursive_triggers_on AS [RecursiveTriggersEnabled],
dtb.user_access AS [UserAccess],
CAST(DATABASEPROPERTYEX(dtb.name, 'Version') AS int) AS [Version],
dtb.is_auto_update_stats_async_on AS [AutoUpdateStatisticsAsync],
dtb.is_broker_enabled AS [BrokerEnabled],
drs.database_guid AS [DatabaseGuid],
ISNULL(DB_NAME(dtb.source_database_id), N'') AS [DatabaseSnapshotBaseName],
dtb.is_date_correlation_on AS [DateCorrelationOptimization],
ISNULL((select top 1 ftc.name from sys.fulltext_catalogs as ftc where ftc.is_default=1),N'') AS [DefaultFullTextCatalog],
CAST(isnull(dtb.source_database_id, 0) AS bit) AS [IsDatabaseSnapshot],
CAST((select count(1) from sys.databases dtbmir where dtbmir.source_database_id = dtb.database_id) AS bit) AS [IsDatabaseSnapshotBase],
0 AS [IsMailHost],
CAST(case when dmi.mirroring_partner_name is null then 0 else 1 end AS bit) AS [IsMirroringEnabled],
dtb.is_parameterization_forced AS [IsParameterizationForced],
dtb.is_read_committed_snapshot_on AS [IsReadCommittedSnapshotOn],

                case
                when vardec.vardecimal_enabled = 'ON' then cast(1 as bit)
                else cast(0 as bit)
                end
             AS [IsVarDecimalStorageFormatEnabled],
ISNULL(dtb.log_reuse_wait,0) AS [LogReuseWaitStatus],
ISNULL(dmi.mirroring_failover_lsn,0) AS [MirroringFailoverLogSequenceNumber],
ISNULL(dmi.mirroring_guid,'00000000-0000-0000-0000-0000000000000000') AS [MirroringID],
ISNULL(dmi.mirroring_partner_name,'') AS [MirroringPartner],
ISNULL(dmi.mirroring_partner_instance,'') AS [MirroringPartnerInstance],
ISNULL((case dmi.mirroring_redo_queue_type when N'UNLIMITED' then 0 else dmi.mirroring_redo_queue end),0) AS [MirroringRedoQueueMaxSize],
ISNULL(dmi.mirroring_role,0) AS [MirroringRole],
ISNULL(dmi.mirroring_role_sequence,0) AS [MirroringRoleSequence],
ISNULL(dmi.mirroring_safety_level + 1, 0) AS [MirroringSafetyLevel],
ISNULL(dmi.mirroring_safety_sequence,0) AS [MirroringSafetySequence],
ISNULL(dmi.mirroring_state + 1, 0) AS [MirroringStatus],
ISNULL(dmi.mirroring_connection_timeout,0) AS [MirroringTimeout],
ISNULL(dmi.mirroring_witness_name,'') AS [MirroringWitness],
ISNULL(dmi.mirroring_witness_state + 1, 0) AS [MirroringWitnessStatus],
drs.recovery_fork_guid AS [RecoveryForkGuid],
dtb.service_broker_guid AS [ServiceBrokerGuid],
dtb.snapshot_isolation_state AS [SnapshotIsolationState],
dtb.is_trustworthy_on AS [Trustworthy],
CAST(ISNULL(ctb.is_auto_cleanup_on,0) AS bit) AS [ChangeTrackingAutoCleanUp],
CAST(case when ctb.database_id is null then 0 else 1  end AS bit) AS [ChangeTrackingEnabled],
ISNULL(ctb.retention_period,0) AS [ChangeTrackingRetentionPeriod],
CAST(ISNULL(ctb.retention_period_units,0) AS tinyint) AS [ChangeTrackingRetentionPeriodUnits],
N'' AS [DefaultFileStreamFileGroup],
CAST(dtb.is_encrypted AS bit) AS [EncryptionEnabled],
CAST(dtb.is_honor_broker_priority_on AS bit) AS [HonorBrokerPriority],
CAST(0 AS bit) AS [IsManagementDataWarehouse],
case when 1=@is_policy_automation_enabled and exists (select * from msdb.dbo.syspolicy_system_health_state where target_query_expression_with_id like 'Server'+ '/Database\[@ID=' + convert(nvarchar(20),dtb.database_id) + '\]%' ESCAPE '\') then 1 else 0 end AS [PolicyHealthState],
dtb.name AS [DatabaseName],
dtb.name AS [DatabaseName2]
FROM
master.sys.databases AS dtb
LEFT OUTER JOIN sys.master_files AS df ON df.database_id = dtb.database_id and 1=df.data_space_id and 1 = df.file_id
LEFT OUTER JOIN sys.database_recovery_status AS drs ON drs.database_id = dtb.database_id
LEFT OUTER JOIN sys.database_mirroring AS dmi ON dmi.database_id = dtb.database_id
LEFT OUTER JOIN #tmp_sp_db_vardecimal_storage_format as vardec ON dtb.name = vardec.dbname
LEFT OUTER JOIN sys.change_tracking_databases AS ctb ON ctb.database_id = dtb.database_id 
WHERE
(dtb.name=@_msparam_3)

            drop table #tempbackup
          


            drop table #tmp_sp_db_vardecimal_storage_format
          
,17,17,0,61,0,17
SELECT [R].[ROUTINE_SCHEMA], [R].[ROUTINE_NAME], [P].[ORDINAL_POSITION], [P].[IS_RESULT], [P].[PARAMETER_NAME],
       [P].[DATA_TYPE], [P].[PARAMETER_MODE], [P].[NUMERIC_PRECISION], [P].[NUMERIC_SCALE],
       [P].[NUMERIC_PRECISION_RADIX], [P].[DATETIME_PRECISION], [P].[CHARACTER_MAXIMUM_LENGTH]
  FROM [GewinnPortal].[INFORMATION_SCHEMA].[ROUTINES] AS [R] LEFT OUTER JOIN [GewinnPortal].[INFORMATION_SCHEMA].[PARAMETERS] AS [P]
    ON [P].[SPECIFIC_SCHEMA] = [R].[SPECIFIC_SCHEMA] AND [P].[SPECIFIC_NAME] = [R].[SPECIFIC_NAME]
 WHERE [R].[ROUTINE_TYPE] = 'PROCEDURE' AND [R].[ROUTINE_SCHEMA] <> 'SYS'
 ORDER BY [R].[ROUTINE_SCHEMA], [R].[ROUTINE_NAME], [P].ORDINAL_POSITION,15,13,2,1913,0,15
CREATE PROCEDURE sp_sqlagent_has_server_access
  @login_name         sysname = NULL,
  @is_sysadmin_member INT     = NULL OUTPUT
AS
BEGIN
  DECLARE @has_server_access BIT
  DECLARE @is_sysadmin       BIT
  DECLARE @actual_login_name sysname
  DECLARE @cachedate         DATETIME

  SET NOCOUNT ON

  SELECT @cachedate = NULL

  -- remove expired entries from the cache
  DELETE msdb.dbo.syscachedcredentials
  WHERE  DATEDIFF(MINUTE, cachedate, GETDATE()) >= 29

  -- query the cache
  SELECT  @is_sysadmin = is_sysadmin_member,
          @has_server_access = has_server_access,
          @cachedate = cachedate
  FROM    msdb.dbo.syscachedcredentials
  WHERE   login_name = @login_name
  AND     DATEDIFF(MINUTE, cachedate, GETDATE()) < 29

  IF (@cachedate IS NOT NULL)
  BEGIN
    -- no output variable
    IF (@is_sysadmin_member IS NULL)
    BEGIN
      -- Return result row
      SELECT has_server_access = @has_server_access,
             is_sysadmin       = @is_sysadmin,
             actual_login_name = @login_name
      RETURN
    END
    ELSE
    BEGIN
      SELECT @is_sysadmin_member = @is_sysadmin
      RETURN
    END
  END -- select from cache

  -- Set defaults
  SELECT @has_server_access = 0
  SELECT @is_sysadmin = 0
  SELECT @actual_login_name = FORMATMESSAGE(14205)

  IF (@login_name IS NULL)
  BEGIN
    SELECT has_server_access = 1,
           is_sysadmin       = IS_SRVROLEMEMBER(N'sysadmin'),
           actual_login_name = SUSER_SNAME()
    RETURN
  END

  IF (@login_name LIKE '%\%')
  BEGIN
    -- Handle the LocalSystem account ('NT AUTHORITY\SYSTEM') as a special case
    IF (UPPER(@login_name collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')
    BEGIN
      IF (EXISTS (SELECT *
                  FROM master.dbo.syslogins
                  WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')))
      BEGIN
        SELECT @has_server_access = hasaccess,
               @is_sysadmin = sysadmin,
               @actual_login_name = loginname
        FROM master.dbo.syslogins
        WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')
      END
      ELSE
      IF (EXISTS (SELECT *
                  FROM master.dbo.syslogins
                  WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')))
      BEGIN
        SELECT @has_server_access = hasaccess,
               @is_sysadmin = sysadmin,
               @actual_login_name = loginname
        FROM master.dbo.syslogins
        WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')
      END
    END
    ELSE
    BEGIN
      -- Check if the NT login has been explicitly denied access
      IF (EXISTS (SELECT *
                  FROM master.dbo.syslogins
                  WHERE (loginname = @login_name)
                    AND (denylogin = 1)))
      BEGIN
        SELECT @has_server_access = 0,
               @is_sysadmin = sysadmin,
               @actual_login_name = loginname
        FROM master.dbo.syslogins
        WHERE (loginname = @login_name)
      END
      ELSE
      BEGIN
        -- declare table variable for storing results
        DECLARE @xp_results TABLE
        (
        account_name      sysname      COLLATE database_default NOT NULL PRIMARY KEY,
        type              NVARCHAR(10) COLLATE database_default NOT NULL,
        privilege         NVARCHAR(10) COLLATE database_default NOT NULL,
        mapped_login_name sysname      COLLATE database_default NOT NULL,
        permission_path   sysname      COLLATE database_default NULL
        )

        -- Call xp_logininfo to determine server access
        INSERT INTO @xp_results
        EXECUTE master.dbo.xp_logininfo @login_name

        SELECT @has_server_access = CASE COUNT(*)
                                      WHEN 0 THEN 0
                                      ELSE 1
                                    END
        FROM @xp_results
        SELECT @actual_login_name = mapped_login_name,
               @is_sysadmin = CASE UPPER(privilege collate SQL_Latin1_General_CP1_CS_AS)
                                WHEN 'ADMIN' THEN 1
                                ELSE 0
                             END
        FROM @xp_results
      END
    END
      
    -- Only cache the NT logins to approximate the behavior of Sql Server and Windows (see bug 323287)
    -- update the cache only if something is found
    IF  (UPPER(@actual_login_name collate SQL_Latin1_General_CP1_CS_AS) <> '(UNKNOWN)')
    BEGIN
      -- Procedure starts its own transaction.
      BEGIN TRANSACTION;

      -- Modify database.
      -- use a try catch login to prevent any error when trying 
      -- to insert/update syscachedcredentials table
      -- no need to fail since the job owner has been validated
      BEGIN TRY      
        IF EXISTS (SELECT * FROM msdb.dbo.syscachedcredentials WITH (TABLOCKX) WHERE login_name = @login_name)
        BEGIN
          UPDATE msdb.dbo.syscachedcredentials
          SET    has_server_access = @has_server_access,
                is_sysadmin_member = @is_sysadmin,
               cachedate = GETDATE()
          WHERE  login_name = @login_name
        END
        ELSE
        BEGIN
          INSERT INTO msdb.dbo.syscachedcredentials(login_name, has_server_access, is_sysadmin_member) 
          VALUES(@login_name, @has_server_access, @is_sysadmin)
        END
        END TRY
        BEGIN CATCH
          -- If an error occurred we want to ignore it
        END CATCH

        -- The procedure must commit the transaction it started.
        COMMIT TRANSACTION;  
    END
      
  END
  ELSE
  BEGIN
    -- Standard login
    IF (EXISTS (SELECT *
                FROM master.dbo.syslogins
                WHERE (loginname = @login_name)))
    BEGIN
      SELECT @has_server_access = hasaccess,
             @is_sysadmin = sysadmin,
             @actual_login_name = loginname
      FROM master.dbo.syslogins
      WHERE (loginname = @login_name)
    END
  END

  IF (@is_sysadmin_member IS NULL)
    -- Return result row
    SELECT has_server_access = @has_server_access,
           is_sysadmin       = @is_sysadmin,
           actual_login_name = @actual_login_name
  ELSE
    -- output variable only
    SELECT @is_sysadmin_member = @is_sysadmin
END
,15,14,1,229,1,163677
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))SELECT
tbl.name AS [Name],
SCHEMA_NAME(tbl.schema_id) AS [Schema],
'Server[@Name=' + quotename(CAST(
        serverproperty(N'Servername')
       AS sysname),'''') + ']' + '/Database[@Name=' + quotename(db_name(),'''') + ']' + '/Table[@Name=' + quotename(tbl.name,'''') + ' and @Schema=' + quotename(SCHEMA_NAME(tbl.schema_id),'''') + ']' AS [Urn],
tbl.create_date AS [CreateDate],
CAST(CASE WHEN 'PS'=dsidx.type THEN 1 ELSE 0 END AS bit) AS [IsPartitioned],
CAST(
        ISNULL((SELECT distinct 1 from sys.all_columns
        WHERE object_id = tbl.object_id
        AND is_sparse = 1), 0)
       AS bit) AS [HasSparseColumn],
CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type > 1 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasNonClusteredIndex],
CAST(CASE idx.index_id WHEN 1 THEN 1 ELSE 0 END AS bit) AS [HasClusteredIndex],
CAST(case idx.index_id when 1 then case when (idx.is_primary_key + 2*idx.is_unique_constraint = 1) then 1 else 0 end else 0 end AS bit) AS [HasPrimaryClusteredIndex],
CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type = 3 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasXmlIndex],
CAST(ISNULL((select top 1 1 from sys.all_columns as clmns join sys.types as usrt on usrt.user_type_id = clmns.user_type_id where clmns.object_id = tbl.object_id and usrt.name = N'xml'), 0) AS bit) AS [HasXmlData]
FROM
sys.tables AS tbl
INNER JOIN sys.indexes AS idx ON 
        idx.object_id = tbl.object_id and (idx.index_id < @_msparam_0)
      
LEFT OUTER JOIN sys.data_spaces AS dsidx ON dsidx.data_space_id = idx.data_space_id
WHERE
(CAST(
 case 
    when tbl.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = tbl.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit)=@_msparam_1)
ORDER BY
[Schema] ASC,[Name] ASC,14,5,9,1673,0,14

------------------------------- xp_logininfo ----------------------------------

create procedure sys.xp_logininfo
	@acctname		sysname = null,				-- IN: NT login name
	@option			varchar(10) = null,			-- IN: 'all' | 'members' | null
	@privilege		varchar(10) = 'Not wanted' OUTPUT	-- OUT: 'admin' | 'user' | null
as
	set nocount on

	declare @ret		int

	-- VALIDATE PARAMETERS --
	if (@acctname is null AND (@option is not null OR (@privilege is null OR @privilege <> 'Not wanted')))
		OR ((@option is null OR @option <> 'all') AND (@privilege is null OR @privilege <> 'Not wanted'))
		OR (@option is not null and @option not in ('all', 'members'))
	begin
        raiserror(15600,-1,-1,'sys.xp_logininfo')
        return 1
	end

	-- HANDLE case where NO @acctname GIVEN --
	if (@acctname is null)
	begin
		select	'account name' = loginname,
				'type' = convert(varchar(8), case when isntuser = 1 then 'user' else 'group' end),
				'privilege' = convert(varchar(8), case when sysadmin = 1 then 'admin' else 'user' end),
				'mapped login name' = loginname,
				'permission path' = convert(sysname, null)
		from master..syslogins where isntname = 1 and hasaccess = 1
		order by 3, 1
		return @@error
	end

	-- HANDLE 'members' QUERY --
	if (@option = 'members')
	begin
		declare @priv varchar(8)
		select @priv = case when sysadmin = 1 then 'admin' else 'user' end
			from master..syslogins where isntname = 1 and loginname = @acctname and hasaccess = 1
		if @priv is not null
			select	'account name' = domain+N'\'+name,
					'type' = convert(varchar(8), case when sidtype = 1 then 'user' else 'group' end),
					'privilege' = @priv,
					'mapped login name' = domain+N'\'+name,
					'permission path' = @acctname
			from OpenRowset(NetGroupGetMembers, @acctname) order by 3, 1
		else
			select	'account name' = convert(sysname, null),
					'type' = convert(varchar(8), null),
					'privilege' = @priv,
					'mapped login name' = convert(sysname, null),
					'permission path' = convert(sysname, null)
			where 0=1	-- empty result set
		return @@error
	end

	-- CREATE TEMP TABLE AND POPULATE WITH THE REQUIRED DATA --
	CREATE TABLE #nt (name sysname collate database_default, sid varbinary(85), sidtype int)
	insert #nt select loginname, sid, isntgroup + 1 from master..syslogins
			where isntname = 1 and loginname = @acctname
	insert #nt select distinct domain+N'\'+name, sid, sidtype
			from OpenRowset(NetUserGetGroups, @acctname)
	select @ret = @@error
	if @ret <> 0
		return @ret
	-- IF ANY DENY, THEN NO ACCESS --
	if exists (select * from master..syslogins where sid in (select #nt.sid from #nt) and denylogin = 1)
		delete #nt

	-- HANDLE case where OUTPUT REQUESTED --
	if (@privilege is null OR @privilege <> 'Not wanted')
	begin
		select @privilege = case max(sysadmin)
			when 1 then 'admin'
			when 0 then 'user'
			else NULL end
		from master..syslogins where isntname = 1 and hasaccess = 1
			AND sid in (select sid from #nt)
		return @@error
	end

	-- GET NT TYPE FOR NEXT OPTIONS --
	declare @type varchar(8)
	select @type = case when get_sid('\U'+@acctname) is null then 'group' else 'user' end

	-- HANDLE 'all' QUERY --
	if (@option = 'all')
	begin
		select	'account name' = @acctname,
				'type' = @type,
				'privilege' = convert(varchar(8), case when sysadmin = 1 then 'admin' else 'user' end),
				'mapped login name' = @acctname,
				'permission path' = case when l.loginname = @acctname then NULL else l.loginname end
		from master..syslogins l join #nt n on l.isntname = 1 and l.sid = n.sid
		where l.loginname = n.name and hasaccess = 1
		order by 3, 5
		return @@error
	end

	-- HANDLE DEFAULT QUERY --
	select	TOP 1
			'account name' = @acctname,
			'type' = @type,
			'privilege' = convert(varchar(8), case when sysadmin = 1 then 'admin' else 'user' end),
			'mapped login name' = @acctname,
			'permission path' = case when l.loginname = @acctname then NULL else l.loginname end
	from master..syslogins l join #nt n on l.isntname = 1 and l.sid = n.sid
	where l.loginname = n.name and hasaccess = 1
	order by 3, 5
	return @@error
,13,13,0,88,0,145816
declare @Path nvarchar(255)
declare @Name nvarchar(255)


select @Path = N'C:'



		create table #filetmpfin (Name nvarchar(255) NOT NULL, IsFile bit NULL) 
		if(@Name is null) 
		begin 
			create table #filetmp (Name nvarchar(255) NOT NULL, depth int NOT NULL, IsFile bit NULL ) 
			insert #filetmp EXECUTE master.dbo.xp_dirtree @Path, 1, 1 
			insert #filetmpfin select Name, IsFile from #filetmp f 
			drop table #filetmp 
		end 
		if(NOT @Name is null) 
		begin 
			declare @FullName nvarchar(300) 
			if(@Path is null) 
				select @FullName = @Name 
			else
				select @FullName = @Path 	+ '\' + @Name 
			create table #filetmp2 ( Exist bit NOT NULL, IsDir bit NOT NULL, DirExist bit NULL ) 
			insert #filetmp2 EXECUTE master.dbo.xp_fileexist @FullName 
			insert #filetmpfin select @Name, 1-IsDir from #filetmp2 where Exist = 1 or IsDir = 1 drop table #filetmp2 
		end
		


SELECT
Name AS [Name],
IsFile AS [IsFile]
FROM
#filetmpfin
ORDER BY
[IsFile] ASC,[Name] ASC
drop table #filetmpfin
,13,6,7,132,0,13
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))SELECT
tbl.name AS [Name],
SCHEMA_NAME(tbl.schema_id) AS [Schema],
'Server[@Name=' + quotename(CAST(
        serverproperty(N'Servername')
       AS sysname),'''') + ']' + '/Database[@Name=' + quotename(db_name(),'''') + ']' + '/Table[@Name=' + quotename(tbl.name,'''') + ' and @Schema=' + quotename(SCHEMA_NAME(tbl.schema_id),'''') + ']' AS [Urn],
tbl.create_date AS [CreateDate],
CAST(CASE WHEN 'PS'=dsidx.type THEN 1 ELSE 0 END AS bit) AS [IsPartitioned],
CAST(
        ISNULL((SELECT distinct 1 from sys.all_columns
        WHERE object_id = tbl.object_id
        AND is_sparse = 1), 0)
       AS bit) AS [HasSparseColumn],
CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type > 1 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasNonClusteredIndex],
CAST(CASE idx.index_id WHEN 1 THEN 1 ELSE 0 END AS bit) AS [HasClusteredIndex],
CAST(case idx.index_id when 1 then case when (idx.is_primary_key + 2*idx.is_unique_constraint = 1) then 1 else 0 end else 0 end AS bit) AS [HasPrimaryClusteredIndex],
CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type = 3 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasXmlIndex],
CAST(ISNULL((select top 1 1 from sys.all_columns as clmns join sys.types as usrt on usrt.user_type_id = clmns.user_type_id where clmns.object_id = tbl.object_id and usrt.name = N'xml'), 0) AS bit) AS [HasXmlData]
FROM
sys.tables AS tbl
INNER JOIN sys.indexes AS idx ON 
        idx.object_id = tbl.object_id and (idx.index_id < @_msparam_0)
      
LEFT OUTER JOIN sys.data_spaces AS dsidx ON dsidx.data_space_id = idx.data_space_id
WHERE
(CAST(
 case 
    when tbl.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = tbl.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit)=@_msparam_1)
ORDER BY
[Schema] ASC,[Name] ASC,12,2,10,989,0,12
CREATE   PROCEDURE sp_delete_backuphistory
  @oldest_date datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @backup_set_id TABLE      (backup_set_id INT)
  DECLARE @media_set_id TABLE       (media_set_id INT)
  DECLARE @restore_history_id TABLE (restore_history_id INT)

  INSERT INTO @backup_set_id (backup_set_id)
  SELECT DISTINCT backup_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @media_set_id (media_set_id)
  SELECT DISTINCT media_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @restore_history_id (restore_history_id)
  SELECT DISTINCT restore_history_id
  FROM msdb.dbo.restorehistory
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)

  BEGIN TRANSACTION

  DELETE FROM msdb.dbo.backupfile
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupfilegroup
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefile
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefilegroup
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorehistory
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupset
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediafamily
  FROM msdb.dbo.backupmediafamily bmf
  WHERE bmf.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bmf.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediaset
  FROM msdb.dbo.backupmediaset bms
  WHERE bms.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bms.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  COMMIT TRANSACTION
  RETURN

Quit:
  ROLLBACK TRANSACTION

END
,12,11,1,3893,83,12
(@P1 int)SELECT item.collection_item_id As item_id, item.frequency, item.parameters,       type.collection_package_path, type.upload_package_path, type.collector_type_uid FROM   [dbo].[syscollector_collection_sets] s, [dbo].[syscollector_collection_items] item,        [dbo].[syscollector_collector_types] type WHERE  s.collection_set_id = item.collection_set_id AND	 item.collector_type_uid = type.collector_type_uid AND	 s.collection_set_id = @P1,12,8,4,135,0,12
select ic.AssignmentID,ic.Assignment,ic.Description,ic.FuncObjID,ic.BUID,ic.CompanyID,ic.PeriodID,ic.UpdateDate,ic.UpdateBy,ic.CreateDate,ic.CreateBy, 
                            (-1) as ParentID  from ICP_Assignment ic
                        inner join GewinnPortal.dbo.Obj_Function obj
                        on obj.FuncObjID = ic.FuncObjID

                        where ic.PeriodID = 16 and obj.IsDelete = 0 order by ic.FuncObjID,11,1,10,53,0,23
SELECT [R].[ROUTINE_SCHEMA], [R].[ROUTINE_NAME], [P].[ORDINAL_POSITION], [P].[IS_RESULT], [P].[PARAMETER_NAME],
       [P].[DATA_TYPE], [P].[PARAMETER_MODE], [P].[NUMERIC_PRECISION], [P].[NUMERIC_SCALE],
       [P].[NUMERIC_PRECISION_RADIX], [P].[DATETIME_PRECISION], [P].[CHARACTER_MAXIMUM_LENGTH]
  FROM [GewinnGRMS].[INFORMATION_SCHEMA].[ROUTINES] AS [R] LEFT OUTER JOIN [GewinnGRMS].[INFORMATION_SCHEMA].[PARAMETERS] AS [P]
    ON [P].[SPECIFIC_SCHEMA] = [R].[SPECIFIC_SCHEMA] AND [P].[SPECIFIC_NAME] = [R].[SPECIFIC_NAME]
 WHERE [R].[ROUTINE_TYPE] = 'PROCEDURE' AND [R].[ROUTINE_SCHEMA] <> 'SYS'
 ORDER BY [R].[ROUTINE_SCHEMA], [R].[ROUTINE_NAME], [P].ORDINAL_POSITION,11,10,1,1745,0,11
CREATE   PROCEDURE sp_delete_backuphistory
  @oldest_date datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @backup_set_id TABLE      (backup_set_id INT)
  DECLARE @media_set_id TABLE       (media_set_id INT)
  DECLARE @restore_history_id TABLE (restore_history_id INT)

  INSERT INTO @backup_set_id (backup_set_id)
  SELECT DISTINCT backup_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @media_set_id (media_set_id)
  SELECT DISTINCT media_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @restore_history_id (restore_history_id)
  SELECT DISTINCT restore_history_id
  FROM msdb.dbo.restorehistory
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)

  BEGIN TRANSACTION

  DELETE FROM msdb.dbo.backupfile
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupfilegroup
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefile
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefilegroup
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorehistory
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupset
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediafamily
  FROM msdb.dbo.backupmediafamily bmf
  WHERE bmf.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bmf.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediaset
  FROM msdb.dbo.backupmediaset bms
  WHERE bms.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bms.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  COMMIT TRANSACTION
  RETURN

Quit:
  ROLLBACK TRANSACTION

END
,11,10,1,3389,62,11

CREATE PROCEDURE dbo.sp_verify_subsystems
   @syssubsytems_refresh_needed BIT = 0
AS
BEGIN
  SET NOCOUNT ON
   
  DECLARE @retval         INT
  DECLARE @InstRootPath nvarchar(512)
  DECLARE @VersionRootPath nvarchar(512)
  DECLARE @ComRootPath nvarchar(512)
  DECLARE @DtsRootPath nvarchar(512)
  DECLARE @SQLPSPath nvarchar(512)
  DECLARE @DTExec nvarchar(512)
  DECLARE @DTExecExists INT
  DECLARE @ToolsPath nvarchar(512)

  IF ( (@syssubsytems_refresh_needed=1) OR (NOT EXISTS(select * from syssubsystems)) )
  BEGIN
     EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\Setup', N'SQLPath', @InstRootPath OUTPUT
     IF @InstRootPath IS NULL
     BEGIN
       RAISERROR(14658, -1, -1) WITH LOG
       RETURN (1)
     END
     SELECT @InstRootPath = @InstRootPath + N'\binn\'

     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\Microsoft Sql Server\100', N'VerSpecificRootDir', @VersionRootPath OUTPUT
     IF @VersionRootPath IS NULL
     BEGIN
       RAISERROR(14659, -1, -1) WITH LOG
       RETURN(1)
     END

     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\Microsoft SQL Server\100\SSIS\Setup\DTSPath', N'', @DtsRootPath OUTPUT, N'no_output'
     IF (@DtsRootPath IS NOT NULL)
     BEGIN
       SELECT @DtsRootPath  = @DtsRootPath  + N'Binn\'
       SELECT @DTExec = @DtsRootPath + N'DTExec.exe'
       CREATE TABLE #t (file_exists int, is_directory int, parent_directory_exists int)
       INSERT #t EXEC xp_fileexist @DTExec
       SELECT TOP 1 @DTExecExists=file_exists from #t
       DROP TABLE #t
       IF ((@DTExecExists IS NULL) OR (@DTExecExists = 0))
         SET @DtsRootPath = NULL
     END

     SELECT @ComRootPath  = @VersionRootPath  + N'COM\'

     create table #Platform(ID int,  Name  sysname, Internal_Value int NULL, Value nvarchar(512))
     insert #Platform exec master.dbo.xp_msver 'Platform'
     if EXISTS(select * from #Platform where Value like '%64%')
     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Wow6432Node\Microsoft\Microsoft Sql Server\100\Tools\ClientSetup', N'SQLPath', @ToolsPath OUTPUT
  else
     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\Microsoft Sql Server\100\Tools\ClientSetup', N'SQLPath', @ToolsPath OUTPUT
     drop table #Platform
     SELECT @SQLPSPath  = @ToolsPath  + N'\Binn\SQLPS.exe'
     
     -- Procedure must start its own transaction if we don't have one already.
     DECLARE @TranCounter INT;
     SET @TranCounter = @@TRANCOUNT;
     IF @TranCounter = 0
     BEGIN
        BEGIN TRANSACTION;
     END

     -- Obtain processor count to determine maximum number of threads per subsystem
     DECLARE @xp_results TABLE
     (
     id              INT           NOT NULL,
     name            NVARCHAR(30)  COLLATE database_default NOT NULL,
     internal_value  INT           NULL,
     character_value NVARCHAR(212) COLLATE database_default NULL
     )
     INSERT INTO @xp_results
     EXECUTE master.dbo.xp_msver

     DECLARE @processor_count INT
     SELECT @processor_count = internal_value from @xp_results where id=16 -- ProcessorCount

     -- Modify database.
     BEGIN TRY

       --create subsystems
       --TSQL subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'TSQL')
       INSERT syssubsystems
       VALUES
       (
          1, N'TSQL',14556, FORMATMESSAGE(14557), FORMATMESSAGE(14557), FORMATMESSAGE(14557), FORMATMESSAGE(14557), FORMATMESSAGE(14557), 20 * @processor_count
       )
       --ActiveScripting subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'ActiveScripting')
       INSERT syssubsystems
       VALUES
       (
          2, N'ActiveScripting',  14555, @InstRootPath + N'SQLATXSS.DLL',NULL,N'ActiveScriptStart',N'ActiveScriptEvent',N'ActiveScriptStop', 10 * @processor_count
       )

       --CmdExec subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'CmdExec')
       INSERT syssubsystems
       VALUES
       (
          3, N'CmdExec', 14550, @InstRootPath + N'SQLCMDSS.DLL',NULL,N'CmdExecStart',N'CmdEvent',N'CmdExecStop', 10 * @processor_count
       )

       --Snapshot subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'Snapshot')
       INSERT syssubsystems
       VALUES
       (
          4, N'Snapshot',   14551, @InstRootPath + N'SQLREPSS.DLL', @ComRootPath + N'SNAPSHOT.EXE', N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --LogReader subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'LogReader')
       INSERT syssubsystems
       VALUES
       (
          5, N'LogReader',  14552, @InstRootPath + N'SQLREPSS.DLL', @ComRootPath + N'logread.exe',N'ReplStart',N'ReplEvent',N'ReplStop',25 * @processor_count
       )

       --Distribution subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'Distribution')
       INSERT syssubsystems
       VALUES
       (
          6, N'Distribution',  14553, @InstRootPath + N'SQLREPSS.DLL', @ComRootPath + N'DISTRIB.EXE',N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --Merge subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'Merge')
       INSERT syssubsystems
       VALUES
       (
          7, N'Merge',   14554, @InstRootPath + N'SQLREPSS.DLL',@ComRootPath + N'REPLMERG.EXE',N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --QueueReader subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'QueueReader')
       INSERT syssubsystems
       VALUES
       (
          8, N'QueueReader',   14581, @InstRootPath + N'SQLREPSS.dll',@ComRootPath + N'qrdrsvc.exe',N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --ANALYSISQUERY subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'ANALYSISQUERY')
       INSERT syssubsystems
       VALUES
       (
          9, N'ANALYSISQUERY', 14513, @InstRootPath + N'SQLOLAPSS.DLL',NULL,N'OlapStart',N'OlapQueryEvent',N'OlapStop',100 * @processor_count
       )

       --ANALYSISCOMMAND subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'ANALYSISCOMMAND')
       INSERT syssubsystems
       VALUES
       (
          10, N'ANALYSISCOMMAND', 14514, @InstRootPath + N'SQLOLAPSS.DLL',NULL,N'OlapStart',N'OlapCommandEvent',N'OlapStop',100 * @processor_count
       )

       IF(@DtsRootPath IS NOT NULL)
       BEGIN
          --DTS subsystem
          IF (NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'SSIS') )
             INSERT syssubsystems
             VALUES
             (
                11, N'SSIS', 14538, @InstRootPath + N'SQLDTSSS.DLL',@DtsRootPath + N'DTExec.exe',N'DtsStart',N'DtsEvent',N'DtsStop',100 * @processor_count
             )
          ELSE
             UPDATE syssubsystems SET agent_exe = @DtsRootPath + N'DTExec.exe' WHERE subsystem = N'SSIS'
       END
       ELSE
       BEGIN
          IF EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'SSIS')
            DELETE FROM syssubsystems WHERE subsystem = N'SSIS' 
       END
       
       --PowerShell subsystem     
	   IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'PowerShell')
	   INSERT syssubsystems
	   VALUES
	   (
		  12, N'PowerShell', 14698, @InstRootPath + N'SQLPOWERSHELLSS.DLL', @SQLPSPath, N'PowerShellStart',N'PowerShellEvent',N'PowerShellStop',2
	   )
	   

   END TRY
   BEGIN CATCH

       DECLARE @ErrorMessage NVARCHAR(400)
       DECLARE @ErrorSeverity INT
       DECLARE @ErrorState INT

       SELECT @ErrorMessage = ERROR_MESSAGE()
       SELECT @ErrorSeverity = ERROR_SEVERITY()
       SELECT @ErrorState = ERROR_STATE()

       -- Roll back the transaction that we started if we are not nested
       IF @TranCounter = 0
       BEGIN
         ROLLBACK TRANSACTION;
       END
       -- if we are nested inside another transaction just raise the 
       -- error and let the outer transaction do the rollback
       RAISERROR (@ErrorMessage, -- Message text.
                   @ErrorSeverity, -- Severity.
                   @ErrorState -- State.
                   )
       RETURN (1)                  
     END CATCH
  END --(NOT EXISTS(select * from syssubsystems))
  
  -- commit the transaction we started
  IF @TranCounter = 0
  BEGIN
    COMMIT TRANSACTION;
  END
  
  RETURN(0) -- Success
END
,10,8,2,50,4,10
SELECT BUID, BUName AS BUName, BUTypeID, ParentID FROM Hrcy_BusinessUnit WHERE PeriodID = '31' AND CompanyID = '1' AND IsDelete=0 ORDER BY BUName,10,1,9,68,0,21
(@_msparam_0 nvarchar(4000))SELECT
bkps.name AS [Name],
bkps.backup_set_id AS [ID],
bkps.backup_set_uuid AS [BackupSetUuid],
bkps.media_set_id AS [MediaSetId],
bkps.first_family_number AS [FirstFamilyNumber],
bkps.first_media_number AS [FirstMediaNumber],
bkps.last_family_number AS [LastFamilyNumber],
bkps.last_media_number AS [LastMediaNumber],
bkps.catalog_family_number AS [CatalogFamilyNumber],
bkps.catalog_media_number AS [CatalogMediaNumber],
bkps.position AS [Position],
bkps.expiration_date AS [ExpirationDate],
bkps.software_vendor_id AS [SoftwareVendorId],
bkps.description AS [Description],
bkps.user_name AS [UserName],
bkps.software_major_version AS [SoftwareMajorVersion],
bkps.software_minor_version AS [SoftwareMinorVersion],
bkps.software_build_version AS [SoftwareBuildVersion],
bkps.time_zone AS [TimeZone],
bkps.mtf_minor_version AS [MtfMinorVersion],
bkps.first_lsn AS [FirstLsn],
bkps.last_lsn AS [LastLsn],
bkps.checkpoint_lsn AS [CheckpointLsn],
bkps.database_backup_lsn AS [DatabaseBackupLsn],
bkps.database_creation_date AS [DatabaseCreationDate],
bkps.backup_start_date AS [BackupStartDate],
bkps.backup_finish_date AS [BackupFinishDate],
CASE bkps.type WHEN 'D' THEN 1 WHEN 'I' THEN 2 WHEN 'L' THEN 3 WHEN 'F' THEN 4 END AS [BackupSetType],
bkps.sort_order AS [SortOrder],
bkps.code_page AS [CodePage],
bkps.compatibility_level AS [CompatibilityLevel],
bkps.database_version AS [DatabaseVersion],
bkps.backup_size AS [BackupSize],
bkps.database_name AS [DatabaseName],
bkps.server_name AS [ServerName],
bkps.machine_name AS [MachineName],
bkps.flags AS [BackupSetFlags],
bkps.unicode_locale AS [UnicodeLocale],
bkps.unicode_compare_style AS [UnicodeCompareStyle],
bkps.collation_name AS [CollationName],
bkps.is_password_protected AS [IsPasswordProtected],
bkps.compressed_backup_size AS [CompressedBackupSize]
FROM
msdb.dbo.backupset bkps
WHERE
(bkps.database_name=@_msparam_0)
ORDER BY
[BackupFinishDate] DESC,10,9,1,179,0,52
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000))
            create table #tempbackup (database_name nvarchar(128), [type] char(1), backup_finish_date datetime)
            insert into #tempbackup select database_name, [type], max(backup_finish_date) from msdb..backupset where [type] = 'D' or [type] = 'L' or [type]='I' group by database_name, [type]
          


                create table #tmp_sp_db_vardecimal_storage_format (dbname sysname null, vardecimal_enabled varchar(3) null)
                if exists (select o.object_id from sys.system_objects o where o.name=N'sp_db_vardecimal_storage_format')
                begin
                insert into #tmp_sp_db_vardecimal_storage_format exec sys.sp_db_vardecimal_storage_format
                end
            


        DECLARE @is_policy_automation_enabled bit
        SET @is_policy_automation_enabled  = (SELECT CONVERT(bit, current_value)
                                              FROM msdb.dbo.syspolicy_configuration
                                              WHERE name = 'Enabled')
      


SELECT
dtb.name AS [Name],
(select count(*) from master.dbo.sysprocesses p where dtb.database_id=p.dbid) AS [ActiveConnections],
dtb.is_auto_close_on AS [AutoClose],
dtb.is_auto_shrink_on AS [AutoShrink],
dtb.compatibility_level AS [CompatibilityLevel],
dtb.create_date AS [CreateDate],
CAST(0 AS float) AS [DataSpaceUsage],
CAST(0 AS bit) AS [DboLogin],
N'' AS [DefaultFileGroup],
'' AS [DefaultSchema],
dtb.database_id AS [ID],
CAST(0 AS float) AS [IndexSpaceUsage],
CAST(has_dbaccess(dtb.name) AS bit) AS [IsAccessible],
CAST(0 AS bit) AS [IsDbAccessAdmin],
CAST(0 AS bit) AS [IsDbBackupOperator],
CAST(0 AS bit) AS [IsDbDatareader],
CAST(0 AS bit) AS [IsDbDatawriter],
CAST(0 AS bit) AS [IsDbDdlAdmin],
CAST(0 AS bit) AS [IsDbDenyDatareader],
CAST(0 AS bit) AS [IsDbDenyDatawriter],
CAST(0 AS bit) AS [IsDbOwner],
CAST(0 AS bit) AS [IsDbSecurityAdmin],
dtb.is_fulltext_enabled AS [IsFullTextEnabled],
CAST(case when dtb.name in ('master','model','msdb','tempdb') then 1 else dtb.is_distributor end AS bit) AS [IsSystemObject],
(select backup_finish_date from #tempbackup where type = @_msparam_0 and database_name = dtb.name) AS [LastBackupDate],
(select backup_finish_date from #tempbackup where type = @_msparam_1 and database_name = dtb.name) AS [LastDifferentialBackupDate],
(select backup_finish_date from #tempbackup where type = @_msparam_2 and database_name = dtb.name) AS [LastLogBackupDate],
suser_sname(dtb.owner_sid) AS [Owner],
df.physical_name AS [PrimaryFilePath],
(dtb.is_published*1+dtb.is_subscribed*2+dtb.is_merge_published*4) AS [ReplicationOptions],
CAST(0 AS float) AS [Size],
CAST(0 AS float) AS [SpaceAvailable],

            case
            when dtb.collation_name is null then 0x200
            else 0
            end |
            case
            when 1 = dtb.is_in_standby then 0x40
            else 0
            end |
            case dtb.state
            when 1 then 0x2
            when 2 then 0x8
            when 3 then 0x4
            when 4 then 0x10
            when 5 then 0x100
            when 6 then 0x20
            else 1
            end
           AS [Status],
'' AS [UserName],
dtb.is_ansi_null_default_on AS [AnsiNullDefault],
dtb.is_ansi_nulls_on AS [AnsiNullsEnabled],
dtb.is_ansi_padding_on AS [AnsiPaddingEnabled],
dtb.is_ansi_warnings_on AS [AnsiWarningsEnabled],
dtb.is_arithabort_on AS [ArithmeticAbortEnabled],
dtb.is_auto_create_stats_on AS [AutoCreateStatisticsEnabled],
dtb.is_auto_update_stats_on AS [AutoUpdateStatisticsEnabled],
CAST(CHARINDEX(N'_CS_', dtb.collation_name) AS bit) AS [CaseSensitive],
dtb.is_cursor_close_on_commit_on AS [CloseCursorsOnCommitEnabled],
dtb.collation_name AS [Collation],
dtb.is_concat_null_yields_null_on AS [ConcatenateNullYieldsNull],
dtb.is_db_chaining_on AS [DatabaseOwnershipChaining],
CAST(( case LOWER(convert( nvarchar(128), DATABASEPROPERTYEX(dtb.name, 'Updateability'))) when 'read_write' then 1 else 0 end) AS bit) AS [IsUpdateable],
dtb.is_local_cursor_default AS [LocalCursorsDefault],
dtb.is_numeric_roundabort_on AS [NumericRoundAbortEnabled],
dtb.page_verify_option AS [PageVerify],
dtb.is_quoted_identifier_on AS [QuotedIdentifiersEnabled],
dtb.is_read_only AS [ReadOnly],
dtb.recovery_model AS [RecoveryModel],
dtb.is_recursive_triggers_on AS [RecursiveTriggersEnabled],
dtb.user_access AS [UserAccess],
CAST(DATABASEPROPERTYEX(dtb.name, 'Version') AS int) AS [Version],
dtb.is_auto_update_stats_async_on AS [AutoUpdateStatisticsAsync],
dtb.is_broker_enabled AS [BrokerEnabled],
drs.database_guid AS [DatabaseGuid],
ISNULL(DB_NAME(dtb.source_database_id), N'') AS [DatabaseSnapshotBaseName],
dtb.is_date_correlation_on AS [DateCorrelationOptimization],
ISNULL((select top 1 ftc.name from sys.fulltext_catalogs as ftc where ftc.is_default=1),N'') AS [DefaultFullTextCatalog],
CAST(isnull(dtb.source_database_id, 0) AS bit) AS [IsDatabaseSnapshot],
CAST((select count(1) from sys.databases dtbmir where dtbmir.source_database_id = dtb.database_id) AS bit) AS [IsDatabaseSnapshotBase],
0 AS [IsMailHost],
CAST(case when dmi.mirroring_partner_name is null then 0 else 1 end AS bit) AS [IsMirroringEnabled],
dtb.is_parameterization_forced AS [IsParameterizationForced],
dtb.is_read_committed_snapshot_on AS [IsReadCommittedSnapshotOn],

                case
                when vardec.vardecimal_enabled = 'ON' then cast(1 as bit)
                else cast(0 as bit)
                end
             AS [IsVarDecimalStorageFormatEnabled],
ISNULL(dtb.log_reuse_wait,0) AS [LogReuseWaitStatus],
ISNULL(dmi.mirroring_failover_lsn,0) AS [MirroringFailoverLogSequenceNumber],
ISNULL(dmi.mirroring_guid,'00000000-0000-0000-0000-0000000000000000') AS [MirroringID],
ISNULL(dmi.mirroring_partner_name,'') AS [MirroringPartner],
ISNULL(dmi.mirroring_partner_instance,'') AS [MirroringPartnerInstance],
ISNULL((case dmi.mirroring_redo_queue_type when N'UNLIMITED' then 0 else dmi.mirroring_redo_queue end),0) AS [MirroringRedoQueueMaxSize],
ISNULL(dmi.mirroring_role,0) AS [MirroringRole],
ISNULL(dmi.mirroring_role_sequence,0) AS [MirroringRoleSequence],
ISNULL(dmi.mirroring_safety_level + 1, 0) AS [MirroringSafetyLevel],
ISNULL(dmi.mirroring_safety_sequence,0) AS [MirroringSafetySequence],
ISNULL(dmi.mirroring_state + 1, 0) AS [MirroringStatus],
ISNULL(dmi.mirroring_connection_timeout,0) AS [MirroringTimeout],
ISNULL(dmi.mirroring_witness_name,'') AS [MirroringWitness],
ISNULL(dmi.mirroring_witness_state + 1, 0) AS [MirroringWitnessStatus],
drs.recovery_fork_guid AS [RecoveryForkGuid],
dtb.service_broker_guid AS [ServiceBrokerGuid],
dtb.snapshot_isolation_state AS [SnapshotIsolationState],
dtb.is_trustworthy_on AS [Trustworthy],
CAST(ISNULL(ctb.is_auto_cleanup_on,0) AS bit) AS [ChangeTrackingAutoCleanUp],
CAST(case when ctb.database_id is null then 0 else 1  end AS bit) AS [ChangeTrackingEnabled],
ISNULL(ctb.retention_period,0) AS [ChangeTrackingRetentionPeriod],
CAST(ISNULL(ctb.retention_period_units,0) AS tinyint) AS [ChangeTrackingRetentionPeriodUnits],
N'' AS [DefaultFileStreamFileGroup],
CAST(dtb.is_encrypted AS bit) AS [EncryptionEnabled],
CAST(dtb.is_honor_broker_priority_on AS bit) AS [HonorBrokerPriority],
CAST(0 AS bit) AS [IsManagementDataWarehouse],
case when 1=@is_policy_automation_enabled and exists (select * from msdb.dbo.syspolicy_system_health_state where target_query_expression_with_id like 'Server'+ '/Database\[@ID=' + convert(nvarchar(20),dtb.database_id) + '\]%' ESCAPE '\') then 1 else 0 end AS [PolicyHealthState],
dtb.name AS [DatabaseName],
dtb.name AS [DatabaseName2]
FROM
master.sys.databases AS dtb
LEFT OUTER JOIN sys.master_files AS df ON df.database_id = dtb.database_id and 1=df.data_space_id and 1 = df.file_id
LEFT OUTER JOIN sys.database_recovery_status AS drs ON drs.database_id = dtb.database_id
LEFT OUTER JOIN sys.database_mirroring AS dmi ON dmi.database_id = dtb.database_id
LEFT OUTER JOIN #tmp_sp_db_vardecimal_storage_format as vardec ON dtb.name = vardec.dbname
LEFT OUTER JOIN sys.change_tracking_databases AS ctb ON ctb.database_id = dtb.database_id 
WHERE
(dtb.name=@_msparam_3)

            drop table #tempbackup
          


            drop table #tmp_sp_db_vardecimal_storage_format
          
,10,9,1,205,0,10

CREATE PROCEDURE [dbo].[sp_syscollector_event_oncollectionbegin]
    @collection_set_id int,
    @mode smallint = NULL,
    @operator nvarchar(128) = NULL,
    @log_id bigint OUTPUT
AS
BEGIN
    SET NOCOUNT ON

    -- Security check (role membership)
    IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))
    BEGIN
        RAISERROR(14677, -1, -1, 'dc_proxy')
        RETURN(1) -- Failure
    END

    -- Verify parameters
    --

    -- Check the collection_set_id
    IF (@collection_set_id IS NULL)
    BEGIN
        RAISERROR(14606, -1, -1, '@collection_set_id')
        RETURN (1)
    END
    ELSE IF (NOT EXISTS (SELECT collection_set_id FROM dbo.syscollector_collection_sets WHERE collection_set_id = @collection_set_id))
    BEGIN
        DECLARE @collection_set_id_as_char VARCHAR(36)
        SELECT @collection_set_id_as_char = CONVERT(VARCHAR(36), @collection_set_id)

        RAISERROR(14262, -1, -1, '@collection_set_id', @collection_set_id_as_char)
        RETURN (1)
    END


    -- Default operator to currently logged in user
    SET @operator = NULLIF(LTRIM(RTRIM(@operator)), '')
    SET @operator = ISNULL(@operator, suser_sname())

    -- Default mode to Collection
    SET @mode = ISNULL(@mode, 0)

    -- Find the parent log id.
    -- It will be a log entry for the same collection set, with no parent and not finished
    DECLARE @parent_log_id bigint
    SELECT TOP 1 @parent_log_id = log_id FROM dbo.syscollector_execution_log_internal 
        WHERE collection_set_id = @collection_set_id 
        AND parent_log_id IS NULL
        AND (@mode = 1 OR finish_time IS NULL)
        ORDER BY start_time DESC

    -- Insert the log record
    --
    INSERT INTO dbo.syscollector_execution_log_internal (
        parent_log_id, 
        collection_set_id, 
        collection_item_id,
        start_time,
        last_iteration_time,
        finish_time,
        runtime_execution_mode,
        [status],
        operator,
        package_id,
        package_execution_id,
        failure_message
    ) VALUES (
        @parent_log_id,
        @collection_set_id,
        NULL,
        GETDATE(),
        NULL,
        NULL,
        @mode,
        0, -- Running
        @operator,
        NULL,
        NULL,
        NULL
    )

    SET @log_id = SCOPE_IDENTITY()                
    
    RETURN (0)
END
,10,9,1,3971,0,3872
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(v.schema_id) AS [Schema],
v.name AS [Name],
v.object_id AS [ID]
FROM
sys.all_views AS v
WHERE
(v.type = @_msparam_0)
ORDER BY
[Schema] ASC,[Name] ASC,9,2,7,33,0,9
SELECT Table1.FuncObjID, Table1.PeriodID, Table1.CompanyID, Table1.FuncObjCode, Table1.FuncObj, Table1.FuncObjDesc, Table1.BUID, Table1.BUName, 
                Table1.BUTypeID, Table1.Remark, Table1.IsDelete, Table1.ParentID, Table2.UserID, Table2.PeriodID AS Expr1, Table2.CompanyID AS Expr2, Table2.BUID AS Expr3, 
                Table2.PerspectiveID, Table2.SWCode, Table2.canAccess, Table2.canModify, Table2.canDelete, Table2.ParentID AS Expr4, Table2.BUTypeID AS Expr5, 
                Table2.BUName AS Expr6
            FROM (SELECT A.FuncObjID, A.PeriodID, A.CompanyID, A.FuncObjCode, A.FuncObj, A.FuncObjDesc, A.BUID, B.BUName, B.BUTypeID, A.Remark, A.IsDelete, - 1 AS ParentID
                    FROM Obj_Function AS A LEFT OUTER JOIN
                    Hrcy_BusinessUnit AS B ON A.BUID = B.BUID AND A.PeriodID = B.PeriodID AND A.CompanyID = B.CompanyID
                    WHERE (A.PeriodID = 16) AND (A.CompanyID = 1) AND (B.BUTypeID <> 5) AND (A.IsDelete = 0)) AS Table1 INNER JOIN
                        (SELECT A.UserID, A.PeriodID, A.CompanyID, A.BUID, A.PerspectiveID, A.SWCode, A.canAccess, A.canModify, A.canDelete, B.ParentID, B.BUTypeID, B.BUName
                            FROM Hrcy_BusinessUnit AS B LEFT OUTER JOIN
                                Auth_Apps AS A ON A.BUID = B.BUID AND A.PeriodID = B.PeriodID AND A.CompanyID = B.CompanyID
                            WHERE (A.UserID = 1) AND (A.PeriodID = 16) AND (A.CompanyID = 1) AND (A.SWCode = 'IC05') AND (A.canAccess = '1') AND (B.IsDelete = 0)) AS Table2 ON 
                            Table1.BUID = Table2.BUID,9,4,5,1340,0,18

            Select A.FuncObjID, A.PeriodID, A.CompanyID, A.FuncObjCode, A.FuncObj, A.FuncObjDesc, A.BUID, B.BUName, A.Remark, A.IsDelete, (-1) AS ParentID 
            From Obj_Function A LEFT OUTER JOIN Hrcy_BusinessUnit B ON A.BUID = B.BUID AND A.PeriodID = B.PeriodID AND A.CompanyID = B.CompanyID
            WHERE A.PeriodID = 16 AND A.CompanyID = 1 AND B.BUTypeID <> 5 AND A.IsDelete = 0,9,3,6,959,0,18
SELECT
dtb.name AS [Name],
dtb.database_id AS [ID],
CAST(case when dtb.name in ('master','model','msdb','tempdb') then 1 else dtb.is_distributor end AS bit) AS [IsSystemObject],
dtb.collation_name AS [Collation],
CAST(has_dbaccess(dtb.name) AS bit) AS [IsAccessible],
dtb.name AS [DatabaseName2]
FROM
master.sys.databases AS dtb
ORDER BY
[Name] ASC,9,2,7,192,0,9
SELECT
    DB_NAME (database_id) as [Database Name],
    name as [Database File Name],
    [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'
            WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'
            ELSE Type_Desc END,
    size*8/1024 as 'Size (MB)',
    physical_name as [Database_File_Location]
FROM sys.master_files
ORDER BY 1,3

IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL
    DROP TABLE #space

CREATE TABLE #space (
      database_id INT PRIMARY KEY
    , data_used_size DECIMAL(18,2)
    , log_used_size DECIMAL(18,2)
)

DECLARE @SQL NVARCHAR(MAX)

SELECT @SQL = STUFF((
    SELECT '
    USE [' + d.name + ']
    INSERT INTO #space (database_id, data_used_size, log_used_size)
    SELECT
          DB_ID()
        , SUM(CASE WHEN [type] = 0 THEN space_used END)
        , SUM(CASE WHEN [type] = 1 THEN space_used END)
    FROM (
        SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)
        FROM sys.database_files s
        GROUP BY s.[type]
    ) t;'
    FROM sys.databases d
    WHERE d.[state] = 0
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')

EXEC sys.sp_executesql @SQL

SELECT
      d.database_id
    , d.name
    , d.state_desc
    , d.recovery_model_desc
    , t.total_size
    , t.data_size
    , s.data_used_size
    , t.log_size
    , s.log_used_size
    , bu.full_last_date
    , bu.full_size
    , bu.log_last_date
    , bu.log_size
FROM (
    SELECT
          database_id
        , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))
    FROM sys.master_files
    GROUP BY database_id
) t
JOIN sys.databases d ON d.database_id = t.database_id
LEFT JOIN #space s ON d.database_id = s.database_id
LEFT JOIN (
    SELECT
          database_name
        , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)
        , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)
        , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)
        , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)
    FROM (
        SELECT
              s.database_name
            , s.[type]
            , s.backup_finish_date
            , backup_size =
                        CAST(CASE WHEN s.backup_size = s.compressed_backup_size
                                    THEN s.backup_size
                                    ELSE s.compressed_backup_size
                        END / 1048576.0 AS DECIMAL(18,2))
            , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)
        FROM msdb.dbo.backupset s
        WHERE s.[type] IN ('D', 'L')
    ) f
    WHERE f.RowNum = 1
    GROUP BY f.database_name
) bu ON d.name = bu.database_name
ORDER BY t.total_size DESC

SELECT 
    req.session_id
    , req.total_elapsed_time AS duration_ms
    , req.cpu_time AS cpu_time_ms
    , req.total_elapsed_time - req.cpu_time AS wait_time
    , req.logical_reads
    , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1, 
       ((CASE statement_end_offset
           WHEN -1
           THEN DATALENGTH(ST.text)  
           ELSE req.statement_end_offset
         END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '), 
      1, 512)  AS statement_text  
FROM sys.dm_exec_requests AS req
    CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST
ORDER BY total_elapsed_time DESC;

SELECT top 100 t.text,
     (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,
     (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,
     ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,
     qs.total_logical_reads / qs.execution_count AS avg_logical_reads,
     qs.total_logical_writes / qs.execution_count AS avg_writes,
     (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions
FROM sys.dm_exec_query_stats qs
     CROSS apply sys.Dm_exec_sql_text (sql_handle) t
-- WHERE t.text like '<Your Query>%'
-- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped.
ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC

--Deadlock sql check
SELECT
    session_id,
    start_time, 
    [status],
    command,
    blocking_session_id,
    wait_type,
    wait_time,
    open_transaction_count,
    transaction_id,
    total_elapsed_time,
    Definition = CAST(text AS VARCHAR(MAX))
FROM
    SYS.DM_EXEC_REQUESTS
    CROSS APPLY sys.dm_exec_sql_text(sql_handle) 
WHERE blocking_session_id != 0


,8,8,0,253,0,8
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT
param.is_readonly AS [IsReadOnly],
param.name AS [Name],
param.parameter_id AS [ID],
param.default_value AS [DefaultValue],
param.has_default_value AS [HasDefaultValue],
usrt.name AS [DataType],
s1param.name AS [DataTypeSchema],
ISNULL(baset.name, N'') AS [SystemType],
CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND param.max_length <> -1 THEN param.max_length/2 ELSE param.max_length END AS int) AS [Length],
CAST(param.precision AS int) AS [NumericPrecision],
CAST(param.scale AS int) AS [NumericScale],
ISNULL(xscparam.name, N'') AS [XmlSchemaNamespace],
ISNULL(s2param.name, N'') AS [XmlSchemaNamespaceSchema],
ISNULL( (case param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint],
CASE WHEN usrt.is_table_type = 1 THEN N'structured' ELSE N'' END AS [UserType],
udf.object_id AS [IDText],
db_name() AS [DatabaseName],
param.name AS [ParamName],
CAST(
 case 
    when udf.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = udf.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [ParentSysObj],
-1 AS [Number]
FROM
sys.all_objects AS udf
INNER JOIN sys.all_parameters AS param ON (param.is_output = 0) AND (param.object_id=udf.object_id)
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = param.user_type_id
LEFT OUTER JOIN sys.schemas AS s1param ON s1param.schema_id = usrt.schema_id
LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = param.system_type_id) and (baset.user_type_id = param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1)) 
LEFT OUTER JOIN sys.xml_schema_collections AS xscparam ON xscparam.xml_collection_id = param.xml_collection_id
LEFT OUTER JOIN sys.schemas AS s2param ON s2param.schema_id = xscparam.schema_id
WHERE
(param.name=@_msparam_0)and((udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))and(udf.name=@_msparam_1 and SCHEMA_NAME(udf.schema_id)=@_msparam_2)),8,2,6,180,0,8
SELECT
    DB_NAME (database_id) as [Database Name],
    name as [Database File Name],
    [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'
            WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'
            ELSE Type_Desc END,
    size*8/1024 as 'Size (MB)',
    physical_name as [Database_File_Location]
FROM sys.master_files
ORDER BY 1,3

IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL
    DROP TABLE #space

CREATE TABLE #space (
      database_id INT PRIMARY KEY
    , data_used_size DECIMAL(18,2)
    , log_used_size DECIMAL(18,2)
)

DECLARE @SQL NVARCHAR(MAX)

SELECT @SQL = STUFF((
    SELECT '
    USE [' + d.name + ']
    INSERT INTO #space (database_id, data_used_size, log_used_size)
    SELECT
          DB_ID()
        , SUM(CASE WHEN [type] = 0 THEN space_used END)
        , SUM(CASE WHEN [type] = 1 THEN space_used END)
    FROM (
        SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)
        FROM sys.database_files s
        GROUP BY s.[type]
    ) t;'
    FROM sys.databases d
    WHERE d.[state] = 0
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')

EXEC sys.sp_executesql @SQL

SELECT
      d.database_id
    , d.name
    , d.state_desc
    , d.recovery_model_desc
    , t.total_size
    , t.data_size
    , s.data_used_size
    , t.log_size
    , s.log_used_size
    , bu.full_last_date
    , bu.full_size
    , bu.log_last_date
    , bu.log_size
FROM (
    SELECT
          database_id
        , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))
    FROM sys.master_files
    GROUP BY database_id
) t
JOIN sys.databases d ON d.database_id = t.database_id
LEFT JOIN #space s ON d.database_id = s.database_id
LEFT JOIN (
    SELECT
          database_name
        , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)
        , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)
        , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)
        , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)
    FROM (
        SELECT
              s.database_name
            , s.[type]
            , s.backup_finish_date
            , backup_size =
                        CAST(CASE WHEN s.backup_size = s.compressed_backup_size
                                    THEN s.backup_size
                                    ELSE s.compressed_backup_size
                        END / 1048576.0 AS DECIMAL(18,2))
            , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)
        FROM msdb.dbo.backupset s
        WHERE s.[type] IN ('D', 'L')
    ) f
    WHERE f.RowNum = 1
    GROUP BY f.database_name
) bu ON d.name = bu.database_name
ORDER BY t.total_size DESC

SELECT 
    req.session_id
    , req.total_elapsed_time AS duration_ms
    , req.cpu_time AS cpu_time_ms
    , req.total_elapsed_time - req.cpu_time AS wait_time
    , req.logical_reads
    , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1, 
       ((CASE statement_end_offset
           WHEN -1
           THEN DATALENGTH(ST.text)  
           ELSE req.statement_end_offset
         END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '), 
      1, 512)  AS statement_text  
FROM sys.dm_exec_requests AS req
    CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST
ORDER BY total_elapsed_time DESC;

SELECT top 100 t.text,
     (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,
     (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,
     ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,
     qs.total_logical_reads / qs.execution_count AS avg_logical_reads,
     qs.total_logical_writes / qs.execution_count AS avg_writes,
     (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions
FROM sys.dm_exec_query_stats qs
     CROSS apply sys.Dm_exec_sql_text (sql_handle) t
-- WHERE t.text like '<Your Query>%'
-- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped.
ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC

--Deadlock sql check
SELECT
    session_id,
    start_time, 
    [status],
    command,
    blocking_session_id,
    wait_type,
    wait_time,
    open_transaction_count,
    transaction_id,
    total_elapsed_time,
    Definition = CAST(text AS VARCHAR(MAX))
FROM
    SYS.DM_EXEC_REQUESTS
    CROSS APPLY sys.dm_exec_sql_text(sql_handle) 
WHERE blocking_session_id != 0

,8,8,0,254,0,8

SELECT MAX(Row) AS MaxRow FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  , 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,543,544,545,561,562,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,507,508,509,510,511,512,547,563,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP ,8,7,1,2652,0,40
Select MUG.userGroupID,MUG.UserRightCode,MUG.GroupName,MUG.GroupDescription,CAL.CalID,CAL.PersonID,Person.FirstName,Person.LastName,Person.Email1,Person.Email2,UsrLogin.usrlog From Mas_UserGroups MUG inner join CAL_UserAuthen CAL on MUG.UserRightCode=CAL.UserRightCode Left join Profile_Personal Person on Person.PersonID=CAL.PersonID and Person.IsDelete=0  Left join Profile_userLogin UsrLogin ON UsrLogin.personID=Person.PersonID and UsrLogin.IsActive=1 and UsrLogin.IsDelete=0 Where MUG.Deletable=0 and MUG.SWCode='RM05' and MUG.UserRightCode=5,8,5,3,964,0,48
 IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) ) DECLARE @SQL NVARCHAR(MAX) SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '') EXEC sys.sp_executesql @SQL SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , (s.data_used_size + s.log_used_size) AS total_used     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC,7,7,0,245,0,7
SELECT
    DB_NAME (database_id) as [Database Name],
    name as [Database File Name],
    [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'
            WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'
            ELSE Type_Desc END,
    size*8/1024 as 'Size (MB)',
    physical_name as [Database_File_Location]
FROM sys.master_files
ORDER BY 1,3

IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL
    DROP TABLE #space

CREATE TABLE #space (
      database_id INT PRIMARY KEY
    , data_used_size DECIMAL(18,2)
    , log_used_size DECIMAL(18,2)
)

DECLARE @SQL NVARCHAR(MAX)

SELECT @SQL = STUFF((
    SELECT '
    USE [' + d.name + ']
    INSERT INTO #space (database_id, data_used_size, log_used_size)
    SELECT
          DB_ID()
        , SUM(CASE WHEN [type] = 0 THEN space_used END)
        , SUM(CASE WHEN [type] = 1 THEN space_used END)
    FROM (
        SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)
        FROM sys.database_files s
        GROUP BY s.[type]
    ) t;'
    FROM sys.databases d
    WHERE d.[state] = 0
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')

EXEC sys.sp_executesql @SQL

SELECT
      d.database_id
    , d.name
    , d.state_desc
    , d.recovery_model_desc
    , t.total_size
    , t.data_size
    , s.data_used_size
    , t.log_size
    , s.log_used_size
    , bu.full_last_date
    , bu.full_size
    , bu.log_last_date
    , bu.log_size
FROM (
    SELECT
          database_id
        , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))
        , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))
    FROM sys.master_files
    GROUP BY database_id
) t
JOIN sys.databases d ON d.database_id = t.database_id
LEFT JOIN #space s ON d.database_id = s.database_id
LEFT JOIN (
    SELECT
          database_name
        , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)
        , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)
        , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)
        , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)
    FROM (
        SELECT
              s.database_name
            , s.[type]
            , s.backup_finish_date
            , backup_size =
                        CAST(CASE WHEN s.backup_size = s.compressed_backup_size
                                    THEN s.backup_size
                                    ELSE s.compressed_backup_size
                        END / 1048576.0 AS DECIMAL(18,2))
            , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)
        FROM msdb.dbo.backupset s
        WHERE s.[type] IN ('D', 'L')
    ) f
    WHERE f.RowNum = 1
    GROUP BY f.database_name
) bu ON d.name = bu.database_name
ORDER BY t.total_size DESC

SELECT 
    req.session_id
    , req.total_elapsed_time AS duration_ms
    , req.cpu_time AS cpu_time_ms
    , req.total_elapsed_time - req.cpu_time AS wait_time
    , req.logical_reads
    , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1, 
       ((CASE statement_end_offset
           WHEN -1
           THEN DATALENGTH(ST.text)  
           ELSE req.statement_end_offset
         END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '), 
      1, 512)  AS statement_text  
FROM sys.dm_exec_requests AS req
    CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST
ORDER BY total_elapsed_time DESC;

SELECT top 100 t.text,
     (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,
     (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,
     ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,
     qs.total_logical_reads / qs.execution_count AS avg_logical_reads,
     qs.total_logical_writes / qs.execution_count AS avg_writes,
     (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions
FROM sys.dm_exec_query_stats qs
     CROSS apply sys.Dm_exec_sql_text (sql_handle) t
-- WHERE t.text like '<Your Query>%'
-- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped.
ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC

--Deadlock sql check
SELECT
    session_id,
    start_time, 
    [status],
    command,
    blocking_session_id,
    wait_type,
    wait_time,
    open_transaction_count,
    transaction_id,
    total_elapsed_time,
    Definition = CAST(text AS VARCHAR(MAX))
FROM
    SYS.DM_EXEC_REQUESTS
    CROSS APPLY sys.dm_exec_sql_text(sql_handle) 
WHERE blocking_session_id != 0

--SELECT
--sqlserver_start_time,
--(committed_kb/1024) AS Total_Server_Memory_MB,
--(committed_target_kb/1024)  AS Target_Server_Memory_MB
--FROM sys.dm_os_sys_info;,7,7,0,253,0,7

SELECT * FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  ,Risk.UpdateDate as [UpdateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.UpdateDate) as UpdateDate
	  ,Risk.BUID
	  ,Risk.PerspectiveID
      ,Risk.MeasureID
      ,Risk.KRAID
      ,Risk.StrategicID
      ,Risk.CategoryID
	  ,CATName=CASE WHEN(cat.Flag_status='D') THEN '<S>'+cat.CATName+'(ถูกลบ)' ELSE cat.CATName END
      ,Risk.DriverID		
	  ,DriverName = CASE WHEN(Drv.Flag_status='D') THEN '<S>'+Drv.DriverName+'(ถูกลบ)' ELSE dbo.getRiskDriverFromRiskProfile(Risk.RiskID,Risk.UpdateDate)END	  
      ,Risk.RiskStatement,Risk.Because,Risk.Result,Risk.effect
      ,Risk.ImpactID,Imp.ImpactLevel+':'+cast(Imp.ImpactScore as nvarchar(2)) as ImpName,Imp.ImpactLevel,Imp.ImpactScore,Imp.ImpactColor
      ,Risk.LikelihoodID,Lih.LikeliLevel+':'+cast(Lih.LikeliScore as nvarchar(2)) as LihName,Lih.LikeliLevel,Lih.LikeliScore,Lih.LikeliColor
      ,Risk.DoAID,DoA.DoALevel,DoA.DoAScore,DoA.DoAColor
      ,dbo.getRiskCurrent(Risk.RiskID,Risk.UpdateDate) as CurrentResponse
      ,dbo.getRiskReqResponse(Risk.RiskID,Risk.UpdateDate) as ReqResponse
      ,CoordinatorID,CurOwnerID
      ,Risk.PrefIMID,PImp.ImpactLevel+':'+cast(PImp.ImpactScore as nvarchar(2)) as PrefImpName,PImp.ImpactLevel as PrefImpactLevel,Imp.ImpactScore as PrefImpactScore,Imp.ImpactColor as PrefImpactColor
      ,Risk.PrefLIID,PLih.LikeliLevel+':'+cast(PLih.LikeliScore as nvarchar(2)) as PrefLihName,PLih.LikeliLevel as PrefLikeliLevel,PLih.LikeliScore as PrefLikeliScore,Lih.LikeliColor as PrefLikeliColor
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.EffectiveDate) as EffDate
	  ,Risk.EffectiveDate as [EffDate-int]
      ,Risk.AprvLevelID,Aprv.AprvStatus
      ,Risk.Rank
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.CreateDate) as CreateDate
	  ,Risk.CreateDate as [CreateDate-int]
      ,dbo.F_UNIXTIME_TO_DATETIME(Risk.SubmitDate) as SubmitDate
	  ,Risk.SubmitDate as [SubmitDate-int]
      ,Risk.CreatedBy
      ,Risk.SubmitBy,Risk.UpdateBy
      ,Risk.RiskObjSeq,Risk.Comment,Risk.ExpectedLoss,Risk.IsOrigin, 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(513) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP WHERE Row BETWEEN 1 AND 90,7,7,0,855,0,15
(@p0 int,@p1 int,@p2 nvarchar(6),@p3 nvarchar(64),@p4 nvarchar(12),@p5 nvarchar(4000),@p6 nvarchar(4000),@p7 nvarchar(4000),@p8 int)SELECT @p2 + (CONVERT(NVarChar,[t3].[KRIID])) AS [Code], (((@p3 + (CONVERT(NVarChar,[t3].[KRIID]))) + @p4) + (CONVERT(NVarChar,[t3].[UpdateDate]))) + @p5 AS [Factor], [t4].[DriverName] AS [RiskDriver], (@p6 + [t3].[DriverDefinition]) + @p7 AS [Description], [t3].[Measure] AS [Measurement], [t3].[MeasureUnit] AS [MeasureUnit], 
    (CASE 
        WHEN ([t5].[JustifyID]) IS NULL THEN @p8
        ELSE [t5].[JustifyID]
     END) AS [JustifyType], [t6].[Level1] AS [Level1], [t6].[Level2] AS [Level2], [t6].[Level3] AS [Level3], [t6].[Level4] AS [Level4], [t6].[Level5] AS [Level5], [t7].[ActualPeriod1] AS [Actual1], [t7].[ActualPeriod2] AS [Actual2], [t7].[ActualPeriod3] AS [Actual3], [t7].[ActualPeriod4] AS [Actual4], [t7].[ActualPeriod5] AS [Actual5], [t7].[ActualPeriod6] AS [Actual6], [t7].[ActualPeriod7] AS [Actual7], [t7].[ActualPeriod8] AS [Actual8], [t7].[ActualPeriod9] AS [Actual9], [t7].[ActualPeriod10] AS [Actual10], [t7].[ActualPeriod11] AS [Actual11], [t7].[ActualPeriod12] AS [Actual12], [t7].[TargetPeriod1] AS [Target1], [t7].[TargetPeriod2] AS [Target2], [t7].[TargetPeriod3] AS [Target3], [t7].[TargetPeriod4] AS [Target4], [t7].[TargetPeriod5] AS [Target5], [t7].[TargetPeriod6] AS [Target6], [t7].[TargetPeriod7] AS [Target7], [t7].[TargetPeriod8] AS [Target8], [t7].[TargetPeriod9] AS [Target9], [t7].[TargetPeriod10] AS [Target10], [t7].[TargetPeriod11] AS [Target11], [t7].[TargetPeriod12] AS [Target12]
FROM (
    SELECT [t0].[KRIID]
    FROM [dbo].[KRI_Profile] AS [t0]
    WHERE ([t0].[CompanyID] = @p0) AND ([t0].[PeriodID] = @p1) AND (NOT ([t0].[Deleted] = 1))
    GROUP BY [t0].[KRIID]
    ) AS [t1]
OUTER APPLY (
    SELECT TOP (1) [t2].[KRIID], [t2].[UpdateDate], [t2].[DriverID], [t2].[DriverDefinition], [t2].[Measure], [t2].[MeasureUnit], [t2].[JustifyID]
    FROM [dbo].[KRI_Profile] AS [t2]
    WHERE ([t1].[KRIID] = [t2].[KRIID]) AND ([t2].[CompanyID] = @p0) AND ([t2].[PeriodID] = @p1) AND (NOT ([t2].[Deleted] = 1))
    ORDER BY [t2].[UpdateDate] DESC
    ) AS [t3]
LEFT OUTER JOIN [dbo].[Profile_Driver] AS [t4] ON [t4].[DriverID] = [t3].[DriverID]
LEFT OUTER JOIN [dbo].[KRI_Justify] AS [t5] ON [t5].[JustifyID] = [t3].[JustifyID]
LEFT OUTER JOIN [dbo].[KRI_WarningLevel] AS [t6] ON ([t6].[KRIID] = [t3].[KRIID]) AND ([t6].[KRIUpdateDate] = [t3].[UpdateDate])
LEFT OUTER JOIN [dbo].[KRI_Collection] AS [t7] ON ([t7].[KRIID] = [t3].[KRIID]) AND ([t7].[KRIUpdateDate] = [t3].[UpdateDate])
ORDER BY [t1].[KRIID], [t3].[UpdateDate] DESC,7,4,3,623,0,7
Select MUG.userGroupID,MUG.UserRightCode,MUG.GroupName,MUG.GroupDescription,CAL.CalID,CAL.PersonID,Person.FirstName,Person.LastName,Person.Email1,Person.Email2,UsrLogin.usrlog From Mas_UserGroups MUG inner join CAL_UserAuthen CAL on MUG.UserRightCode=CAL.UserRightCode Left join Profile_Personal Person on Person.PersonID=CAL.PersonID and Person.IsDelete=0  Left join Profile_userLogin UsrLogin ON UsrLogin.personID=Person.PersonID and UsrLogin.IsActive=1 and UsrLogin.IsDelete=0 Where MUG.Deletable=0 and MUG.SWCode='RM05' and MUG.UserRightCode=89,7,3,4,832,0,42

CREATE PROCEDURE dbo.sp_verify_subsystems
   @syssubsytems_refresh_needed BIT = 0
AS
BEGIN
  SET NOCOUNT ON
   
  DECLARE @retval         INT
  DECLARE @InstRootPath nvarchar(512)
  DECLARE @VersionRootPath nvarchar(512)
  DECLARE @ComRootPath nvarchar(512)
  DECLARE @DtsRootPath nvarchar(512)
  DECLARE @SQLPSPath nvarchar(512)
  DECLARE @DTExec nvarchar(512)
  DECLARE @DTExecExists INT
  DECLARE @ToolsPath nvarchar(512)

  IF ( (@syssubsytems_refresh_needed=1) OR (NOT EXISTS(select * from syssubsystems)) )
  BEGIN
     EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\Setup', N'SQLPath', @InstRootPath OUTPUT
     IF @InstRootPath IS NULL
     BEGIN
       RAISERROR(14658, -1, -1) WITH LOG
       RETURN (1)
     END
     SELECT @InstRootPath = @InstRootPath + N'\binn\'

     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\Microsoft Sql Server\100', N'VerSpecificRootDir', @VersionRootPath OUTPUT
     IF @VersionRootPath IS NULL
     BEGIN
       RAISERROR(14659, -1, -1) WITH LOG
       RETURN(1)
     END

     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\Microsoft SQL Server\100\SSIS\Setup\DTSPath', N'', @DtsRootPath OUTPUT, N'no_output'
     IF (@DtsRootPath IS NOT NULL)
     BEGIN
       SELECT @DtsRootPath  = @DtsRootPath  + N'Binn\'
       SELECT @DTExec = @DtsRootPath + N'DTExec.exe'
       CREATE TABLE #t (file_exists int, is_directory int, parent_directory_exists int)
       INSERT #t EXEC xp_fileexist @DTExec
       SELECT TOP 1 @DTExecExists=file_exists from #t
       DROP TABLE #t
       IF ((@DTExecExists IS NULL) OR (@DTExecExists = 0))
         SET @DtsRootPath = NULL
     END

     SELECT @ComRootPath  = @VersionRootPath  + N'COM\'

     create table #Platform(ID int,  Name  sysname, Internal_Value int NULL, Value nvarchar(512))
     insert #Platform exec master.dbo.xp_msver 'Platform'
     if EXISTS(select * from #Platform where Value like '%64%')
     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Wow6432Node\Microsoft\Microsoft Sql Server\100\Tools\ClientSetup', N'SQLPath', @ToolsPath OUTPUT
  else
     EXEC master.dbo.xp_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\Microsoft Sql Server\100\Tools\ClientSetup', N'SQLPath', @ToolsPath OUTPUT
     drop table #Platform
     SELECT @SQLPSPath  = @ToolsPath  + N'\Binn\SQLPS.exe'
     
     -- Procedure must start its own transaction if we don't have one already.
     DECLARE @TranCounter INT;
     SET @TranCounter = @@TRANCOUNT;
     IF @TranCounter = 0
     BEGIN
        BEGIN TRANSACTION;
     END

     -- Obtain processor count to determine maximum number of threads per subsystem
     DECLARE @xp_results TABLE
     (
     id              INT           NOT NULL,
     name            NVARCHAR(30)  COLLATE database_default NOT NULL,
     internal_value  INT           NULL,
     character_value NVARCHAR(212) COLLATE database_default NULL
     )
     INSERT INTO @xp_results
     EXECUTE master.dbo.xp_msver

     DECLARE @processor_count INT
     SELECT @processor_count = internal_value from @xp_results where id=16 -- ProcessorCount

     -- Modify database.
     BEGIN TRY

       --create subsystems
       --TSQL subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'TSQL')
       INSERT syssubsystems
       VALUES
       (
          1, N'TSQL',14556, FORMATMESSAGE(14557), FORMATMESSAGE(14557), FORMATMESSAGE(14557), FORMATMESSAGE(14557), FORMATMESSAGE(14557), 20 * @processor_count
       )
       --ActiveScripting subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'ActiveScripting')
       INSERT syssubsystems
       VALUES
       (
          2, N'ActiveScripting',  14555, @InstRootPath + N'SQLATXSS.DLL',NULL,N'ActiveScriptStart',N'ActiveScriptEvent',N'ActiveScriptStop', 10 * @processor_count
       )

       --CmdExec subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'CmdExec')
       INSERT syssubsystems
       VALUES
       (
          3, N'CmdExec', 14550, @InstRootPath + N'SQLCMDSS.DLL',NULL,N'CmdExecStart',N'CmdEvent',N'CmdExecStop', 10 * @processor_count
       )

       --Snapshot subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'Snapshot')
       INSERT syssubsystems
       VALUES
       (
          4, N'Snapshot',   14551, @InstRootPath + N'SQLREPSS.DLL', @ComRootPath + N'SNAPSHOT.EXE', N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --LogReader subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'LogReader')
       INSERT syssubsystems
       VALUES
       (
          5, N'LogReader',  14552, @InstRootPath + N'SQLREPSS.DLL', @ComRootPath + N'logread.exe',N'ReplStart',N'ReplEvent',N'ReplStop',25 * @processor_count
       )

       --Distribution subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'Distribution')
       INSERT syssubsystems
       VALUES
       (
          6, N'Distribution',  14553, @InstRootPath + N'SQLREPSS.DLL', @ComRootPath + N'DISTRIB.EXE',N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --Merge subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'Merge')
       INSERT syssubsystems
       VALUES
       (
          7, N'Merge',   14554, @InstRootPath + N'SQLREPSS.DLL',@ComRootPath + N'REPLMERG.EXE',N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --QueueReader subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'QueueReader')
       INSERT syssubsystems
       VALUES
       (
          8, N'QueueReader',   14581, @InstRootPath + N'SQLREPSS.dll',@ComRootPath + N'qrdrsvc.exe',N'ReplStart',N'ReplEvent',N'ReplStop',100 * @processor_count
       )

       --ANALYSISQUERY subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'ANALYSISQUERY')
       INSERT syssubsystems
       VALUES
       (
          9, N'ANALYSISQUERY', 14513, @InstRootPath + N'SQLOLAPSS.DLL',NULL,N'OlapStart',N'OlapQueryEvent',N'OlapStop',100 * @processor_count
       )

       --ANALYSISCOMMAND subsystem
       IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'ANALYSISCOMMAND')
       INSERT syssubsystems
       VALUES
       (
          10, N'ANALYSISCOMMAND', 14514, @InstRootPath + N'SQLOLAPSS.DLL',NULL,N'OlapStart',N'OlapCommandEvent',N'OlapStop',100 * @processor_count
       )

       IF(@DtsRootPath IS NOT NULL)
       BEGIN
          --DTS subsystem
          IF (NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'SSIS') )
             INSERT syssubsystems
             VALUES
             (
                11, N'SSIS', 14538, @InstRootPath + N'SQLDTSSS.DLL',@DtsRootPath + N'DTExec.exe',N'DtsStart',N'DtsEvent',N'DtsStop',100 * @processor_count
             )
          ELSE
             UPDATE syssubsystems SET agent_exe = @DtsRootPath + N'DTExec.exe' WHERE subsystem = N'SSIS'
       END
       ELSE
       BEGIN
          IF EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'SSIS')
            DELETE FROM syssubsystems WHERE subsystem = N'SSIS' 
       END
       
       --PowerShell subsystem     
	   IF NOT EXISTS(SELECT * FROM syssubsystems WHERE subsystem = N'PowerShell')
	   INSERT syssubsystems
	   VALUES
	   (
		  12, N'PowerShell', 14698, @InstRootPath + N'SQLPOWERSHELLSS.DLL', @SQLPSPath, N'PowerShellStart',N'PowerShellEvent',N'PowerShellStop',2
	   )
	   

   END TRY
   BEGIN CATCH

       DECLARE @ErrorMessage NVARCHAR(400)
       DECLARE @ErrorSeverity INT
       DECLARE @ErrorState INT

       SELECT @ErrorMessage = ERROR_MESSAGE()
       SELECT @ErrorSeverity = ERROR_SEVERITY()
       SELECT @ErrorState = ERROR_STATE()

       -- Roll back the transaction that we started if we are not nested
       IF @TranCounter = 0
       BEGIN
         ROLLBACK TRANSACTION;
       END
       -- if we are nested inside another transaction just raise the 
       -- error and let the outer transaction do the rollback
       RAISERROR (@ErrorMessage, -- Message text.
                   @ErrorSeverity, -- Severity.
                   @ErrorState -- State.
                   )
       RETURN (1)                  
     END CATCH
  END --(NOT EXISTS(select * from syssubsystems))
  
  -- commit the transaction we started
  IF @TranCounter = 0
  BEGIN
    COMMIT TRANSACTION;
  END
  
  RETURN(0) -- Success
END
,6,6,0,47,2,6

SELECT MAX(Row) AS MaxRow FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  , 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,543,544,545,561,562,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,507,508,509,510,511,512,547,563,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 117
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 117
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP ,6,6,0,2652,0,33
CREATE PROCEDURE sp_sqlagent_refresh_job
  @job_id      UNIQUEIDENTIFIER = NULL,
  @server_name sysname          = NULL -- This parameter allows a TSX to use this SP when updating a job
AS
BEGIN
  DECLARE @server_id INT

  SET NOCOUNT ON

  IF (@server_name IS NULL) OR (UPPER(@server_name collate SQL_Latin1_General_CP1_CS_AS) = '(LOCAL)')
    SELECT @server_name = CONVERT(sysname, SERVERPROPERTY('ServerName'))

  SELECT @server_name = UPPER(@server_name)

  SELECT @server_id = server_id
  FROM msdb.dbo.systargetservers_view
  WHERE (UPPER(server_name) = ISNULL(@server_name, UPPER(CONVERT(sysname, SERVERPROPERTY('ServerName')))))

  SELECT @server_id = ISNULL(@server_id, 0)

  SELECT sjv.job_id,
         sjv.name,
         sjv.enabled,
         sjv.start_step_id,
         owner = dbo.SQLAGENT_SUSER_SNAME(sjv.owner_sid),
         sjv.notify_level_eventlog,
         sjv.notify_level_email,
         sjv.notify_level_netsend,
         sjv.notify_level_page,
         sjv.notify_email_operator_id,
         sjv.notify_netsend_operator_id,
         sjv.notify_page_operator_id,
         sjv.delete_level,
         has_step = (SELECT COUNT(*)
                     FROM msdb.dbo.sysjobsteps sjst
                     WHERE (sjst.job_id = sjv.job_id)),
         sjv.version_number,
         last_run_date = ISNULL(sjs.last_run_date, 0),
         last_run_time = ISNULL(sjs.last_run_time, 0),
         sjv.originating_server,
         sjv.description,
         agent_account = CASE sjv.owner_sid
              WHEN 0xFFFFFFFF THEN 1
              ELSE                 0
         END
  FROM msdb.dbo.sysjobservers sjs,
       msdb.dbo.sysjobs_view  sjv
  WHERE ((@job_id IS NULL) OR (@job_id = sjv.job_id))
    AND (sjv.job_id = sjs.job_id)
    AND (sjs.server_id = @server_id)
  ORDER BY sjv.job_id
  OPTION (FORCE ORDER)

  RETURN(@@error) -- 0 means success
END
,6,4,2,79,0,6
SELECT CurOwnerID FROM RiskProfile WHERE CurOwnerID <>0 AND PeriodID = 31 AND CompanyID = 1 GROUP BY CurOwnerID,6,3,3,550,0,13
CREATE   PROCEDURE sp_delete_backuphistory
  @oldest_date datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @backup_set_id TABLE      (backup_set_id INT)
  DECLARE @media_set_id TABLE       (media_set_id INT)
  DECLARE @restore_history_id TABLE (restore_history_id INT)

  INSERT INTO @backup_set_id (backup_set_id)
  SELECT DISTINCT backup_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @media_set_id (media_set_id)
  SELECT DISTINCT media_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @restore_history_id (restore_history_id)
  SELECT DISTINCT restore_history_id
  FROM msdb.dbo.restorehistory
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)

  BEGIN TRANSACTION

  DELETE FROM msdb.dbo.backupfile
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupfilegroup
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefile
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefilegroup
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorehistory
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupset
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediafamily
  FROM msdb.dbo.backupmediafamily bmf
  WHERE bmf.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bmf.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediaset
  FROM msdb.dbo.backupmediaset bms
  WHERE bms.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bms.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  COMMIT TRANSACTION
  RETURN

Quit:
  ROLLBACK TRANSACTION

END
,6,4,2,977,3,6

        CREATE PROCEDURE dbo.TempUpdateStateItemLong
            @id         tSessionId,
            @itemLong   tSessionItemLong,
            @timeout    int,
            @lockCookie int
        AS    
            UPDATE [ASPState].dbo.ASPStateTempSessions
            SET Expires = DATEADD(n, @timeout, GETUTCDATE()), 
                SessionItemLong = @itemLong,
                Timeout = @timeout,
                Locked = 0
            WHERE SessionId = @id AND LockCookie = @lockCookie

            RETURN 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ,6,5,1,46,1,42

SELECT MAX(Row) AS MaxRow FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  , 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=24 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,528,445,446,447,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,507,508,509,510,511,512,529,531,532,533,534,535,530,536,537,538,539,540,525,526,527) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=24 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=24 and C.companyID=1)) 
) AS EMP ,5,5,0,1007,0,29

SELECT MAX(Row) AS MaxRow FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  , 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=28 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,445,447,546,543,544,545,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,507,508,509,510,511,512,547,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=28 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=28 and C.companyID=1)) 
) AS EMP ,5,5,0,1441,0,216
CREATE   PROCEDURE sp_delete_backuphistory
  @oldest_date datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @backup_set_id TABLE      (backup_set_id INT)
  DECLARE @media_set_id TABLE       (media_set_id INT)
  DECLARE @restore_history_id TABLE (restore_history_id INT)

  INSERT INTO @backup_set_id (backup_set_id)
  SELECT DISTINCT backup_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @media_set_id (media_set_id)
  SELECT DISTINCT media_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @restore_history_id (restore_history_id)
  SELECT DISTINCT restore_history_id
  FROM msdb.dbo.restorehistory
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)

  BEGIN TRANSACTION

  DELETE FROM msdb.dbo.backupfile
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupfilegroup
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefile
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefilegroup
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorehistory
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupset
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediafamily
  FROM msdb.dbo.backupmediafamily bmf
  WHERE bmf.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bmf.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediaset
  FROM msdb.dbo.backupmediaset bms
  WHERE bms.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bms.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  COMMIT TRANSACTION
  RETURN

Quit:
  ROLLBACK TRANSACTION

END
,5,5,0,1918,144,5

SELECT MAX(Row) AS MaxRow FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  , 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=27 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.BUID IN(1,275,278,448,449,450,451,452,453,454,455,514,515,516,517,285,456,463,464,458,465,467,518,286,355,356,357,399,439,440,441,443,445,447,546,543,544,545,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,507,508,509,510,511,512,547,513,542,548,549,551,552,553,554,555,550,556,557,558,559,560) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=27 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=27 and C.companyID=1)) 
) AS EMP ,5,5,0,1380,0,213
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(v.schema_id) AS [Schema],
v.name AS [Name]
FROM
sys.all_views AS v
WHERE
(v.type = @_msparam_0)
ORDER BY
[Schema] ASC,[Name] ASC,5,4,1,60,0,25
declare @Path nvarchar(255)
declare @Name nvarchar(255)


select @Path = N'D:'



		create table #filetmpfin (Name nvarchar(255) NOT NULL, IsFile bit NULL) 
		if(@Name is null) 
		begin 
			create table #filetmp (Name nvarchar(255) NOT NULL, depth int NOT NULL, IsFile bit NULL ) 
			insert #filetmp EXECUTE master.dbo.xp_dirtree @Path, 1, 1 
			insert #filetmpfin select Name, IsFile from #filetmp f 
			drop table #filetmp 
		end 
		if(NOT @Name is null) 
		begin 
			declare @FullName nvarchar(300) 
			if(@Path is null) 
				select @FullName = @Name 
			else
				select @FullName = @Path 	+ '\' + @Name 
			create table #filetmp2 ( Exist bit NOT NULL, IsDir bit NOT NULL, DirExist bit NULL ) 
			insert #filetmp2 EXECUTE master.dbo.xp_fileexist @FullName 
			insert #filetmpfin select @Name, 1-IsDir from #filetmp2 where Exist = 1 or IsDir = 1 drop table #filetmp2 
		end
		


SELECT
Name AS [Name],
IsFile AS [IsFile]
FROM
#filetmpfin
ORDER BY
[IsFile] ASC,[Name] ASC
drop table #filetmpfin
,5,3,2,66,0,5
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(v.schema_id) AS [Schema],
v.name AS [Name]
FROM
sys.all_views AS v
WHERE
(v.type = @_msparam_0)
ORDER BY
[Schema] ASC,[Name] ASC,4,3,1,33,0,24
select pp.PersonID,pp.FirstName,pp.MiddleName,pp.LastName,pp.Email1, pu.usrlog, pu.IsActive from Profile_Personal pp left join Profile_userLogin pu on pp.PersonID = pu.personID where pu.IsActive is null or pu.IsActive = 1 and pp.IsDelete=0 ORDER BY FirstName,4,2,2,29,0,28
declare @Path nvarchar(255)
declare @Name nvarchar(255)


select @Path = N'H:'



		create table #filetmpfin (Name nvarchar(255) NOT NULL, IsFile bit NULL) 
		if(@Name is null) 
		begin 
			create table #filetmp (Name nvarchar(255) NOT NULL, depth int NOT NULL, IsFile bit NULL ) 
			insert #filetmp EXECUTE master.dbo.xp_dirtree @Path, 1, 1 
			insert #filetmpfin select Name, IsFile from #filetmp f 
			drop table #filetmp 
		end 
		if(NOT @Name is null) 
		begin 
			declare @FullName nvarchar(300) 
			if(@Path is null) 
				select @FullName = @Name 
			else
				select @FullName = @Path 	+ '\' + @Name 
			create table #filetmp2 ( Exist bit NOT NULL, IsDir bit NOT NULL, DirExist bit NULL ) 
			insert #filetmp2 EXECUTE master.dbo.xp_fileexist @FullName 
			insert #filetmpfin select @Name, 1-IsDir from #filetmp2 where Exist = 1 or IsDir = 1 drop table #filetmp2 
		end
		


SELECT
Name AS [Name],
IsFile AS [IsFile]
FROM
#filetmpfin
ORDER BY
[IsFile] ASC,[Name] ASC
drop table #filetmpfin
,4,2,2,63,0,4
SELECT
log.name AS [Name],
log.principal_id AS [ID],
ISNULL(ak.name,N'') AS [AsymmetricKey],
ISNULL(cert.name,N'') AS [Certificate],
ISNULL(c.name,N'') AS [Credential],
CASE WHEN N'U' = log.type THEN 0 WHEN N'G' = log.type THEN 1 WHEN N'S' = log.type THEN 2 WHEN N'C' = log.type THEN 3 WHEN N'K' = log.type THEN 4 END AS [LoginType]
FROM
sys.server_principals AS log
LEFT OUTER JOIN master.sys.asymmetric_keys AS ak ON ak.sid = log.sid
LEFT OUTER JOIN master.sys.certificates AS cert ON cert.sid = log.sid
LEFT OUTER JOIN sys.credentials AS c ON c.credential_id = log.credential_id
WHERE
(log.type in ('U', 'G', 'S', 'C', 'K') AND log.principal_id not between 101 and 255 AND log.name <> N'##MS_AgentSigningCertificate##')
ORDER BY
[Name] ASC,4,2,2,269,0,22
declare @Path nvarchar(255)
declare @Name nvarchar(255)


select @Path = N'F:'



		create table #filetmpfin (Name nvarchar(255) NOT NULL, IsFile bit NULL) 
		if(@Name is null) 
		begin 
			create table #filetmp (Name nvarchar(255) NOT NULL, depth int NOT NULL, IsFile bit NULL ) 
			insert #filetmp EXECUTE master.dbo.xp_dirtree @Path, 1, 1 
			insert #filetmpfin select Name, IsFile from #filetmp f 
			drop table #filetmp 
		end 
		if(NOT @Name is null) 
		begin 
			declare @FullName nvarchar(300) 
			if(@Path is null) 
				select @FullName = @Name 
			else
				select @FullName = @Path 	+ '\' + @Name 
			create table #filetmp2 ( Exist bit NOT NULL, IsDir bit NOT NULL, DirExist bit NULL ) 
			insert #filetmp2 EXECUTE master.dbo.xp_fileexist @FullName 
			insert #filetmpfin select @Name, 1-IsDir from #filetmp2 where Exist = 1 or IsDir = 1 drop table #filetmp2 
		end
		


SELECT
Name AS [Name],
IsFile AS [IsFile]
FROM
#filetmpfin
ORDER BY
[IsFile] ASC,[Name] ASC
drop table #filetmpfin
,4,2,2,60,0,4
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT
param.is_readonly AS [IsReadOnly],
param.name AS [Name],
param.parameter_id AS [ID],
param.default_value AS [DefaultValue],
usrt.name AS [DataType],
sparam.name AS [DataTypeSchema],
ISNULL(baset.name, N'') AS [SystemType],
CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND param.max_length <> -1 THEN param.max_length/2 ELSE param.max_length END AS int) AS [Length],
CAST(param.precision AS int) AS [NumericPrecision],
CAST(param.scale AS int) AS [NumericScale],
ISNULL(xscparam.name, N'') AS [XmlSchemaNamespace],
ISNULL(s2param.name, N'') AS [XmlSchemaNamespaceSchema],
ISNULL( (case param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint],
CASE WHEN usrt.is_table_type = 1 THEN N'structured' ELSE N'' END AS [UserType],
udf.object_id AS [IDText],
db_name() AS [DatabaseName],
param.name AS [ParamName],
CAST(
 case 
    when udf.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = udf.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [ParentSysObj],
-1 AS [Number]
FROM
sys.all_objects AS udf
INNER JOIN sys.all_parameters AS param ON (param.is_output = 0) AND (param.object_id=udf.object_id)
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = param.user_type_id
LEFT OUTER JOIN sys.schemas AS sparam ON sparam.schema_id = usrt.schema_id
LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = param.system_type_id) and (baset.user_type_id = param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1)) 
LEFT OUTER JOIN sys.xml_schema_collections AS xscparam ON xscparam.xml_collection_id = param.xml_collection_id
LEFT OUTER JOIN sys.schemas AS s2param ON s2param.schema_id = xscparam.schema_id
WHERE
(param.name=@_msparam_0)and((udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))and(udf.name=@_msparam_1 and SCHEMA_NAME(udf.schema_id)=@_msparam_2)),4,2,2,180,0,21

SELECT MAX(Row) AS MaxRow FROM
    (SELECT ROW_NUMBER() 
        OVER (ORDER BY RiskID) AS Row, 
	  Risk.RiskID
	  , 1 AS ViewAuth 	From   ((((((((RiskProfile Risk
			LEFT OUTER JOIN Profile_Impact Imp  ON Risk.ImpactID = Imp.ImpactID AND Imp.PeriodID=Risk.PeriodID and Imp.CompanyID=Risk.CompanyID) 
                                 LEFT OUTER JOIN Profile_Likelihood         Lih  ON Risk.LikelihoodID=Lih.LikelihoodID  AND Lih.PeriodID=Risk.PeriodID and Lih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Mas_DegreeofAcceptance		DoA  ON Risk.DoAID=DoA.DoAID             )
                                 LEFT OUTER JOIN Profile_Impact             PImp ON Risk.PrefIMID=PImp.ImpactID   AND PImp.PeriodID=Risk.PeriodID and PImp.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Likelihood         PLih ON Risk.PrefLIID=PLih.LikelihoodID AND PLih.PeriodID=Risk.PeriodID and PLih.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Category           Cat  ON Risk.CategoryID =Cat.CategoryID and Cat.CompanyID=Risk.CompanyID)
                                 LEFT OUTER JOIN Profile_Driver             Drv  ON Risk.DriverID   =Drv.DriverID and Drv.CompanyID=Risk.CompanyID )
                                 LEFT OUTER JOIN Mas_ApprovalLevel          Aprv ON Risk.AprvLevelID=Aprv.AprvLevelID) Where  Risk.PeriodID=31 and Risk.companyID=1
			and  Risk.UpdateDate = ANY (SELECT MAX(Journey.UpdateDate) As UpdateDate 
                                          FROM RiskProfile Journey           
                                          WHERE Journey.RiskID=Risk.RiskID  AND Journey.IsOrigin<>'-1' GROUP BY Journey.RiskID)  AND Risk.CategoryID IN (14,16,17,18) AND (
      EXISTS (SELECT * 
                  FROM Auth_UserBizAuth B 
                  WHERE B.BUID=Risk.BUID  
                  AND B.UserID = 1
				  AND B.PeriodID=31 and B.companyID=1) 
      
      OR EXISTS (SELECT *         
                 FROM Auth_UserPerspAuth C   
                 WHERE C.PerspectiveID=Risk.PerspectiveID
                  AND C.UserID = 1
				  AND C.PeriodID=31 and C.companyID=1)) 
) AS EMP ,4,4,0,1948,0,63
SELECT [R].[ROUTINE_SCHEMA], [R].[ROUTINE_NAME], [P].[ORDINAL_POSITION], [P].[IS_RESULT], [P].[PARAMETER_NAME],
       [P].[DATA_TYPE], [P].[PARAMETER_MODE], [P].[NUMERIC_PRECISION], [P].[NUMERIC_SCALE],
       [P].[NUMERIC_PRECISION_RADIX], [P].[DATETIME_PRECISION], [P].[CHARACTER_MAXIMUM_LENGTH]
  FROM [GewinnGICS].[INFORMATION_SCHEMA].[ROUTINES] AS [R] LEFT OUTER JOIN [GewinnGICS].[INFORMATION_SCHEMA].[PARAMETERS] AS [P]
    ON [P].[SPECIFIC_SCHEMA] = [R].[SPECIFIC_SCHEMA] AND [P].[SPECIFIC_NAME] = [R].[SPECIFIC_NAME]
 WHERE [R].[ROUTINE_TYPE] = 'PROCEDURE' AND [R].[ROUTINE_SCHEMA] <> 'SYS'
 ORDER BY [R].[ROUTINE_SCHEMA], [R].[ROUTINE_NAME], [P].ORDINAL_POSITION,4,3,1,295,0,4
(@1 int,@2 varchar(8000),@3 varchar(8000))UPDATE [Log_System_Session] set [LastAccessTime] = @1  WHERE [SessionID]=@2 AND [StartTime]=@3,4,3,1,124,0,66
(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))SELECT
clmns.column_id AS [ID],
clmns.name AS [Name],
clmns.is_nullable AS [Nullable],
CAST(ISNULL(cik.index_column_id, 0) AS bit) AS [InPrimaryKey],
clmns.is_identity AS [Identity],
usrt.name AS [DataType],
ISNULL(baset.name, N'') AS [SystemType],
CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND clmns.max_length <> -1 THEN clmns.max_length/2 ELSE clmns.max_length END AS int) AS [Length],
CAST(clmns.precision AS int) AS [NumericPrecision],
CAST(clmns.scale AS int) AS [NumericScale],
ISNULL(xscclmns.name, N'') AS [XmlSchemaNamespace],
ISNULL(s2clmns.name, N'') AS [XmlSchemaNamespaceSchema],
ISNULL( (case clmns.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint],
sclmns.name AS [DataTypeSchema]
FROM
sys.tables AS tbl
INNER JOIN sys.all_columns AS clmns ON clmns.object_id=tbl.object_id
LEFT OUTER JOIN sys.indexes AS ik ON ik.object_id = clmns.object_id and 1=ik.is_primary_key
LEFT OUTER JOIN sys.index_columns AS cik ON cik.index_id = ik.index_id and cik.column_id = clmns.column_id and cik.object_id = clmns.object_id and 0 = cik.is_included_column
LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = clmns.user_type_id
LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = clmns.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = clmns.system_type_id) and (baset.user_type_id = clmns.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1)) 
LEFT OUTER JOIN sys.xml_schema_collections AS xscclmns ON xscclmns.xml_collection_id = clmns.xml_collection_id
LEFT OUTER JOIN sys.schemas AS s2clmns ON s2clmns.schema_id = xscclmns.schema_id
LEFT OUTER JOIN sys.schemas AS sclmns ON sclmns.schema_id = usrt.schema_id
WHERE
(tbl.name=@_msparam_0 and SCHEMA_NAME(tbl.schema_id)=@_msparam_1)
ORDER BY
[ID] ASC,4,3,1,853,0,20
CREATE   PROCEDURE sp_delete_backuphistory
  @oldest_date datetime
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @backup_set_id TABLE      (backup_set_id INT)
  DECLARE @media_set_id TABLE       (media_set_id INT)
  DECLARE @restore_history_id TABLE (restore_history_id INT)

  INSERT INTO @backup_set_id (backup_set_id)
  SELECT DISTINCT backup_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @media_set_id (media_set_id)
  SELECT DISTINCT media_set_id
  FROM msdb.dbo.backupset
  WHERE backup_finish_date < @oldest_date

  INSERT INTO @restore_history_id (restore_history_id)
  SELECT DISTINCT restore_history_id
  FROM msdb.dbo.restorehistory
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)

  BEGIN TRANSACTION

  DELETE FROM msdb.dbo.backupfile
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupfilegroup
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefile
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorefilegroup
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.restorehistory
  WHERE restore_history_id IN (SELECT restore_history_id
                               FROM @restore_history_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE FROM msdb.dbo.backupset
  WHERE backup_set_id IN (SELECT backup_set_id
                          FROM @backup_set_id)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediafamily
  FROM msdb.dbo.backupmediafamily bmf
  WHERE bmf.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bmf.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  DELETE msdb.dbo.backupmediaset
  FROM msdb.dbo.backupmediaset bms
  WHERE bms.media_set_id IN (SELECT media_set_id
                             FROM @media_set_id)
    AND ((SELECT COUNT(*)
          FROM msdb.dbo.backupset
          WHERE media_set_id = bms.media_set_id) = 0)
  IF (@@error > 0)
    GOTO Quit

  COMMIT TRANSACTION
  RETURN

Quit:
  ROLLBACK TRANSACTION

END
,3,1,2,769,2,83
(@_msparam_0 nvarchar(4000))SELECT
SCHEMA_NAME(v.schema_id) AS [Schema],
v.name AS [Name],
CAST(
 case 
    when v.is_ms_shipped = 1 then 1
    when (
        select 
            major_id 
        from 
            sys.extended_properties 
        where 
            major_id = v.object_id and 
            minor_id = 0 and 
            class = 1 and 
            name = N'microsoft_database_tools_support') 
        is not null then 1
    else 0
end          
             AS bit) AS [IsSystemObject]
FROM
sys.all_views AS v
WHERE
(v.type = @_msparam_0)
ORDER BY
[Schema] ASC,[Name] ASC,3,2,1,31,0,81

            Select A.FuncObjID, A.PeriodID, A.CompanyID, A.FuncObjCode, A.FuncObj, A.FuncObjDesc, A.BUID, B.BUName, A.Remark, A.IsDelete, (-1) AS ParentID 
            From Obj_Function A LEFT OUTER JOIN Hrcy_BusinessUnit B ON A.BUID = B.BUID AND A.PeriodID = B.PeriodID AND A.CompanyID = B.CompanyID
            WHERE A.PeriodID = 31 AND A.CompanyID = 1 AND B.BUTypeID <> 5 AND A.IsDelete = 0,3,2,1,300,0,7
(@_msparam_0 nvarchar(4000))SELECT
CAST(COLLATIONPROPERTY(name, 'LCID') AS int) AS [LocaleID]
FROM
sys.fn_helpcollations() cl
WHERE
(cl.name=@_msparam_0),3,3,0,0,0,13823
(@1 varchar(8000))SELECT * FROM [msdb]..[sysmaintplan_logdetail] WHERE [task_detail_id]=@1 ORDER BY [start_time] ASC,[end_time] ASC,3,3,0,1765,0,13415
