"use mdb;  select 	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",7077,8750,-1673,18494,0,7077
"use mdb;  select 	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",5953,8321,-2368,18494,0,5953
"use mdb;  select 	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",3524,5603,-2079,19826,0,3524
"use mdb;  select 	ca_location.location_name ,	ca_owned_resource.resource_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",3320,5555,-2235,19826,0,3320
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",3174,5411,-2237,19826,0,3174
"use mdb;  select 	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') ,	ca_owned_resource.inactive from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",2745,4252,-1507,18494,0,2745
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",1211,678,533,162336,0,3633
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info; ",963,656,307,260495,3282,963
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name --,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						--left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",784,580,204,161309,0,784
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0   ",778,736,42,264010,3112,778
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",773,602,171,161309,0,1547
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",724,573,151,161309,0,1449
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",718,582,136,161285,0,1437
"CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_plan]     @duration smallint = NULL,     @end_time datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     PRINT 'Begin purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())      DECLARE @stop_purge int      -- Delete orphaned rows from snapshots.notable_query_plan.  Query plans are not deleted by the generic purge      -- process that deletes other data (above) because query plan rows are not tied to a particular snapshot ID.      -- Purging query plans table  as a special case, by looking for plans that      -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these      -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and      -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).       DECLARE @rows_affected int;     -- set expected rows affected as delete batch size     SET @rows_affected = @delete_batch_size;          -- select set of orphaned query plans to be deleted into a temp table      SELECT qp.[sql_handle],         qp.plan_handle,         qp.plan_generation_num,         qp.statement_start_offset,         qp.statement_end_offset,         qp.creation_time     INTO #tmp_notable_query_plan     FROM snapshots.notable_query_plan AS qp      WHERE NOT EXISTS (         SELECT snapshot_id          FROM snapshots.query_stats AS qs         WHERE qs.[sql_handle] = qp.[sql_handle] AND qs.plan_handle = qp.plan_handle              AND qs.plan_generation_num = qp.plan_generation_num              AND qs.statement_start_offset = qp.statement_start_offset              AND qs.statement_end_offset = qp.statement_end_offset              AND qs.creation_time = qp.creation_time)      WHILE (@rows_affected = @delete_batch_size)     BEGIN         -- Deleting TOP N orphaned rows in query plan table by joining info from temp table variable         -- This is done to speed up delete query.          DELETE TOP (@delete_batch_size) snapshots.notable_query_plan          FROM snapshots.notable_query_plan AS qp , #tmp_notable_query_plan AS tmp         WHERE tmp.[sql_handle] = qp.[sql_handle]              AND tmp.plan_handle = qp.plan_handle              AND tmp.plan_generation_num = qp.plan_generation_num              AND tmp.statement_start_offset = qp.statement_start_offset              AND tmp.statement_end_offset = qp.statement_end_offset              AND tmp.creation_time = qp.creation_time                  SET @rows_affected = @@ROWCOUNT;         IF(@rows_affected > 0)         BEGIN             RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_plan', 0, 1, @rows_affected) WITH NOWAIT;         END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN             PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END     END;          PRINT 'End purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE()) END  ",644,644,0,34093,8,644
" CREATE PROC [dbo].[sp_syscollector_snapshot_dm_exec_query_stats_internal]   @include_system_databases bit = 1 AS BEGIN     SET NOCOUNT ON      DECLARE @p1 datetime     SET @p1 = GETDATE()      SELECT          [sql_handle],         statement_start_offset,         statement_end_offset,         -- Use ISNULL here and in other columns to handle in-progress queries that are not yet in sys.dm_exec_query_stats.           -- These values only come from sys.dm_exec_query_stats. If the plan does not show up in sys.dm_exec_query_stats          -- (first execution of a still-in-progress query, visible in sys.dm_exec_requests), these values will be NULL.          MAX (plan_generation_num) AS plan_generation_num,         plan_handle,         MIN (creation_time) AS creation_time,          MAX (last_execution_time) AS last_execution_time,         SUM (execution_count) AS execution_count,         SUM (total_worker_time) AS total_worker_time,         MIN (min_worker_time) AS min_worker_time,           -- NULLable         MAX (max_worker_time) AS max_worker_time,         SUM (total_physical_reads) AS total_physical_reads,         MIN (min_physical_reads) AS min_physical_reads,     -- NULLable         MAX (max_physical_reads) AS max_physical_reads,         SUM (total_logical_writes) AS total_logical_writes,         MIN (min_logical_writes) AS min_logical_writes,     -- NULLable         MAX (max_logical_writes) AS max_logical_writes,         SUM (total_logical_reads) AS total_logical_reads,         MIN (min_logical_reads) AS min_logical_reads,       -- NULLable         MAX (max_logical_reads) AS max_logical_reads,         SUM (total_clr_time) AS total_clr_time,         MIN (min_clr_time) AS min_clr_time,                 -- NULLable         MAX (max_clr_time) AS max_clr_time,         SUM (total_elapsed_time) AS total_elapsed_time,         MIN (min_elapsed_time) AS min_elapsed_time,         -- NULLable         MAX (max_elapsed_time) AS max_elapsed_time,         @p1 AS collection_time     FROM     (         SELECT               [sql_handle],             statement_start_offset,             statement_end_offset,             plan_generation_num,             plan_handle,             creation_time,             last_execution_time,             execution_count,             total_worker_time,             min_worker_time,             max_worker_time,             total_physical_reads,             min_physical_reads,             max_physical_reads,             total_logical_writes,             min_logical_writes,             max_logical_writes,             total_logical_reads,             min_logical_reads,             max_logical_reads,             total_clr_time,             min_clr_time,             max_clr_time,             total_elapsed_time,             min_elapsed_time,             max_elapsed_time          FROM sys.dm_exec_query_stats AS q         -- Temporary workaround for VSTS #91422.  This should be removed if/when sys.dm_exec_query_stats reflects in-progress queries.          UNION ALL          SELECT              r.[sql_handle],             r.statement_start_offset,             r.statement_end_offset,             ISNULL (qs.plan_generation_num, 0) AS plan_generation_num,             r.plan_handle,             ISNULL (qs.creation_time, r.start_time) AS creation_time,             r.start_time AS last_execution_time,             1 AS execution_count,             -- dm_exec_requests shows CPU time as ms, while dm_exec_query_stats              -- uses microseconds.  Convert ms to us.              r.cpu_time * CAST(1000 as bigint) AS total_worker_time,             qs.min_worker_time,     -- min should not be influenced by in-progress queries             r.cpu_time * CAST(1000 as bigint) AS max_worker_time,             r.reads AS total_physical_reads,             qs.min_physical_reads,  -- min should not be influenced by in-progress queries             r.reads AS max_physical_reads,             r.writes AS total_logical_writes,             qs.min_logical_writes,  -- min should not be influenced by in-progress queries             r.writes AS max_logical_writes,             r.logical_reads AS total_logical_reads,             qs.min_logical_reads,   -- min should not be influenced by in-progress queries             r.logical_reads AS max_logical_reads,             qs.total_clr_time,      -- CLR time is not available in dm_exec_requests             qs.min_clr_time,        -- CLR time is not available in dm_exec_requests             qs.max_clr_time,        -- CLR time is not available in dm_exec_requests             -- dm_exec_requests shows elapsed time as ms, while dm_exec_query_stats              -- uses microseconds.  Convert ms to us.              r.total_elapsed_time * CAST(1000 as bigint) AS total_elapsed_time,             qs.min_elapsed_time,    -- min should not be influenced by in-progress queries             r.total_elapsed_time * CAST(1000 as bigint) AS max_elapsed_time         FROM sys.dm_exec_requests AS r          LEFT OUTER JOIN sys.dm_exec_query_stats AS qs ON r.plan_handle = qs.plan_handle AND r.statement_start_offset = qs.statement_start_offset              AND r.statement_end_offset = qs.statement_end_offset          WHERE r.sql_handle IS NOT NULL      ) AS query_stats      OUTER APPLY sys.dm_exec_sql_text (sql_handle) AS sql     WHERE (@include_system_databases = 1 OR ([sql].dbid > 4 AND [sql].dbid < 32767))     GROUP BY [sql_handle], plan_handle, statement_start_offset, statement_end_offset      ORDER BY [sql_handle], plan_handle, statement_start_offset, statement_end_offset END ",539,492,47,1024,0,592292
"CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_text]     @duration smallint = NULL,     @end_time datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     PRINT 'Begin purging orphaned records in snapshots.notable_query_text Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())      DECLARE @stop_purge int      -- Delete orphaned rows from snapshots.notable_query_text.  Query texts are not deleted by the generic purge      -- process that deletes other data (above) because query text rows are not tied to a particular snapshot ID.      -- Purging  query text table as a special case, by looking for plans that      -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these      -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and      -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).       DECLARE @rows_affected int;     -- set expected rows affected as delete batch size     SET @rows_affected = @delete_batch_size;      SELECT qtext.[sql_handle]      INTO #tmp_notable_query_text     FROM snapshots.notable_query_text AS qtext     EXCEPT ( 	SELECT qt.[sql_handle] FROM snapshots.notable_query_text AS qt  	INNER HASH JOIN snapshots.query_stats AS qs  	ON (qt.sql_handle = qs.sql_handle))      WHILE (@rows_affected = @delete_batch_size)     BEGIN         -- Deleting TOP N orphaned rows in query text table by joining info from temp table         -- This is done to speed up delete query.          DELETE TOP (@delete_batch_size) snapshots.notable_query_text           FROM snapshots.notable_query_text AS qt, #tmp_notable_query_text AS tmp         WHERE tmp.[sql_handle] = qt.[sql_handle]                  SET @rows_affected = @@ROWCOUNT;         IF(@rows_affected > 0)         BEGIN             RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_text', 0, 1, @rows_affected) WITH NOWAIT;         END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN             PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END     END;      PRINT 'End purging orphaned records in snapshots.notable_query_text Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())  END  ",533,533,0,33749,4,533
"(@P1 nvarchar(4000))SELECT call_req.persid, cr_template.quick_tmpl_type, call_req.template_name, call_req.open_date FROM call_req, cr_template WHERE call_req.template_name = cr_template.template_name AND cr_template.quick_tmpl_type <> 0 AND call_req.type = @P1 AND call_req.template_name = cr_template.template_name AND cr_template.del = 0 ORDER BY call_req.template_name ",528,2066,-1538,12843,5,4231
"use mdb;  select  	ca_location.location_name ,	ca_resource_class.name ,	ca_resource_cost_center.description from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_owned_resource.inactive = 0 		and ca_resource_cost_center.description like '%CA POS%' 		and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย')",364,73,291,19448,0,364
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						--left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.resource_name like N'%CMS%' 	--and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",347,966,-619,89795,9,695
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.resource_name like N'%CMS%' 	and ca_owned_resource.inactive = 0",331,924,-593,94011,9,331
"use mdb;  select  	ca_location.zpost_code ,	ca_location.location_name ,	ca_organization.org_name ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name --,	ca_contact.last_name ,	ca_owned_resource.resource_description --,	ca_owned_resource.inactive from ca_owned_resource	left join ca_location	on ca_owned_resource.location_uuid = ca_location.location_uuid 						--left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join usp_lrel_oenv_orgref on  ca_owned_resource.own_resource_uuid = usp_lrel_oenv_orgref.nr 						left join ca_organization on usp_lrel_oenv_orgref.org = ca_organization.organization_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id where ca_owned_resource.resource_name like 'HND%' 	--and ca_owned_resource.inactive = 0 	--and ca_owned_resource.resource_description like N'%สูญหาย%'",285,1009,-724,15699,0,285
"CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_plan]     @duration smallint = NULL,     @end_time datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     PRINT 'Begin purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())      DECLARE @stop_purge int      -- Delete orphaned rows from snapshots.notable_query_plan.  Query plans are not deleted by the generic purge      -- process that deletes other data (above) because query plan rows are not tied to a particular snapshot ID.      -- Purging query plans table  as a special case, by looking for plans that      -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these      -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and      -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).       DECLARE @rows_affected int;     -- set expected rows affected as delete batch size     SET @rows_affected = @delete_batch_size;          -- select set of orphaned query plans to be deleted into a temp table      SELECT qp.[sql_handle],         qp.plan_handle,         qp.plan_generation_num,         qp.statement_start_offset,         qp.statement_end_offset,         qp.creation_time     INTO #tmp_notable_query_plan     FROM snapshots.notable_query_plan AS qp      WHERE NOT EXISTS (         SELECT snapshot_id          FROM snapshots.query_stats AS qs         WHERE qs.[sql_handle] = qp.[sql_handle] AND qs.plan_handle = qp.plan_handle              AND qs.plan_generation_num = qp.plan_generation_num              AND qs.statement_start_offset = qp.statement_start_offset              AND qs.statement_end_offset = qp.statement_end_offset              AND qs.creation_time = qp.creation_time)      WHILE (@rows_affected = @delete_batch_size)     BEGIN         -- Deleting TOP N orphaned rows in query plan table by joining info from temp table variable         -- This is done to speed up delete query.          DELETE TOP (@delete_batch_size) snapshots.notable_query_plan          FROM snapshots.notable_query_plan AS qp , #tmp_notable_query_plan AS tmp         WHERE tmp.[sql_handle] = qp.[sql_handle]              AND tmp.plan_handle = qp.plan_handle              AND tmp.plan_generation_num = qp.plan_generation_num              AND tmp.statement_start_offset = qp.statement_start_offset              AND tmp.statement_end_offset = qp.statement_end_offset              AND tmp.creation_time = qp.creation_time                  SET @rows_affected = @@ROWCOUNT;         IF(@rows_affected > 0)         BEGIN             RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_plan', 0, 1, @rows_affected) WITH NOWAIT;         END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN             PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END     END;          PRINT 'End purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE()) END  ",252,59,193,9155,2557,252
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount]       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END     ",211,210,1,568,2,5287
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 1",208,207,1,64350,0,626
"use mdb;  select  	ca_location.zpost_code ,	ca_location.location_name ,	ca_organization.org_name ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_contact.last_name ,	ca_owned_resource.resource_description --,	ca_owned_resource.inactive from ca_owned_resource	left join ca_location	on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join usp_lrel_oenv_orgref on  ca_owned_resource.own_resource_uuid = usp_lrel_oenv_orgref.nr 						left join ca_organization on usp_lrel_oenv_orgref.org = ca_organization.organization_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id where ca_owned_resource.resource_name like 'HND%' 	--and ca_owned_resource.inactive = 0 	--and ca_owned_resource.resource_description like N'%สูญหาย%'",204,896,-692,17031,0,204
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], s1ret_param.name AS [DataTypeSchema] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",201,199,2,7007,0,201
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	--and ca_owned_resource.resource_name like N'%CMS%' 	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 1",184,184,0,64350,0,184
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000))SELECT tbl.name AS [Name], SCHEMA_NAME(tbl.schema_id) AS [Schema], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/Database[@Name=' + quotename(db_name(),'''') + ']' + '/Table[@Name=' + quotename(tbl.name,'''') + ' and @Schema=' + quotename(SCHEMA_NAME(tbl.schema_id),'''') + ']' AS [Urn], tbl.create_date AS [CreateDate], CAST(tbl.is_memory_optimized AS bit) AS [IsMemoryOptimized], CAST(CASE idx.type WHEN 5 THEN 1 ELSE 0 END AS bit) AS [HasClusteredColumnStoreIndex], CAST(tbl.is_remote_data_archive_enabled AS bit) AS [RemoteDataArchiveEnabled], tbl.temporal_type AS [TemporalType], CAST(CASE WHEN 'PS'=dsidx.type THEN 1 ELSE 0 END AS bit) AS [IsPartitioned], CAST(         ISNULL((SELECT distinct 1 from sys.all_columns                 WHERE object_id = tbl.object_id                  AND is_sparse = 1), 0)        AS bit) AS [HasSparseColumn], CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type > 1 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasNonClusteredIndex], CAST(CASE idx.index_id WHEN 1 THEN 1 ELSE 0 END AS bit) AS [HasClusteredIndex], CAST(case idx.index_id when 1 then case when (idx.is_primary_key + 2*idx.is_unique_constraint = 1) then 1 else 0 end else 0 end AS bit) AS [HasPrimaryClusteredIndex], CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type = 3 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasXmlIndex], CAST(ISNULL((select top 1 1 from sys.all_columns as clmns join sys.types as usrt on usrt.user_type_id = clmns.user_type_id where clmns.object_id = tbl.object_id and usrt.name = N'xml'), 0) AS bit) AS [HasXmlData], CAST(ISNULL((select top 1 1 from sys.all_columns as clmns join sys.types as usrt on usrt.user_type_id = clmns.user_type_id where clmns.object_id = tbl.object_id and usrt.name in (N'geometry', N'geography')), 0) AS bit) AS [HasSpatialData], CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type = 6 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasNonClusteredColumnStoreIndex] FROM sys.tables AS tbl INNER JOIN sys.indexes AS idx ON          idx.object_id = tbl.object_id and (idx.index_id < @_msparam_0  or (tbl.is_memory_optimized = 1 and idx.index_id = (select min(index_id) from sys.indexes where object_id = tbl.object_id)))        LEFT OUTER JOIN sys.data_spaces AS dsidx ON dsidx.data_space_id = idx.data_space_id WHERE (CAST(  case      when tbl.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = tbl.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit)=@_msparam_1 and tbl.is_filetable=@_msparam_2 and CAST(tbl.is_memory_optimized AS bit)=@_msparam_3 and tbl.temporal_type=@_msparam_4 and CAST(tbl.is_external AS bit)=@_msparam_5)",183,183,0,122601,12,183
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.resource_name like N'%CMH%' 	--and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 1",173,173,0,1409,0,173
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",169,122,47,85895,0,169
"CREATE PROCEDURE [dbo].[sp_syscollector_purge_collection_logs]     @reference_date datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     SET NOCOUNT ON      -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))     BEGIN         RAISERROR(14677, -1, -1, 'dc_proxy')         RETURN(1) -- Failure     END      IF (@reference_date IS NULL)     BEGIN         SET @reference_date = GETDATE()     END          -- An expired log record is any record of a collection set that is older than      -- the reference date minus the collection set's days_until_expiration     CREATE TABLE #purged_log_ids (log_id BIGINT, package_execution_id uniqueidentifier)          -- Identify logs to purge based on following criteria     -- a) limit max batch size      -- b) do not delete last log record that is a root log record for a collection set     INSERT INTO #purged_log_ids     SELECT TOP (@delete_batch_size) log_id, package_execution_id     FROM syscollector_execution_log_internal as l     INNER JOIN syscollector_collection_sets s ON l.collection_set_id = s.collection_set_id     WHERE s.days_until_expiration > 0     AND @reference_date >= DATEADD(DAY, s.days_until_expiration, l.finish_time)     AND log_id NOT IN (                         SELECT TOP 1 log_id  from syscollector_execution_log_internal                          WHERE parent_log_id IS NULL                          AND collection_set_id = l.collection_set_id                         ORDER BY start_time DESC                         )      DECLARE @purge_log_count int     SELECT @purge_log_count  = COUNT(log_id)      FROM  #purged_log_ids      -- Delete all ssis log records pertaining to expired logs     DELETE FROM dbo.sysssislog         FROM dbo.sysssislog AS s         INNER JOIN #purged_log_ids AS i ON i.package_execution_id = s.executionid              -- Then delete the actual logs     DELETE FROM syscollector_execution_log_internal         FROM syscollector_execution_log_internal AS l         INNER Join #purged_log_ids AS i ON i.log_id = l.log_id       DROP TABLE #purged_log_ids      -- making sure that delete # record does not exceed given delete batch size     DECLARE @orphaned_record_cleanup_count int     SET @orphaned_record_cleanup_count = @delete_batch_size - @purge_log_count      -- Go for another round to cleanup the orphans     -- Ideally, the log heirarchy guarantees that a finish time by a parent log will always     -- be higher than the finish time of any of its descendants.     -- The purge step however does not delete log records with a null finish time     -- A child log can have a null finish time while its parent is closed if there is an     -- error in execution that causes the log to stay open.     -- If such a child log exists, its parent will be purged leaving it as an orphan          -- get orphan records and all their descendants in a cursor and purge them     DECLARE orphaned_log_cursor INSENSITIVE CURSOR FOR             SELECT TOP (@orphaned_record_cleanup_count) log_id              FROM syscollector_execution_log_internal             WHERE parent_log_id NOT IN (                 SELECT log_id FROM syscollector_execution_log_internal             )             FOR READ ONLY                  DECLARE @log_id BIGINT      -- for every orphan, delete all its remaining tree     -- this is supposedly a very small fraction of the entire log     OPEN orphaned_log_cursor         FETCH orphaned_log_cursor INTO @log_id     WHILE @@FETCH_STATUS = 0     BEGIN         EXEC sp_syscollector_delete_execution_log_tree @log_id = @log_id, @from_collection_set = 0         FETCH orphaned_log_cursor INTO @log_id     END          CLOSE orphaned_log_cursor     DEALLOCATE orphaned_log_cursor END ",156,247,-91,38888,14,11272
"use mdb;  select  	ca_location.zpost_code ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_company.company_name ,	ca_model_def.name ,	ca_owned_resource.serial_number ,	ca_resource_cost_center.description ,	ca_resource_cost_center.name from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id where ca_resource_cost_center.description like '%CA POS%' 		and (ca_owned_resource.resource_name like '%CMH%' or ca_owned_resource.resource_name like '%CMS%') 	and ca_owned_resource.inactive = 0",156,677,-521,15451,22,156
"CREATE PROCEDURE [core].[sp_purge_data]     @retention_days smallint = NULL,     @instance_name sysname = NULL,     @collection_set_uid uniqueidentifier = NULL,     @duration smallint = NULL,     @delete_batch_size int = 500 AS BEGIN     -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'mdw_admin'), 0) = 1) AND NOT (ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0) = 1))     BEGIN         RAISERROR(14677, 16, -1, 'mdw_admin')         RETURN(1) -- Failure     END      -- Validate parameters     IF ((@retention_days IS NOT NULL) AND (@retention_days < 0))     BEGIN         RAISERROR(14200, -1, -1, '@retention_days')         RETURN(1) -- Failure     END      IF ((@duration IS NOT NULL) AND (@duration < 0))     BEGIN         RAISERROR(14200, -1, -1, '@duration')         RETURN(1) -- Failure     END      -- This table will contain a record if somebody requests purge to stop     -- If user requested us to purge data - we reset the content of it - and proceed with purge     -- If somebody in a different session wants purge operations to stop he adds a record     -- that we will discover while purge in progress     --     -- We dont clear this flag when we exit since multiple purge operations with differnet     -- filters may proceed, and we want all of them to stop.     DELETE FROM [core].[purge_info_internal]      SET @instance_name = NULLIF(LTRIM(RTRIM(@instance_name)), N'')      -- Calculate the time when the operation should stop (NULL otherwise)     DECLARE @end_time datetime     IF (@duration IS NOT NULL)     BEGIN         SET @end_time = DATEADD(minute, @duration, GETUTCDATE())     END      -- Declare table that will be used to find what are the valid     -- candidate snapshots that could be selected for purge     DECLARE @purge_candidates table     (         snapshot_id int NOT NULL,         snapshot_time datetime NOT NULL,         instance_name sysname NOT NULL,         collection_set_uid uniqueidentifier NOT NULL     )      -- Find candidates that match the retention_days criteria (if specified)     IF (@retention_days IS NULL)     BEGIN         -- User did not specified a value for @retention_days, therfore we         -- will use the default expiration day as marked in the source info         INSERT INTO @purge_candidates         SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid         FROM core.snapshots s         WHERE (GETUTCDATE() >= s.valid_through)     END     ELSE     BEGIN         -- User specified a value for @retention_days, we will use this overriden value         -- when deciding what means old enough to qualify for purge this overrides         -- the days_until_expiration value specified in the source_info_internal table         INSERT INTO @purge_candidates         SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid         FROM core.snapshots s         WHERE GETUTCDATE() >= DATEADD(DAY, @retention_days, s.snapshot_time)     END      -- Determine which is the oldest snapshot, from the list of candidates     DECLARE oldest_snapshot_cursor CURSOR FORWARD_ONLY READ_ONLY FOR     SELECT p.snapshot_id, p.instance_name, p.collection_set_uid     FROM @purge_candidates p     WHERE          ((@instance_name IS NULL) or (p.instance_name = @instance_name)) AND         ((@collection_set_uid IS NULL) or (p.collection_set_uid = @collection_set_uid))     ORDER BY p.snapshot_time ASC          OPEN oldest_snapshot_cursor      DECLARE @stop_purge int     DECLARE @oldest_snapshot_id int     DECLARE @oldest_instance_name sysname     DECLARE @oldest_collection_set_uid uniqueidentifier      FETCH NEXT FROM oldest_snapshot_cursor     INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid      -- As long as there are snapshots that matched the time criteria     WHILE @@FETCH_STATUS = 0     BEGIN          -- Filter out records that do not match the other filter crieria         IF ((@instance_name IS NULL) or (@oldest_instance_name = @instance_name))         BEGIN              -- There was no filter specified for instance_name or the instance matches the filter             IF ((@collection_set_uid IS NULL) or (@oldest_collection_set_uid = @collection_set_uid))             BEGIN                  -- There was no filter specified for the collection_set_uid or the collection_set_uid matches the filter                 BEGIN TRANSACTION tran_sp_purge_data                  -- Purge data associated with this snapshot. Note: deleting this snapshot                 -- triggers cascade delete in all warehouse tables based on the foreign key                  -- relationship to snapshots table                  -- Cascade cleanup of all data related referencing oldest snapshot                 DELETE core.snapshots_internal                 FROM core.snapshots_internal s                 WHERE s.snapshot_id = @oldest_snapshot_id                  COMMIT TRANSACTION tran_sp_purge_data                  PRINT 'Snapshot #' + CONVERT(VARCHAR, @oldest_snapshot_id) + ' purged.';             END          END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN                 PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END          -- Move to next oldest snapshot         FETCH NEXT FROM oldest_snapshot_cursor         INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid      END      CLOSE oldest_snapshot_cursor     DEALLOCATE oldest_snapshot_cursor      -- delete orphaned query plans     EXEC [core].[sp_purge_orphaned_notable_query_plan] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size      -- delete orphaned query text     EXEC [core].[sp_purge_orphaned_notable_query_text] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size         END ",154,111,43,72752,794,309
"use mdb;  select  	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_company.company_name ,	ca_model_def.name ,	ca_owned_resource.serial_number ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id where ca_resource_cost_center.description like N'%สำนักงาน%' 	and ca_owned_resource.inactive = 0",147,290,-143,15552,61,147
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",141,141,0,25919,8,3530
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], s1ret_param.name AS [DataTypeSchema] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",135,134,1,14550,3,407
"(@_msparam_0 nvarchar(4000))SELECT bkps.name AS [Name], bkps.backup_set_id AS [ID], bkps.backup_set_uuid AS [BackupSetUuid], bkps.media_set_id AS [MediaSetId], bkps.first_family_number AS [FirstFamilyNumber], bkps.first_media_number AS [FirstMediaNumber], bkps.last_family_number AS [LastFamilyNumber], bkps.last_media_number AS [LastMediaNumber], bkps.catalog_family_number AS [CatalogFamilyNumber], bkps.catalog_media_number AS [CatalogMediaNumber], bkps.position AS [Position], bkps.expiration_date AS [ExpirationDate], bkps.software_vendor_id AS [SoftwareVendorId], bkps.description AS [Description], bkps.user_name AS [UserName], bkps.software_major_version AS [SoftwareMajorVersion], bkps.software_minor_version AS [SoftwareMinorVersion], bkps.software_build_version AS [SoftwareBuildVersion], bkps.time_zone AS [TimeZone], bkps.mtf_minor_version AS [MtfMinorVersion], bkps.first_lsn AS [FirstLsn], bkps.last_lsn AS [LastLsn], bkps.checkpoint_lsn AS [CheckpointLsn], bkps.database_backup_lsn AS [DatabaseBackupLsn], bkps.database_creation_date AS [DatabaseCreationDate], bkps.backup_start_date AS [BackupStartDate], bkps.backup_finish_date AS [BackupFinishDate], CASE bkps.type WHEN 'D' THEN 1 WHEN 'I' THEN 2 WHEN 'L' THEN 3 WHEN 'F' THEN 4 WHEN 'G' THEN 5 END AS [BackupSetType], bkps.sort_order AS [SortOrder], bkps.code_page AS [CodePage], bkps.compatibility_level AS [CompatibilityLevel], bkps.database_version AS [DatabaseVersion], bkps.backup_size AS [BackupSize], bkps.database_name AS [DatabaseName], bkps.server_name AS [ServerName], bkps.machine_name AS [MachineName], bkps.flags AS [BackupSetFlags], bkps.unicode_locale AS [UnicodeLocale], bkps.unicode_compare_style AS [UnicodeCompareStyle], bkps.collation_name AS [CollationName], bkps.is_damaged AS [IsDamaged], bkps.is_copy_only AS [IsCopyOnly], bkps.is_snapshot AS [IsSnapShot], bkps.is_readonly AS [IsReadOnly], bkps.is_password_protected AS [IsPasswordProtected], bkps.has_incomplete_metadata AS [HasIncompleteMetaData], bkps.has_bulk_logged_data AS [HasBulkLoggedData], bkps.begins_log_chain AS [BeginsLogChain], bkps.is_force_offline AS [IsForceOffline], bkps.database_guid AS [DatabaseGuid], bkps.differential_base_guid AS [DifferentialBaseGuid], bkps.first_recovery_fork_guid AS [FirstRecoveryForkID], bkps.last_recovery_fork_guid AS [RecoveryForkID], bkps.family_guid AS [FamilyGuid], bkps.fork_point_lsn AS [ForkPointLsn], bkps.differential_base_lsn AS [DifferentialBaseLsn], bkps.compressed_backup_size AS [CompressedBackupSize], bkps.key_algorithm AS [KeyAlgorithm], bkps.encryptor_thumbprint AS [EncryptorThumbprint], bkps.encryptor_type AS [EncryptorType] FROM msdb.dbo.backupset bkps WHERE (bkps.database_name=@_msparam_0) ORDER BY [BackupFinishDate] DESC",126,57,69,2606,0,1264
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.resource_name like N'%CMH%' 	and ca_owned_resource.inactive = 0",120,483,-363,31712,0,120
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_model_def.name ,	ca_resource_cost_center.name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						--left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.resource_name like N'%CMH%' 	--and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 0",119,513,-394,31712,0,119
SELECT usp_itsm_msg_queue.id FROM usp_itsm_msg_queue WHERE ( ( usp_itsm_msg_queue.status = 0 AND usp_itsm_msg_queue.retries < 20 ) OR ( usp_itsm_msg_queue.status = 1 AND usp_itsm_msg_queue.timestamp <= 1709252624 ) ),119,296,-177,7964,0,119
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(v.schema_id) AS [Schema], v.name AS [Name], v.object_id AS [ID] FROM sys.all_views AS v WHERE (v.type = @_msparam_0) ORDER BY [Schema] ASC,[Name] ASC",109,107,2,47,0,109
SELECT usp_itsm_msg_queue.id FROM usp_itsm_msg_queue WHERE ( ( usp_itsm_msg_queue.status = 0 AND usp_itsm_msg_queue.retries < 20 ) OR ( usp_itsm_msg_queue.status = 1 AND usp_itsm_msg_queue.timestamp <= 1709256224 ) ),109,277,-168,7964,0,109
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",103,102,1,82418,0,415
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",102,102,0,26837,0,2563
SELECT usp_itsm_msg_queue.id FROM usp_itsm_msg_queue WHERE ( ( usp_itsm_msg_queue.status = 0 AND usp_itsm_msg_queue.retries < 20 ) OR ( usp_itsm_msg_queue.status = 1 AND usp_itsm_msg_queue.timestamp <= 1709254424 ) ),100,272,-172,7964,0,100
SELECT usp_itsm_msg_queue.id FROM usp_itsm_msg_queue WHERE ( ( usp_itsm_msg_queue.status = 0 AND usp_itsm_msg_queue.retries < 20 ) OR ( usp_itsm_msg_queue.status = 1 AND usp_itsm_msg_queue.timestamp <= 1709259824 ) ),99,282,-183,7964,0,99
"CREATE PROCEDURE [dbo].[sp_syscollector_purge_collection_logs]     @reference_date datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     SET NOCOUNT ON      -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))     BEGIN         RAISERROR(14677, -1, -1, 'dc_proxy')         RETURN(1) -- Failure     END      IF (@reference_date IS NULL)     BEGIN         SET @reference_date = GETDATE()     END          -- An expired log record is any record of a collection set that is older than      -- the reference date minus the collection set's days_until_expiration     CREATE TABLE #purged_log_ids (log_id BIGINT, package_execution_id uniqueidentifier)          -- Identify logs to purge based on following criteria     -- a) limit max batch size      -- b) do not delete last log record that is a root log record for a collection set     INSERT INTO #purged_log_ids     SELECT TOP (@delete_batch_size) log_id, package_execution_id     FROM syscollector_execution_log_internal as l     INNER JOIN syscollector_collection_sets s ON l.collection_set_id = s.collection_set_id     WHERE s.days_until_expiration > 0     AND @reference_date >= DATEADD(DAY, s.days_until_expiration, l.finish_time)     AND log_id NOT IN (                         SELECT TOP 1 log_id  from syscollector_execution_log_internal                          WHERE parent_log_id IS NULL                          AND collection_set_id = l.collection_set_id                         ORDER BY start_time DESC                         )      DECLARE @purge_log_count int     SELECT @purge_log_count  = COUNT(log_id)      FROM  #purged_log_ids      -- Delete all ssis log records pertaining to expired logs     DELETE FROM dbo.sysssislog         FROM dbo.sysssislog AS s         INNER JOIN #purged_log_ids AS i ON i.package_execution_id = s.executionid              -- Then delete the actual logs     DELETE FROM syscollector_execution_log_internal         FROM syscollector_execution_log_internal AS l         INNER Join #purged_log_ids AS i ON i.log_id = l.log_id       DROP TABLE #purged_log_ids      -- making sure that delete # record does not exceed given delete batch size     DECLARE @orphaned_record_cleanup_count int     SET @orphaned_record_cleanup_count = @delete_batch_size - @purge_log_count      -- Go for another round to cleanup the orphans     -- Ideally, the log heirarchy guarantees that a finish time by a parent log will always     -- be higher than the finish time of any of its descendants.     -- The purge step however does not delete log records with a null finish time     -- A child log can have a null finish time while its parent is closed if there is an     -- error in execution that causes the log to stay open.     -- If such a child log exists, its parent will be purged leaving it as an orphan          -- get orphan records and all their descendants in a cursor and purge them     DECLARE orphaned_log_cursor INSENSITIVE CURSOR FOR             SELECT TOP (@orphaned_record_cleanup_count) log_id              FROM syscollector_execution_log_internal             WHERE parent_log_id NOT IN (                 SELECT log_id FROM syscollector_execution_log_internal             )             FOR READ ONLY                  DECLARE @log_id BIGINT      -- for every orphan, delete all its remaining tree     -- this is supposedly a very small fraction of the entire log     OPEN orphaned_log_cursor         FETCH orphaned_log_cursor INTO @log_id     WHILE @@FETCH_STATUS = 0     BEGIN         EXEC sp_syscollector_delete_execution_log_tree @log_id = @log_id, @from_collection_set = 0         FETCH orphaned_log_cursor INTO @log_id     END          CLOSE orphaned_log_cursor     DEALLOCATE orphaned_log_cursor END ",97,97,0,51627,107,25567
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       t.object_type,       i.is_disabled     ",97,97,0,5846,0,2741
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",97,73,24,82134,0,97
SELECT target_data 									FROM sys.dm_xe_session_targets xet WITH(nolock) 									JOIN sys.dm_xe_sessions xes WITH(nolock) 									ON xes.address = xet.event_session_address 									WHERE xes.name = 'telemetry_xevents' 									AND xet.target_name = 'ring_buffer',94,92,2,0,0,1441987
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id where ca_resource_cost_center.description not like N'%สำนักงาน%' 	and ca_owned_resource.resource_name like N'%CMS%' 	--and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') 	and ca_owned_resource.inactive = 1",93,483,-390,22059,0,186
"SELECT 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/Collation[@Name=' + quotename(cl.name,'''') + ']' AS [Urn], cl.name AS [Name], CAST(COLLATIONPROPERTY(name, 'CodePage') AS int) AS [CodePage], CAST(COLLATIONPROPERTY(name, 'LCID') AS int) AS [LocaleID], CAST(COLLATIONPROPERTY(name, 'ComparisonStyle') AS int) AS [ComparisonStyle], cl.description AS [Description], CAST(COLLATIONPROPERTY(name, 'Version') AS int) AS [CollationVersion] FROM sys.fn_helpcollations() cl ORDER BY [Name] ASC",84,82,2,0,0,254
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",78,75,3,82127,0,235
"use mdb;  select 	ca_owned_resource.resource_name ,	ca_location.location_name ,	ca_owned_resource.resource_description ,	ca_owned_resource.serial_number ,	ca_company.company_name ,	ca_resource_cost_center.description ,	ca_contact.last_name ,	FORMAT(dateadd(s, usp_owned_resource.nr_wrty_end_dt, '1970-01-01 07:00'), 'dd-MM-yyyy') from ca_owned_resource	left join ca_location on ca_owned_resource.location_uuid = ca_location.location_uuid 						left join ca_contact	on ca_owned_resource.resource_contact_uuid = ca_contact.contact_uuid 						left join ca_company on ca_owned_resource.manufacturer_uuid = ca_company.company_uuid 						left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 						left join usp_owned_resource on ca_owned_resource.own_resource_uuid = usp_owned_resource.owned_resource_uuid 						left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id 						left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid --where ca_resource_cost_center.description not like N'%สำนักงาน%' --	--and ca_owned_resource.resource_name like N'%CMS%' --	and ca_resource_class.name in (N'เครื่องคอมพิวเตอร์ลูกข่าย', N'เครื่องคอมพิวเตอร์แม่ข่าย') --	and ca_owned_resource.inactive = 1 where ca_model_def.name = 'APC-F150'",77,532,-455,19823,0,77
use mdb;  select distinct(ca_model_def.name) from ca_owned_resource left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid,70,69,1,545,0,70
"declare @tmp_sp_help_jobhistory table (     instance_id int null,      job_id uniqueidentifier null,      job_name sysname null,      step_id int null,      step_name sysname null,      sql_message_id int null,      sql_severity int null,      message nvarchar(4000) null,      run_status int null,      run_date int null,      run_time int null,      run_duration int null,      operator_emailed sysname null,      operator_netsent sysname null,      operator_paged sysname null,      retries_attempted int null,      server sysname null   )  insert into @tmp_sp_help_jobhistory  exec msdb.dbo.sp_help_jobhistory      @job_id = 'd158c291-4d2b-4672-85c1-a699fee1e0d5',     @mode='FULL'           SELECT     tshj.instance_id AS [InstanceID],     tshj.sql_message_id AS [SqlMessageID],     tshj.message AS [Message],     tshj.step_id AS [StepID],     tshj.step_name AS [StepName],     tshj.sql_severity AS [SqlSeverity],     tshj.job_id AS [JobID],     tshj.job_name AS [JobName],     tshj.run_status AS [RunStatus],     CASE tshj.run_date WHEN 0 THEN NULL ELSE     convert(datetime,              stuff(stuff(cast(tshj.run_date as nchar(8)), 7, 0, '-'), 5, 0, '-') + N' ' +              stuff(stuff(substring(cast(1000000 + tshj.run_time as nchar(7)), 2, 6), 5, 0, ':'), 3, 0, ':'),              120) END AS [RunDate],     tshj.run_duration AS [RunDuration],     tshj.operator_emailed AS [OperatorEmailed],     tshj.operator_netsent AS [OperatorNetsent],     tshj.operator_paged AS [OperatorPaged],     tshj.retries_attempted AS [RetriesAttempted],     tshj.server AS [Server],     getdate() as [CurrentDate] FROM @tmp_sp_help_jobhistory as tshj ORDER BY [InstanceID] ASC",61,58,3,2292,17,61
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))SELECT clmns.column_id AS [ID], clmns.name AS [Name], ISNULL(dc.Name, N'') AS [DefaultConstraintName], clmns.is_nullable AS [Nullable], CAST(ISNULL(cik.index_column_id, 0) AS bit) AS [InPrimaryKey], clmns.is_identity AS [Identity], usrt.name AS [DataType], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND clmns.max_length <> -1 THEN clmns.max_length/2 ELSE clmns.max_length END AS int) AS [Length], CAST(clmns.precision AS int) AS [NumericPrecision], CAST(clmns.scale AS int) AS [NumericScale], ISNULL(xscclmns.name, N'') AS [XmlSchemaNamespace], ISNULL(s2clmns.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case clmns.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], s1clmns.name AS [DataTypeSchema] FROM sys.tables AS tbl INNER JOIN sys.all_columns AS clmns ON clmns.object_id=tbl.object_id LEFT OUTER JOIN sys.default_constraints as dc ON clmns.default_object_id = dc.object_id LEFT OUTER JOIN sys.indexes AS ik ON ik.object_id = clmns.object_id and 1=ik.is_primary_key LEFT OUTER JOIN sys.index_columns AS cik ON cik.index_id = ik.index_id and cik.column_id = clmns.column_id and cik.object_id = clmns.object_id and 0 = cik.is_included_column LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = clmns.user_type_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = clmns.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = clmns.system_type_id) and (baset.user_type_id = clmns.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscclmns ON xscclmns.xml_collection_id = clmns.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2clmns ON s2clmns.schema_id = xscclmns.schema_id LEFT OUTER JOIN sys.schemas AS s1clmns ON s1clmns.schema_id = usrt.schema_id WHERE (tbl.name=@_msparam_0 and SCHEMA_NAME(tbl.schema_id)=@_msparam_1) ORDER BY [ID] ASC",60,60,0,981,0,1393
use mdb;  select distinct(ca_model_def.name) from ca_owned_resource left join ca_model_def on ca_owned_resource.model_uuid = ca_model_def.model_uuid order by ca_model_def.name,58,58,0,545,0,58
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], s1ret_param.name AS [DataTypeSchema] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",56,51,5,10187,0,56
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0   ",53,51,2,2326,0,53
"(@P1 date,@P2 nvarchar(4000))select	dateadd(s, call_req.open_date, '1970-01-01 07:00') open_date, 		call_req.ref_num, 		call_req.summary, 		call_req.status, 		ca_owned_resource.resource_name, 		ca_resource_class.name class, 		ca_owned_resource.serial_number, 		ca_company.company_name vendor from call_req	left join ca_owned_resource on call_req.affected_rc = ca_owned_resource.own_resource_uuid 				left join ca_resource_cost_center on ca_owned_resource.cost_center = ca_resource_cost_center.id 				left join ca_resource_class on ca_owned_resource.resource_class = ca_resource_class.id 				left join ca_company on ca_owned_resource.supply_vendor_uuid = ca_company.company_uuid 				left join ca_contact on call_req.group_id = ca_contact.contact_uuid where	call_req.status not in ('RE','CL') and 		ca_contact.last_name = 'Outsource' and 		dateadd(s, call_req.open_date, '1970-01-01 07:00') < @P1  and 		ca_resource_cost_center.name = @P2  order by dateadd(s, call_req.open_date, '1970-01-01 07:00')",51,51,0,3018,0,257
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",50,47,3,2257,0,50
FETCH API_CURSOR00000000000013D1 ,49,40,9,52167,0,2666
"       SELECT DB_ID() AS database_id,       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       COUNT_BIG(*) AS NumTables       FROM sys.tables WITH(nolock)       GROUP BY       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type     ",44,40,4,5553,0,1065
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], s1ret_param.name AS [DataTypeSchema] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",43,43,0,7828,0,130
FETCH API_CURSOR0000000000001420 ,42,38,4,53092,0,171
FETCH API_CURSOR0000000000001405 ,41,41,0,52785,0,1490
FETCH API_CURSOR00000000000013EF ,41,41,0,52139,0,82
" DECLARE @dbsize bigint  DECLARE @logsize bigint  DECLARE @ftsize bigint  DECLARE @reservedpages bigint  DECLARE @pages bigint  DECLARE @usedpages bigint  SELECT @dbsize = SUM(convert(bigint,case when type = 0 then size else 0 end))        ,@logsize = SUM(convert(bigint,case when type = 1 then size else 0 end))        ,@ftsize = SUM(convert(bigint,case when type = 4 then size else 0 end))  FROM sys.database_files  DECLARE @allocateUnits table(          total_pages bigint ,       used_pages bigint ,       data_pages bigint ,       container_id bigint ,       type tinyint );   INSERT @allocateUnits SELECT total_pages, used_pages, data_pages, container_id, type FROM sys.allocation_units;  SELECT @reservedpages = SUM(a.total_pages)         ,@usedpages = SUM(a.used_pages)         ,@pages = SUM(CASE                          WHEN it.internal_type IN (202,204) THEN 0                          WHEN a.type != 1 THEN a.used_pages                          WHEN p.index_id < 2 THEN a.data_pages                          ELSE 0                       END)  FROM sys.partitions p   JOIN @allocateUnits a ON p.partition_id = a.container_id  LEFT JOIN sys.internal_tables it ON p.object_id = it.object_id   SELECT          @dbsize as 'dbsize',         @logsize as 'logsize',         @ftsize as 'ftsize',         @reservedpages as 'reservedpages',         @usedpages as 'usedpages',         @pages as 'pages' ",40,40,0,19555,31,5155
FETCH API_CURSOR00000000000013FE ,40,40,0,52701,0,566
FETCH API_CURSOR000000000000140F ,39,39,0,52779,0,79
FETCH API_CURSOR000000000000141B ,39,39,0,53191,0,317
FETCH API_CURSOR000000000000140D ,39,39,0,52803,0,79
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000))SELECT tbl.name AS [Name], SCHEMA_NAME(tbl.schema_id) AS [Schema], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/Database[@Name=' + quotename(db_name(),'''') + ']' + '/Table[@Name=' + quotename(tbl.name,'''') + ' and @Schema=' + quotename(SCHEMA_NAME(tbl.schema_id),'''') + ']' AS [Urn], tbl.create_date AS [CreateDate], CAST(tbl.is_memory_optimized AS bit) AS [IsMemoryOptimized], CAST(CASE idx.type WHEN 5 THEN 1 ELSE 0 END AS bit) AS [HasClusteredColumnStoreIndex], CAST(tbl.is_remote_data_archive_enabled AS bit) AS [RemoteDataArchiveEnabled], tbl.temporal_type AS [TemporalType], CAST(CASE WHEN 'PS'=dsidx.type THEN 1 ELSE 0 END AS bit) AS [IsPartitioned], CAST(         ISNULL((SELECT distinct 1 from sys.all_columns                 WHERE object_id = tbl.object_id                  AND is_sparse = 1), 0)        AS bit) AS [HasSparseColumn], CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type > 1 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasNonClusteredIndex], CAST(CASE idx.index_id WHEN 1 THEN 1 ELSE 0 END AS bit) AS [HasClusteredIndex], CAST(case idx.index_id when 1 then case when (idx.is_primary_key + 2*idx.is_unique_constraint = 1) then 1 else 0 end else 0 end AS bit) AS [HasPrimaryClusteredIndex], CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type = 3 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasXmlIndex], CAST(ISNULL((select top 1 1 from sys.all_columns as clmns join sys.types as usrt on usrt.user_type_id = clmns.user_type_id where clmns.object_id = tbl.object_id and usrt.name = N'xml'), 0) AS bit) AS [HasXmlData], CAST(ISNULL((select top 1 1 from sys.all_columns as clmns join sys.types as usrt on usrt.user_type_id = clmns.user_type_id where clmns.object_id = tbl.object_id and usrt.name in (N'geometry', N'geography')), 0) AS bit) AS [HasSpatialData], CAST(ISNULL((select top 1 1 from sys.indexes ind where ind.object_id = tbl.object_id and ind.type = 6 and ind.is_hypothetical = 0 ), 0) AS bit) AS [HasNonClusteredColumnStoreIndex] FROM sys.tables AS tbl INNER JOIN sys.indexes AS idx ON          idx.object_id = tbl.object_id and (idx.index_id < @_msparam_0  or (tbl.is_memory_optimized = 1 and idx.index_id = (select min(index_id) from sys.indexes where object_id = tbl.object_id)))        LEFT OUTER JOIN sys.data_spaces AS dsidx ON dsidx.data_space_id = idx.data_space_id WHERE (CAST(  case      when tbl.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = tbl.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit)=@_msparam_1 and tbl.is_filetable=@_msparam_2 and CAST(tbl.is_memory_optimized AS bit)=@_msparam_3 and tbl.temporal_type=@_msparam_4 and CAST(tbl.is_external AS bit)=@_msparam_5)",39,39,0,22040,2,39
FETCH API_CURSOR0000000000001419 ,39,39,0,53137,0,631
FETCH API_CURSOR000000000000141D ,39,39,0,53169,0,236
FETCH API_CURSOR0000000000001400 ,39,39,0,52810,0,944
FETCH API_CURSOR000000000000141C ,39,39,0,53191,0,234
FETCH API_CURSOR00000000000013F0 ,39,39,0,52325,0,156
FETCH API_CURSOR0000000000001401 ,38,38,0,52790,0,855
FETCH API_CURSOR00000000000013D4 ,38,38,0,52186,0,1088
"       SELECT DB_ID() AS database_id, COUNT_BIG(DISTINCT ic.object_id) as table_count       FROM  sys.index_columns ic WITH(nolock)       INNER JOIN sys.columns col WITH(nolock) ON ic.object_id = col.object_id and ic.column_id = col.column_id       WHERE col.system_type_id = 241     ",38,38,0,371,0,1163
FETCH API_CURSOR000000000000140E ,38,38,0,52907,0,154
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount]       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END     ",38,38,0,100,0,38
FETCH API_CURSOR00000000000013E9 ,38,38,0,52059,0,382
FETCH API_CURSOR0000000000001402 ,38,38,0,52786,0,916
FETCH API_CURSOR0000000000001423 ,37,37,0,53164,0,150
FETCH API_CURSOR0000000000001422 ,37,37,0,53147,0,74
FETCH API_CURSOR00000000000013D3 ,37,37,0,52209,0,1117
FETCH API_CURSOR00000000000013D5 ,37,37,0,52171,0,1040
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info;",37,37,0,2399,0,37
FETCH API_CURSOR00000000000013D6 ,36,36,0,48735,0,957
FETCH API_CURSOR0000000000001403 ,36,36,0,49301,0,366
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info; ",36,36,0,2350,0,36
FETCH API_CURSOR00000000000013F1 ,36,36,0,52243,0,145
FETCH API_CURSOR0000000000001406 ,36,36,0,49328,0,582
FETCH API_CURSOR0000000000001424 ,35,35,0,53141,0,141
FETCH API_CURSOR00000000000013FF ,35,35,0,46792,0,1558
FETCH API_CURSOR00000000000013EB ,35,35,0,48728,0,212
FETCH API_CURSOR000000000000141E ,35,35,0,49675,0,212
