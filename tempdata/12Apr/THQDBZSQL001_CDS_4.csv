" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",853967,879463,-25496,402519512,525075,853967
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",144150,135620,8530,42948623,66255,144150
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",135595,120221,15374,31737561,203215,135595
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",78307,103238,-24931,28617708,742331,78307
" CREATE TRIGGER TRG_DECLARATIONS_DELETE_COUNTER ON O_DECLARATIONS AFTER DELETE AS BEGIN 	SET NOCOUNT ON;  	DECLARE @DeletedItems TABLE ( 		itemkey NVARCHAR(max) 		,deleleditems NVARCHAR(max) 		,keyhash NVARCHAR(max) 		,oldvaluehash NVARCHAR(max) 		,oldvalue NVARCHAR(max) 		)  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Inbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.DEST_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG (CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash,'', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END  	DELETE 	FROM @DeletedItems;  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Outbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.ORIG_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG(CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash, '', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END END ",64497,32773,31724,9429876,37,128994
" CREATE TRIGGER TRG_DECLARATIONS_DELETE_COUNTER ON O_DECLARATIONS AFTER DELETE AS BEGIN 	SET NOCOUNT ON;  	DECLARE @DeletedItems TABLE ( 		itemkey NVARCHAR(max) 		,deleleditems NVARCHAR(max) 		,keyhash NVARCHAR(max) 		,oldvaluehash NVARCHAR(max) 		,oldvalue NVARCHAR(max) 		)  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Inbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.DEST_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG (CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash,'', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END  	DELETE 	FROM @DeletedItems;  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Outbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.ORIG_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG(CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash, '', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END END ",33993,33120,873,9434357,22,67987
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",13370,21620,-8250,5676316,80071,13370
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",4194,13594,-9400,373796,3207,4194
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",2987,6205,-3218,27432,3533,2987
"  Create PROCEDURE [dbo].[USP_GET_REFERRALS_BY_DECISION_INB] 	@CurrentOrgCode varchar(3), 	@MailFlowCd char(1), 	@DateFrom datetime, 	@DateTo datetime, 	@CustomsDecisionCd varchar(10) AS BEGIN 	set quoted_identifier on  	IF @DateFrom is null 	BEGIN 		set @DateFrom = CAST(GETDATE() as date) 	END  	IF @DateTo is null 	BEGIN 		set @DateTo = GETDATE() 	END 	ELSE 	BEGIN 		set @DateTo = DATEADD(day, 1, @DateTo) 	END  	;WITH D(RespPId, EventDt)  	AS 	( 		SELECT DISTINCT RESPONSE_PID, max(R_EVENT_GMT_DT) 		FROM O_RESPONSE_EVENTS 		where CDS_EVENT_TYPE_CD in (59, 60, 61, 62) 	 		group by RESPONSE_PID 		having max(R_EVENT_GMT_DT) >= @DateFrom and max(R_EVENT_GMT_DT) <= @DateTo 	)  	SELECT mo.MAIL_OBJECT_PID as MailObjectPId, 			mo.MAIL_OBJECT_ID as MailItemId, 			oo.COUNTRY_CD as OriginCountryCd, 			od.COUNTRY_CD as DestinationCountryCd, 			dcro.RESPONSE_PID as ResponsePId, 			convert(xml,convert(varchar(max), dcro.DATA)) as ResponseData, 			dcro.POST_ORGANIZATION_CD as PostOrganizationCd, 			dcro.CUST_ORGANIZATION_CD as CustOrganizationCd 	FROM O_MAIL_OBJECTS mo 	INNER JOIN M_ORGANIZATIONS oo ON (oo.ORGANIZATION_CD = mo.ORIG_POST_ORGANIZATION_CD) 	INNER JOIN M_ORGANIZATIONS od ON (od.ORGANIZATION_CD = mo.DEST_POST_ORGANIZATION_CD) 	inner join O_RESPONSES dcro on dcro.MAIL_OBJECT_PID = mo.MAIL_OBJECT_PID and dcro.POST_ORGANIZATION_CD = mo.DEST_POST_ORGANIZATION_CD 		and dcro.CUST_ORGANIZATION_CD = (select top 1 CUST_ORGANIZATION_CD from M_ORGANIZATIONS dorg WITH (NOLOCK) where dorg.ORGANIZATION_CD = mo.DEST_POST_ORGANIZATION_CD) 	inner join M_CUSTOMS_DECISIONS cd on cd.CUSTOMS_DECISION_CD = CAST(dcro.data.query('data(/ResData/@Decis)') as varchar(10)) 	INNER JOIN M_CUSTOMS_REFERRALS rf on cd.CUSTOMS_DECISION_CD = rf.CUSTOMS_DECISION_CD 	INNER JOIN D on d.RespPId = dcro.RESPONSE_PID 	WHERE mo.ORIG_POST_ORGANIZATION_CD = @CurrentOrgCode AND (mo.MAIL_FLOW_CD = @MailFlowCd OR mo.MAIL_FLOW_CD IS NULL)  		and (@CustomsDecisionCd is null or cd.CUSTOMS_DECISION_CD = @CustomsDecisionCd)  	UNION all 	 	SELECT mo.MAIL_OBJECT_PID as PId, 			mo.MAIL_OBJECT_ID as Id, 			oo.COUNTRY_CD as OriginCountryCd, 			od.COUNTRY_CD as DestinationCountryCd,  			dcro.RESPONSE_PID as ResponsePId, 			convert(xml,convert(varchar(max), hist.DATA)) as ResponseData, 			dcro.POST_ORGANIZATION_CD as PostOrganizationCd, 			dcro.CUST_ORGANIZATION_CD as CustOrganizationCd 	FROM O_MAIL_OBJECTS mo 	INNER JOIN M_ORGANIZATIONS oo ON (oo.ORGANIZATION_CD = mo.ORIG_POST_ORGANIZATION_CD) 	INNER JOIN M_ORGANIZATIONS od ON (od.ORGANIZATION_CD = mo.DEST_POST_ORGANIZATION_CD) 	inner join O_RESPONSES dcro on dcro.MAIL_OBJECT_PID = mo.MAIL_OBJECT_PID and dcro.POST_ORGANIZATION_CD = mo.DEST_POST_ORGANIZATION_CD 		and dcro.CUST_ORGANIZATION_CD = (select top 1 CUST_ORGANIZATION_CD from M_ORGANIZATIONS dorg WITH (NOLOCK) where dorg.ORGANIZATION_CD = mo.DEST_POST_ORGANIZATION_CD) 	left outer join O_RESPONSES_HIST hist on hist.RESPONSE_PID = dcro.RESPONSE_PID  		and hist.CDS_EVENT_TYPE_CD in (59, 60, 61, 62)  		and hist.R_EVENT_GMT_DT >= @DateFrom and hist.R_EVENT_GMT_DT <= @DateTo  	inner join M_CUSTOMS_DECISIONS cd on cd.CUSTOMS_DECISION_CD = CAST(hist.data.query('data(/ResData/@Decis)') as varchar(10)) 	INNER JOIN M_CUSTOMS_REFERRALS rf on cd.CUSTOMS_DECISION_CD = rf.CUSTOMS_DECISION_CD	 	WHERE mo.ORIG_POST_ORGANIZATION_CD = @CurrentOrgCode AND (mo.MAIL_FLOW_CD = @MailFlowCd OR mo.MAIL_FLOW_CD IS NULL)  		and (@CustomsDecisionCd is null or cd.CUSTOMS_DECISION_CD = @CustomsDecisionCd) END ",1731,7547,-5816,2874959,644,31160
"SELECT M.MAIL_OBJECT_ID, convert(varchar, M.POSTING_DATE, 120) POSTING_DATE FROM O_MAIL_OBJECTS M join O_DECLARATIONS D ON(M.MAIL_OBJECT_PID = D.MAIL_OBJECT_PID) where DATEDIFF(hour, M.POSTING_DATE, GETDATE()) >= 5 AND M.ORIG_POST_ORGANIZATION_CD = 'THA' AND M.DEST_POST_ORGANIZATION_CD IN (select E.RECIPIENT_ORGANIZATION_CD from M_EDI_EXCHANGES E) AND DATEDIFF(DAY, M.POSTING_DATE, GETDATE()) <= 30 AND M.MAIL_FLOW_CD = 'O' AND D.CDS_STATE_CD = 2 AND M.MAIL_OBJECT_ID not in (SELECT M.MAIL_OBJECT_ID FROM O_MAIL_OBJECTS M join O_DECLARATIONS D ON(M.MAIL_OBJECT_PID = D.MAIL_OBJECT_PID) where M.ORIG_POST_ORGANIZATION_CD = 'THA' AND DATEDIFF(DAY, M.POSTING_DATE, GETDATE()) <= 30 AND D.CDS_STATE_CD = 5) ORDER BY convert(varchar, M.POSTING_DATE, 120) DESC ",910,5912,-5002,172019,0,10010
" 	SELECT 	CASE 		WHEN name like  '%msdtcprx.dll%' THEN 'msdtcprx' 		WHEN name like  '%sqljdbc_xa.dll%' THEN 'sqljdbc_xa' 		ELSE NULL 	END AS LoadedModules, 	COUNT(1) AS ModuleCount         FROM sys.dm_os_loaded_modules WITH (NOLOCK)         WHERE name like  '%msdtcprx.dll%' 	OR name like  '%sqljdbc_xa.dll%'         GROUP BY 	CASE WHEN name like  '%msdtcprx.dll%' THEN 'msdtcprx' 		WHEN name like  '%sqljdbc_xa.dll%' THEN 'sqljdbc_xa' 		ELSE NULL 	END;     ",640,640,0,28,0,640
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], s1ret_param.name AS [DataTypeSchema] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",631,277,354,80240,6,631
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",588,3380,-2792,14289,0,702189
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",538,3039,-2501,31265,0,538
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info;",454,454,0,12692,0,454
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",335,1767,-1432,38838,0,1005
FETCH API_CURSOR000000000000C590 ,284,86,198,46003,0,569
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",250,221,29,134863,628,60561
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",240,240,0,3535,0,240
SELECT target_data 									FROM sys.dm_xe_session_targets xet WITH(nolock) 									JOIN sys.dm_xe_sessions xes WITH(nolock) 									ON xes.address = xet.event_session_address 									WHERE xes.name = 'telemetry_xevents' 									AND xet.target_name = 'ring_buffer',209,167,42,0,0,267150
" CREATE PROCEDURE dbo.USP_SET_EVENT 	@PId			uniqueidentifier,	 	@ObjectType		char(1), 	@EvtCd			smallint, 	@EvtGmtDt		datetime, 	@LocalOffset	smallint, 	@UserCd			varchar(16), 	@OfficeCd		varchar(10) as Begin 	if @ObjectType = 'D' 	begin 		insert O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD) 		values(@PId, @EvtCd, @EvtGmtDt, @LocalOffset, @UserCd, @OfficeCd) 	end 	else 	begin 		insert O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD) 		values(@PId, @EvtCd, @EvtGmtDt, @LocalOffset, @UserCd, @OfficeCd) 	end  	select 		@PId as PId, 		@EvtCd as EventCd, 		@EvtGmtDt as EventGmtDt, 		@LocalOffset as EventLocalOffset, 		@UserCd	as [User], 		@OfficeCd as Office, 		null as HistoricalXmlData End ",82,0,82,28,0,647895
" CREATE PROCEDURE dbo.USP_SET_DECLARATION 	 	@PId					uniqueidentifier,	 	@MailObjectPId			uniqueidentifier, 	@XMLData				xml, 	@PostOrganizationCd		varchar(5), 	@CustOrganizationCd		varchar(5), 	@CDSStateCd				tinyint,  	@EvtCd					smallint, 	@EvtGmtDt				datetime, 	@LocalOffset			smallint, 	@AnonymousDeclId		varchar(13) = NULL, 	@UserCd					varchar(64), 	@OfficeCd				varchar(10) 	 as 	declare @inserted table( pid uniqueidentifier)				 		 	select @CDSStateCd = RESULTING_STATE_CD from M_CDS_EVENT_TYPES (nolock) where CDS_EVENT_TYPE_CD = @EvtCd  	if @PId is not null 	begin 		declare @CopyHist		bit 		declare @PrevEvtCd		smallint 		declare @PrevEvtGmtDt	datetime 		 		select top 1 @CopyHist = et.COPY_TO_HIST, @PrevEvtCd = de.CDS_EVENT_TYPE_CD, @PrevEvtGmtDt = de.D_EVENT_GMT_DT 		from O_DECLARATION_EVENTS de (nolock) inner join M_CDS_EVENT_TYPES et (nolock) on et.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD 		where de.DECLARATION_PID = @PId  		order by D_EVENT_GMT_DT desc 		 		if @CopyHist = 1 		begin 			if not exists(select 1 from O_DECLARATIONS_HIST where DECLARATION_PID = @PId and CDS_EVENT_TYPE_CD = @PrevEvtCd and D_EVENT_GMT_DT = @PrevEvtGmtDt) 				insert into O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA) 				select @PId, @PrevEvtCd, @PrevEvtGmtDt, DATA 				from O_DECLARATIONS (nolock) 				where DECLARATION_PID = @PId							 		end 				 		update O_DECLARATIONS 		set MAIL_OBJECT_PID = @MailObjectPId, 			DATA = @XMLData, 			POST_ORGANIZATION_CD = @PostOrganizationCd, 			CUST_ORGANIZATION_CD = @CustOrganizationCd, 			CDS_STATE_CD = case when @CDSStateCd is null then CDS_STATE_CD else @CDSStateCd end, 			AN_DECLARATION_ID = @AnonymousDeclId 		where DECLARATION_PID = @PId	 		 		IF (@@ROWCOUNT = 0)  			insert into O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, DATA, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, AN_DECLARATION_ID)			 			values(@PId, @MailObjectPId, @XMLData, @PostOrganizationCd, @CustOrganizationCd, @CDSStateCd, @AnonymousDeclId)			 	end 	else 	begin 		insert into O_DECLARATIONS(MAIL_OBJECT_PID, DATA, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, AN_DECLARATION_ID) 		output inserted.DECLARATION_PID into @inserted 		values(@MailObjectPId, @XMLData, @PostOrganizationCd, @CustOrganizationCd, @CDSStateCd, @AnonymousDeclId)			 		 		select top 1 @PId = pid from @inserted  	end	 		 	 	if not exists(select 1 from O_DECLARATION_EVENTS where DECLARATION_PID = @PId and CDS_EVENT_TYPE_CD = @EvtCd and D_EVENT_GMT_DT = @EvtGmtDt) 	begin				 		insert into O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD) 		values(@PId, @EvtCd, @EvtGmtDt, @LocalOffset, @UserCd, @OfficeCd) 	end  	select 		co.DECLARATION_PID as PId,			 		co.MAIL_OBJECT_PID as MailObjectPId, 		co.DATA as XMLData, 		co.POST_ORGANIZATION_CD as PostOrganizationCd, 		co.CUST_ORGANIZATION_CD as CustOrganizationCd, 		co.CDS_STATE_CD as CDSStateCd, 		co.AN_DECLARATION_ID as AnonymousDeclId 	from O_DECLARATIONS co (nolock) 	where DECLARATION_PID = @PId   ",81,0,81,39,0,2422431
"       SELECT db_id() AS database_id, COUNT_BIG(*) AS [TVPStoredProcsCount]       FROM sys.types t WITH(nolock)       JOIN sys.parameters p WITH(nolock) ON t.system_type_id = p.system_type_id AND t.user_type_id=p.user_type_id       JOIN sys.objects o WITH(nolock) ON o.object_id = p.object_id       WHERE is_table_type = 1     ",74,44,30,4906,0,74
"       SELECT DB_ID() AS database_id,       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       COUNT_BIG(*) AS NumTables,       is_node,       is_edge       FROM sys.tables WITH(nolock)       GROUP BY       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       is_node,       is_edge     ",72,31,41,5751,0,72
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",55,51,4,5670,0,55
FETCH API_CURSOR000000000000C591 ,53,53,0,45923,0,106
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",51,44,7,6040,0,51
"       SELECT db_id() AS database_id, COUNT_BIG(*) AS [TVPStoredProcsCount]       FROM sys.types t WITH(nolock)       JOIN sys.parameters p WITH(nolock) ON t.system_type_id = p.system_type_id AND t.user_type_id=p.user_type_id       JOIN sys.objects o WITH(nolock) ON o.object_id = p.object_id       WHERE is_table_type = 1     ",50,36,14,4141,0,50
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",41,40,1,6285,2,41
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",41,36,5,5151,0,41
FETCH API_CURSOR000000000000C594 ,35,35,0,36855,0,70
"         DECLARE @msticks bigint, @mstickstime datetime, @LastHour datetime                 SELECT @mstickstime = GETDATE(), @msticks = ms_ticks from sys.dm_os_sys_info                 SELECT @LastHour = DATEADD(HOUR, -1, @mstickstime);                  WITH Quartiles AS (                 SELECT DISTINCT                     CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) EventDate,                        CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114) AS [EventTime],                        PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS MedianSQLCPU                            ,                        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS Q3SQLCPU                      ,                        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS Q1SQLCPU                   FROM (                     SELECT timestamp, CONVERT (xml, record) AS 'record'                     FROM sys.dm_os_ring_buffers                     WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'                       AND record LIKE '%<SystemHealth>%'                             ) AS t                      WHERE DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)) = DATEPART(HOUR, @LastHour)                      AND CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE) = CAST(@LastHour AS DATE)               ),               SimpleStats AS (                 SELECT                     CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) EventDate,                        CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114) AS [EventTime],                     MAX(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [MaxSQLCPU],                        MIN(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [MinSQLCPU],                        AVG(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [AvgSQLCPU]                   FROM (                     SELECT timestamp, CONVERT (xml, record) AS 'record'                     FROM sys.dm_os_ring_buffers                     WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'                       AND record LIKE '%<SystemHealth>%'                             ) AS t               WHERE DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)) = DATEPART(HOUR, @LastHour)                      AND CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE) = CAST(@LastHour AS DATE)               GROUP BY                      CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) ,                      CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)               )               SELECT                      ss.EventDate AS EventDate,                      ss.EventTime AS EventTime,                      ss.MaxSQLCPU,                      ss.MinSQLCPU,                      ss.AvgSQLCPU,                      q.MedianSQLCPU,                      q.Q1SQLCPU,                      q.Q3SQLCPU               FROM SimpleStats ss                      INNER JOIN Quartiles q                            ON q.EventDate = ss.EventDate                            AND q.EventTime = ss.EventTime      ",35,35,0,783,0,1239
FETCH API_CURSOR000000000000C595 ,35,35,0,36855,0,70
FETCH API_CURSOR000000000000C593 ,34,34,0,41434,0,138
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",32,32,0,6848,0,32
" CREATE PROCEDURE dbo.USP_GET_USERS 	 as 	select  		USER_CD as Code, 		USER_NM as Name, 		PASSWORD as Password,		 		ORGANIZATION_CD as OrganizationCd,		 		VALID as ValidInd, 		PREFERENCES as XmlPreferences, 		case 			when exists (select 1 from M_ORGANIZATIONS o where o.ORGANIZATION_CD = u.ORGANIZATION_CD and o.ORGANIZATION_TYPE_CD = 'P') then 1 			else 0 		end as IsPostUser, 		case 			when exists (select 1 from M_ORGANIZATIONS o where o.ORGANIZATION_CD = u.ORGANIZATION_CD and o.ORGANIZATION_TYPE_CD = 'C') then 1 			else 0 		end as IsCustUser 	from A_USERS u 	order by USER_CD asc ",30,2,28,57,0,60
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",30,29,1,4396,0,30
" CREATE PROCEDURE dbo.USP_GET_RESTRICTIONS_PROHIBITIONS	 as  	select  		PROHIBITION_PID as PId, 		ORGANIZATION_CD as OrganizationCd, 		LANGUAGE_CD as LanguageCd, 		P_CATEGORY as PCategory, 		DESCRIPTION as Description, 		RESTRICTION_NOTE as RestrictionNote, 		WEBSITE_INFO as WebsiteInfo, 		RESTRICTED_COUNTRIES as RestrictedCountries, 		ADDITIONAL_DOC_FILE_NAME as AdditionalDocFileName, 		FROM_HS_CODE as FromHSCode, 		TO_HS_CODE as ToHSCode, 		HS_CODE_LIST as HSCodeList, 		VALID as Valid 	from M_RESTRICTIONS_PROHIBITIONS  ",26,13,13,250,0,242
"       SELECT DB_ID() AS database_id,       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       COUNT_BIG(*) AS NumTables,       is_node,       is_edge       FROM sys.tables WITH(nolock)       GROUP BY       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       is_node,       is_edge     ",21,13,8,2701,0,21
"       SELECT db_id() AS database_id, o.[type] as ModuleType, COUNT_BIG(*) as ModuleCount       FROM sys.objects AS o WITH(nolock)       WHERE o.type in ('AF', 'F', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TA', 'TF', 'TR', 'X', 'C', 'D', 'PG', 'SN', 'SO', 'SQ', 'TT', 'UQ', 'V')       GROUP BY o.[type]     ",20,20,0,2228,0,20
"       SELECT DB_ID() AS database_id,       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       COUNT_BIG(*) AS NumTables,       is_node,       is_edge       FROM sys.tables WITH(nolock)       GROUP BY       is_remote_data_archive_enabled,       temporal_type,       is_memory_optimized,       lock_escalation,       type,       is_node,       is_edge     ",20,15,5,2561,0,20
"       SELECT db_id() AS database_id, o.[type] as ModuleType, COUNT_BIG(*) as ModuleCount       FROM sys.objects AS o WITH(nolock)       WHERE o.type in ('AF', 'F', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TA', 'TF', 'TR', 'X', 'C', 'D', 'PG', 'SN', 'SO', 'SQ', 'TT', 'UQ', 'V')       GROUP BY o.[type]     ",20,20,0,2494,0,20
"       SELECT db_id() AS database_id, o.[type] as ModuleType, COUNT_BIG(*) as ModuleCount       FROM sys.objects AS o WITH(nolock)       WHERE o.type in ('AF', 'F', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TA', 'TF', 'TR', 'X', 'C', 'D', 'PG', 'SN', 'SO', 'SQ', 'TT', 'UQ', 'V')       GROUP BY o.[type]     ",20,20,0,2652,0,20
"CREATE PROCEDURE sp_sqlagent_has_server_access   @login_name         sysname = NULL,   @job_id             uniqueidentifier = NULL, -- if this is not null, @login_name will be ignored!   @is_sysadmin_member INT     = NULL OUTPUT AS BEGIN   DECLARE @has_server_access BIT   DECLARE @is_sysadmin       BIT   DECLARE @actual_login_name sysname   -- Set only when login_name is actually found. It will be zero when @actual_login_name is (unknown).   DECLARE @login_found BIT   DECLARE @cachedate         DATETIME    SET NOCOUNT ON    SELECT @cachedate = NULL    -- remove expired entries from the cache   DELETE msdb.dbo.syscachedcredentials   WHERE  DATEDIFF(MINUTE, cachedate, GETDATE()) >= 29    -- query the cache   SELECT  @is_sysadmin = is_sysadmin_member,           @has_server_access = has_server_access,           @cachedate = cachedate   FROM    msdb.dbo.syscachedcredentials   WHERE   login_name = @login_name   AND     DATEDIFF(MINUTE, cachedate, GETDATE()) < 29    IF (@cachedate IS NOT NULL)   BEGIN     -- no output variable     IF (@is_sysadmin_member IS NULL)     BEGIN       -- Return result row       SELECT has_server_access = @has_server_access,              is_sysadmin       = @is_sysadmin,              actual_login_name = @login_name       RETURN     END     ELSE     BEGIN       SELECT @is_sysadmin_member = @is_sysadmin       RETURN     END   END -- select from cache    -- Set defaults   SELECT @has_server_access = 0   SELECT @is_sysadmin = 0   SELECT @actual_login_name = FORMATMESSAGE(14205)   SELECT @login_found = 0      -- If @job_id was set, get the current name associated with the job owner sid.   if (@job_id IS NOT NULL)   BEGIN 	SELECT @login_name = dbo.SQLAGENT_SUSER_SNAME(owner_sid) 	FROM msdb.dbo.sysjobs_view 	WHERE @job_id = job_id      -- If the job_id is invalid, return error     IF (@login_name IS NULL)     BEGIN       RETURN 1;     END    END   IF (@login_name IS NULL)   BEGIN     SELECT has_server_access = 1,            is_sysadmin       = IS_SRVROLEMEMBER(N'sysadmin'),            actual_login_name = SUSER_SNAME()     RETURN   END    IF (@login_name LIKE '%\%')   BEGIN     -- Handle the LocalSystem account ('NT AUTHORITY\SYSTEM') as a special case     IF (UPPER(@login_name collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')     BEGIN       IF (EXISTS (SELECT *                   FROM master.dbo.syslogins                   WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')))       BEGIN         SELECT @has_server_access = hasaccess,                @is_sysadmin = sysadmin,                @actual_login_name = loginname         FROM master.dbo.syslogins         WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')          SET @login_found = 1       END       ELSE       IF (EXISTS (SELECT *                   FROM master.dbo.syslogins                   WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')))       BEGIN         SELECT @has_server_access = hasaccess,                @is_sysadmin = sysadmin,                @actual_login_name = loginname         FROM master.dbo.syslogins         WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')          SET @login_found = 1       END     END     ELSE     BEGIN       -- Check if the NT login has been explicitly denied access       IF (EXISTS (SELECT *                   FROM master.dbo.syslogins                   WHERE (loginname = @login_name)                     AND (denylogin = 1)))       BEGIN         SELECT @has_server_access = 0,                @is_sysadmin = sysadmin,                @actual_login_name = loginname         FROM master.dbo.syslogins         WHERE (loginname = @login_name)          SET @login_found = 1       END       ELSE       BEGIN         -- declare table variable for storing results         DECLARE @xp_results TABLE         (         account_name      sysname      COLLATE database_default NOT NULL PRIMARY KEY,         type              NVARCHAR(10) COLLATE database_default NOT NULL,         privilege         NVARCHAR(10) COLLATE database_default NOT NULL,         mapped_login_name sysname      COLLATE database_default NOT NULL,         permission_path   sysname      COLLATE database_default NULL         )          -- Call xp_logininfo to determine server access         INSERT INTO @xp_results         EXECUTE master.dbo.xp_logininfo @login_name          IF (SELECT COUNT(*) FROM @xp_results) > 0         BEGIN           SET @has_server_access = 1           SET @login_found = 1         END          SELECT @actual_login_name = mapped_login_name,                @is_sysadmin = CASE UPPER(privilege collate SQL_Latin1_General_CP1_CS_AS)                                 WHEN 'ADMIN' THEN 1                                 ELSE 0                              END         FROM @xp_results       END     END     -- Only cache the NT logins to approximate the behavior of Sql Server and Windows (see bug 323287)     -- update the cache only if something is found     IF  (UPPER(@actual_login_name collate SQL_Latin1_General_CP1_CS_AS) <> '(UNKNOWN)')     BEGIN       -- Procedure starts its own transaction.       BEGIN TRANSACTION;        -- Modify database.       -- use a try catch login to prevent any error when trying       -- to insert/update syscachedcredentials table       -- no need to fail since the job owner has been validated       BEGIN TRY         IF EXISTS (SELECT * FROM msdb.dbo.syscachedcredentials WITH (TABLOCKX) WHERE login_name = @login_name)         BEGIN           UPDATE msdb.dbo.syscachedcredentials           SET    has_server_access = @has_server_access,                 is_sysadmin_member = @is_sysadmin,                 cachedate = GETDATE()           WHERE  login_name = @login_name         END         ELSE         BEGIN           INSERT INTO msdb.dbo.syscachedcredentials(login_name, has_server_access, is_sysadmin_member)           VALUES(@login_name, @has_server_access, @is_sysadmin)         END         END TRY         BEGIN CATCH             -- If an error occurred we want to ignore it         END CATCH          -- The procedure must commit the transaction it started.         COMMIT TRANSACTION;     END    END   ELSE   BEGIN     -- Standard login     IF (EXISTS (SELECT *                 FROM master.dbo.syslogins                 WHERE (loginname = @login_name)))     BEGIN       SELECT @has_server_access = hasaccess,              @is_sysadmin = sysadmin,              @actual_login_name = loginname       FROM master.dbo.syslogins       WHERE (loginname = @login_name)        SET @login_found = 1     END   END    IF (@is_sysadmin_member IS NULL)     -- Return result row     SELECT has_server_access = @has_server_access,            is_sysadmin       = @is_sysadmin,            actual_login_name = @actual_login_name,            login_found       = @login_found   ELSE     -- output variable only     SELECT @is_sysadmin_member = @is_sysadmin END ",20,15,5,252,1,7802
" CREATE PROCEDURE dbo.USP_GET_LOCALIZATIONS 	 as  	select  		LANGUAGE_CD as LanguageCd, 		PARENT_TABLE as ParentTable, 		ltrim(rtrim(ENTITY_KEY)) as EntityKey, 		LOCAL_NM as LocalNm 	from A_LOCALIZATIONS ",19,8,11,104,0,276
"CREATE PROCEDURE [dbo].[sp_syscollector_purge_collection_logs]     @reference_date datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     SET NOCOUNT ON      -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))     BEGIN         RAISERROR(14677, -1, -1, 'dc_proxy')         RETURN(1) -- Failure     END      IF (@reference_date IS NULL)     BEGIN         SET @reference_date = GETDATE()     END          -- An expired log record is any record of a collection set that is older than      -- the reference date minus the collection set's days_until_expiration     CREATE TABLE #purged_log_ids (log_id BIGINT, package_execution_id uniqueidentifier)          -- Identify logs to purge based on following criteria     -- a) limit max batch size      -- b) do not delete last log record that is a root log record for a collection set     INSERT INTO #purged_log_ids     SELECT TOP (@delete_batch_size) log_id, package_execution_id     FROM syscollector_execution_log_internal as l     INNER JOIN syscollector_collection_sets s ON l.collection_set_id = s.collection_set_id     WHERE s.days_until_expiration > 0     AND @reference_date >= DATEADD(DAY, s.days_until_expiration, l.finish_time)     AND log_id NOT IN (                         SELECT TOP 1 log_id  from syscollector_execution_log_internal                          WHERE parent_log_id IS NULL                          AND collection_set_id = l.collection_set_id                         ORDER BY start_time DESC                         )      DECLARE @purge_log_count int     SELECT @purge_log_count  = COUNT(log_id)      FROM  #purged_log_ids      -- Delete all ssis log records pertaining to expired logs     DELETE FROM dbo.sysssislog         FROM dbo.sysssislog AS s         INNER JOIN #purged_log_ids AS i ON i.package_execution_id = s.executionid              -- Then delete the actual logs     DELETE FROM syscollector_execution_log_internal         FROM syscollector_execution_log_internal AS l         INNER Join #purged_log_ids AS i ON i.log_id = l.log_id       DROP TABLE #purged_log_ids      -- making sure that delete # record does not exceed given delete batch size     DECLARE @orphaned_record_cleanup_count int     SET @orphaned_record_cleanup_count = @delete_batch_size - @purge_log_count      -- Go for another round to cleanup the orphans     -- Ideally, the log heirarchy guarantees that a finish time by a parent log will always     -- be higher than the finish time of any of its descendants.     -- The purge step however does not delete log records with a null finish time     -- A child log can have a null finish time while its parent is closed if there is an     -- error in execution that causes the log to stay open.     -- If such a child log exists, its parent will be purged leaving it as an orphan          -- get orphan records and all their descendants in a cursor and purge them     DECLARE orphaned_log_cursor INSENSITIVE CURSOR FOR             SELECT TOP (@orphaned_record_cleanup_count) log_id              FROM syscollector_execution_log_internal             WHERE parent_log_id NOT IN (                 SELECT log_id FROM syscollector_execution_log_internal             )             FOR READ ONLY                  DECLARE @log_id BIGINT      -- for every orphan, delete all its remaining tree     -- this is supposedly a very small fraction of the entire log     OPEN orphaned_log_cursor         FETCH orphaned_log_cursor INTO @log_id     WHILE @@FETCH_STATUS = 0     BEGIN         EXEC sp_syscollector_delete_execution_log_tree @log_id = @log_id, @from_collection_set = 0         FETCH orphaned_log_cursor INTO @log_id     END          CLOSE orphaned_log_cursor     DEALLOCATE orphaned_log_cursor END ",19,19,0,8691,10,1939
" CREATE TRIGGER TRG_DECLARATIONS_DELETE_COUNTER ON O_DECLARATIONS AFTER DELETE AS BEGIN 	SET NOCOUNT ON;  	DECLARE @DeletedItems TABLE ( 		itemkey NVARCHAR(max) 		,deleleditems NVARCHAR(max) 		,keyhash NVARCHAR(max) 		,oldvaluehash NVARCHAR(max) 		,oldvalue NVARCHAR(max) 		)  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Inbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.DEST_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG (CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash,'', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END  	DELETE 	FROM @DeletedItems;  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Outbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.ORIG_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG(CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash, '', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END END ",17,17,0,482,26,35
"       select counter_name, cntr_value from sys.dm_os_performance_counters where object_name like '%External Scripts%'     ",17,17,0,0,0,17
"       SELECT AVG(cells_per_object) AS CellsPerObjectAvg       , db_id() AS database_id       FROM sys.spatial_index_tessellations WITH(nolock)     ",13,3,10,1132,0,13
" CREATE TRIGGER TRG_DECLARATIONS_DELETE_COUNTER ON O_DECLARATIONS AFTER DELETE AS BEGIN 	SET NOCOUNT ON;  	DECLARE @DeletedItems TABLE ( 		itemkey NVARCHAR(max) 		,deleleditems NVARCHAR(max) 		,keyhash NVARCHAR(max) 		,oldvaluehash NVARCHAR(max) 		,oldvalue NVARCHAR(max) 		)  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Inbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.DEST_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG (CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash,'', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END  	DELETE 	FROM @DeletedItems;  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Outbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.ORIG_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG(CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash, '', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END END ",12,12,0,242,18,25
" CREATE TRIGGER TRG_DECLARATIONS_DELETE_COUNTER ON O_DECLARATIONS AFTER DELETE AS BEGIN 	SET NOCOUNT ON;  	DECLARE @DeletedItems TABLE ( 		itemkey NVARCHAR(max) 		,deleleditems NVARCHAR(max) 		,keyhash NVARCHAR(max) 		,oldvaluehash NVARCHAR(max) 		,oldvalue NVARCHAR(max) 		)  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Inbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.DEST_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG (CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash,'', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END  	DELETE 	FROM @DeletedItems;  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Outbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.ORIG_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG(CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash, '', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END END ",12,8,4,100,0,25
" CREATE PROCEDURE dbo.USP_GET_ORGANIZATIONS 	 	@OrganizationTypeCd char(1) as  	select  		ORGANIZATION_CD as Code, 		ORGANIZATION_NM as Name, 		VALID as ValidInd, 		COUNTRY_CD as CountryCd, 		RULES as XmlRules, 		PREFERENCES as XmlPreferences, 		CUST_ORGANIZATION_CD as CustOrganizationCd, 		ORGANIZATION_TYPE_CD as OrganizationTypeCd, 		ACTIVE as Active, 		(select count(1) from A_USERS where ORGANIZATION_CD = o.ORGANIZATION_CD and VALID not in ('0', '2')) as UsersNo				 	from M_ORGANIZATIONS  o (nolock) 	where @OrganizationTypeCd is null or 		ORGANIZATION_TYPE_CD = @OrganizationTypeCd 	order by OrganizationTypeCd, Code  ",12,4,8,417,0,85
"use ""CDS_Achive""; SELECT SUM (CAST (COALESCE(FILEPROPERTY(dbfile.name, 'SpaceUsed'), dbfile.size) AS FLOAT(53))) / 128.0 AS FileSizeInMB FROM sys.database_files AS dbfile WHERE dbfile.drop_lsn IS NULL AND dbfile.type <> 1",11,11,0,138,0,11
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",11,14,-3,58,0,11
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       t.object_type,       i.is_disabled     ",10,10,0,1582,0,10
" CREATE TRIGGER TRG_DECLARATIONS_DELETE_COUNTER ON O_DECLARATIONS AFTER DELETE AS BEGIN 	SET NOCOUNT ON;  	DECLARE @DeletedItems TABLE ( 		itemkey NVARCHAR(max) 		,deleleditems NVARCHAR(max) 		,keyhash NVARCHAR(max) 		,oldvaluehash NVARCHAR(max) 		,oldvalue NVARCHAR(max) 		)  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Inbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.DEST_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG (CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash,'', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END  	DELETE 	FROM @DeletedItems;  	INSERT INTO @DeletedItems 	SELECT 'Declarations/Outbound/' + deleted.POST_ORGANIZATION_CD + '/' + STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '') 		,COUNT(*) 		,'' 		,'' 		,'' 	FROM O_MAIL_OBJECTS 	INNER JOIN deleted ON O_MAIL_OBJECTS.MAIL_OBJECT_PID = deleted.MAIL_OBJECT_PID 	WHERE O_MAIL_OBJECTS.ORIG_POST_ORGANIZATION_CD = POST_ORGANIZATION_CD 	GROUP BY deleted.POST_ORGANIZATION_CD 		,STUFF(CONVERT(VARCHAR(10), O_MAIL_OBJECTS.POSTING_DATE, 102), 8, 3, '')  	IF EXISTS ( 			SELECT 1 			FROM @DeletedItems 			) 	BEGIN 		UPDATE @DeletedItems 		SET keyhash = CONVERT(VARCHAR(max), HashBytes('SHA1', itemkey), 2);  		UPDATE @DeletedItems 		SET oldvaluehash = A_CONFIG.CONFIG_VALUE 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY;  		UPDATE @DeletedItems 		SET oldvalue = CONVERT(NVARCHAR(max), DECRYPTBYPASSPHRASE(itemkey, CONVERT(VARBINARY(max), oldvaluehash, 2)))  		UPDATE @DeletedItems 		SET deleleditems = cast(deleleditems AS INT) + oldvalue 		WHERE NOT oldvalue IS NULL;  		INSERT INTO A_CONFIG(CONFIG_KEY, CONFIG_VALUE, REMARKS, ORGANIZATION_TYPE_CD) 		SELECT keyhash, '', 'Special key', null 		FROM @DeletedItems 		WHERE NOT EXISTS ( 				SELECT 1 				FROM A_CONFIG 				WHERE A_CONFIG.CONFIG_KEY = keyhash 				)  		UPDATE A_CONFIG 		SET CONFIG_VALUE = CONVERT(VARCHAR(max), EncryptByPassPhrase(itemkey, deleleditems), 2) 		FROM @DeletedItems 		INNER JOIN A_CONFIG ON keyhash = A_CONFIG.CONFIG_KEY; 	END END ",10,5,5,69,0,21
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",9,9,0,1818,0,9
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",9,8,1,1813,5,2033
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       t.object_type,       i.is_disabled     ",9,9,0,1644,0,9
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",9,8,1,7663,0,2183
"(@P1 nvarchar(10),@P2 nvarchar(27))SELECT replace(convert(varchar, s.backup_start_date,111),'/','') + replace(convert(varchar, s.backup_start_date,108),':',''), replace(convert(varchar, s.backup_finish_date,111),'/','') + replace(convert(varchar, s.backup_finish_date,108),':',''), DATEDIFF(second,'1970-01-01 00:00:00',s.backup_finish_date),isnull(cast(s.first_lsn as varchar(25)),''),isnull(cast(s.last_lsn as varchar(25)),''),isnull(cast(s.checkpoint_lsn as varchar(25)),''),isnull(cast(s.database_backup_lsn as varchar(25)),''),isnull(cast(s.differential_base_lsn as varchar(25)),'') FROM msdb.dbo.backupset s inner join msdb.dbo.backupmediafamily m ON s.media_set_id = m.media_set_id WHERE s.database_name = @P1 AND m.physical_device_name = @P2 ORDER BY s.backup_finish_date",8,7,1,508,0,8
"(@P1 nvarchar(10),@P2 nvarchar(28))SELECT replace(convert(varchar, s.backup_start_date,111),'/','') + replace(convert(varchar, s.backup_start_date,108),':',''), replace(convert(varchar, s.backup_finish_date,111),'/','') + replace(convert(varchar, s.backup_finish_date,108),':',''), DATEDIFF(second,'1970-01-01 00:00:00',s.backup_finish_date),isnull(cast(s.first_lsn as varchar(25)),''),isnull(cast(s.last_lsn as varchar(25)),''),isnull(cast(s.checkpoint_lsn as varchar(25)),''),isnull(cast(s.database_backup_lsn as varchar(25)),''),isnull(cast(s.differential_base_lsn as varchar(25)),'') FROM msdb.dbo.backupset s inner join msdb.dbo.backupmediafamily m ON s.media_set_id = m.media_set_id WHERE s.database_name = @P1 AND m.physical_device_name = @P2 ORDER BY s.backup_finish_date",8,7,1,515,0,8
" CREATE PROCEDURE dbo.USP_SET_DECLARATION 	 	@PId					uniqueidentifier,	 	@MailObjectPId			uniqueidentifier, 	@XMLData				xml, 	@PostOrganizationCd		varchar(5), 	@CustOrganizationCd		varchar(5), 	@CDSStateCd				tinyint,  	@EvtCd					smallint, 	@EvtGmtDt				datetime, 	@LocalOffset			smallint, 	@AnonymousDeclId		varchar(13) = NULL, 	@UserCd					varchar(64), 	@OfficeCd				varchar(10) 	 as 	declare @inserted table( pid uniqueidentifier)				 		 	select @CDSStateCd = RESULTING_STATE_CD from M_CDS_EVENT_TYPES (nolock) where CDS_EVENT_TYPE_CD = @EvtCd  	if @PId is not null 	begin 		declare @CopyHist		bit 		declare @PrevEvtCd		smallint 		declare @PrevEvtGmtDt	datetime 		 		select top 1 @CopyHist = et.COPY_TO_HIST, @PrevEvtCd = de.CDS_EVENT_TYPE_CD, @PrevEvtGmtDt = de.D_EVENT_GMT_DT 		from O_DECLARATION_EVENTS de (nolock) inner join M_CDS_EVENT_TYPES et (nolock) on et.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD 		where de.DECLARATION_PID = @PId  		order by D_EVENT_GMT_DT desc 		 		if @CopyHist = 1 		begin 			if not exists(select 1 from O_DECLARATIONS_HIST where DECLARATION_PID = @PId and CDS_EVENT_TYPE_CD = @PrevEvtCd and D_EVENT_GMT_DT = @PrevEvtGmtDt) 				insert into O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA) 				select @PId, @PrevEvtCd, @PrevEvtGmtDt, DATA 				from O_DECLARATIONS (nolock) 				where DECLARATION_PID = @PId							 		end 				 		update O_DECLARATIONS 		set MAIL_OBJECT_PID = @MailObjectPId, 			DATA = @XMLData, 			POST_ORGANIZATION_CD = @PostOrganizationCd, 			CUST_ORGANIZATION_CD = @CustOrganizationCd, 			CDS_STATE_CD = case when @CDSStateCd is null then CDS_STATE_CD else @CDSStateCd end, 			AN_DECLARATION_ID = @AnonymousDeclId 		where DECLARATION_PID = @PId	 		 		IF (@@ROWCOUNT = 0)  			insert into O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, DATA, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, AN_DECLARATION_ID)			 			values(@PId, @MailObjectPId, @XMLData, @PostOrganizationCd, @CustOrganizationCd, @CDSStateCd, @AnonymousDeclId)			 	end 	else 	begin 		insert into O_DECLARATIONS(MAIL_OBJECT_PID, DATA, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, AN_DECLARATION_ID) 		output inserted.DECLARATION_PID into @inserted 		values(@MailObjectPId, @XMLData, @PostOrganizationCd, @CustOrganizationCd, @CDSStateCd, @AnonymousDeclId)			 		 		select top 1 @PId = pid from @inserted  	end	 		 	 	if not exists(select 1 from O_DECLARATION_EVENTS where DECLARATION_PID = @PId and CDS_EVENT_TYPE_CD = @EvtCd and D_EVENT_GMT_DT = @EvtGmtDt) 	begin				 		insert into O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD) 		values(@PId, @EvtCd, @EvtGmtDt, @LocalOffset, @UserCd, @OfficeCd) 	end  	select 		co.DECLARATION_PID as PId,			 		co.MAIL_OBJECT_PID as MailObjectPId, 		co.DATA as XMLData, 		co.POST_ORGANIZATION_CD as PostOrganizationCd, 		co.CUST_ORGANIZATION_CD as CustOrganizationCd, 		co.CDS_STATE_CD as CDSStateCd, 		co.AN_DECLARATION_ID as AnonymousDeclId 	from O_DECLARATIONS co (nolock) 	where DECLARATION_PID = @PId   ",7,0,7,24,0,601092
"       SELECT b1.device_type,       ISNULL(b1.[type],'NULL') AS backup_type,       b1.is_copy_only,       b1.time_bucket,       b1.compressed_backup_size_bucket,       b1.compression_percent_bucket,       b1.backup_throughput_bucket,       COUNT_BIG(b1.device_type) AS 'count',       b1.encryption       FROM       (       SELECT       mf.device_type,       bset.[type],       CAST(bset.[is_copy_only] AS INT) AS [is_copy_only],       CASE       WHEN DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0                    THEN 0       WHEN DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date])      BETWEEN 1 AND 30       THEN 1       WHEN DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date])      BETWEEN 30 AND 60      THEN 2       WHEN DATEDIFF(MINUTE, bset.[backup_start_date], bset.[backup_finish_date])      BETWEEN 1 AND 5        THEN 3       WHEN DATEDIFF(MINUTE, bset.[backup_start_date], bset.[backup_finish_date])      BETWEEN 5 AND 10       THEN 4       WHEN DATEDIFF(MINUTE, bset.[backup_start_date], bset.[backup_finish_date])      BETWEEN 10 AND 30      THEN 5       WHEN DATEDIFF(MINUTE, bset.[backup_start_date], bset.[backup_finish_date])      BETWEEN 30 AND 60      THEN 6       WHEN DATEDIFF(HOUR, bset.[backup_start_date], bset.[backup_finish_date])        BETWEEN 1 AND 2        THEN 7       WHEN DATEDIFF(HOUR, bset.[backup_start_date], bset.[backup_finish_date])        BETWEEN 2 AND 6        THEN 8       WHEN DATEDIFF(HOUR, bset.[backup_start_date], bset.[backup_finish_date])        BETWEEN 6 AND 12       THEN 9       WHEN DATEDIFF(HOUR, bset.[backup_start_date], bset.[backup_finish_date])        BETWEEN 12 AND 24      THEN 10       ELSE 99       END       AS 'time_bucket',       CASE       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 0 AND 1          THEN 0       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 1 AND 5          THEN 1       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 5 AND 25         THEN 2       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 25 AND 100       THEN 3       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 100 AND 500      THEN 4       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 500 AND 1000     THEN 5       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 1000 AND 5000    THEN 6       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 5000 AND 10000   THEN 7       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 10000 AND 50000  THEN 8       WHEN CAST(ISNULL(bset.compressed_backup_size, 0) / 1048576 AS FLOAT) BETWEEN 50000 AND 100000 THEN 9       ELSE 99       END       AS compressed_backup_size_bucket,       CASE       WHEN CAST(((ISNULL(bset.backup_size,0) - ISNULL(bset.compressed_backup_size,0)) /       CASE WHEN bset.backup_size <= 0 THEN 1       ELSE ISNULL(bset.backup_size, 1)       END       ) * 100  AS FLOAT) = 0.0 THEN 0       ELSE (CAST(((ISNULL(bset.backup_size,0) - ISNULL(bset.compressed_backup_size,0)) /       CASE WHEN bset.backup_size <= 0 THEN 1       ELSE ISNULL(bset.backup_size, 1)       END       ) * 100  AS INT)/10) + 1       END       AS compression_percent_bucket,       CASE       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) = 0.0                       THEN 0       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  0 AND 100          THEN 1       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  100 AND 500        THEN 2       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  500 AND 1000       THEN 3       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  1000 AND 5000      THEN 4       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  5000 AND 10000     THEN 5       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  10000 AND 20000    THEN 6       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  20000 AND 30000    THEN 7       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  30000 AND 50000    THEN 8       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  50000 AND 100000   THEN 9       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  100000 AND 500000  THEN 10       WHEN CAST(CAST(ISNULL(bset.compressed_backup_size, 0) / 1024 AS FLOAT) / (CASE WHEN  DATEDIFF(SECOND, bset.[backup_start_date], bset.[backup_finish_date]) = 0 THEN 1 END) AS FLOAT) BETWEEN  500000 AND 1000000 THEN 11       ELSE 99       END       AS backup_throughput_bucket, -- in KB       CASE       WHEN bset.encryptor_type like '%CERTIFICATE%' THEN 1       WHEN bset.encryptor_type like '%ASYMMETRIC KEY%' THEN 2       ELSE 0       END       AS encryption       FROM [msdb].[dbo].[backupset] bset WITH (READUNCOMMITTED)       JOIN [msdb].[dbo].[backupmediafamily]  mf WITH (READUNCOMMITTED) ON  mf.media_set_id = bset.media_set_id       WHERE       backup_finish_date <= GETDATE() and backup_finish_date > DATEADD(hh, -24, GETDATE() )       ) AS b1       GROUP BY       b1.device_type,       b1.[type],       b1.is_copy_only,       b1.time_bucket,       b1.compressed_backup_size_bucket,       b1.compression_percent_bucket,       b1.backup_throughput_bucket,       b1.encryption      ",7,6,1,2851,0,7
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       t.object_type,       i.is_disabled     ",7,6,1,1050,0,7
"       SELECT db_id() AS database_id,       COUNT_BIG(*) AS [NumExternalStats]       FROM sys.tables t WITH(nolock) INNER JOIN sys.stats s WITH(nolock) ON t.object_id = s.object_id       WHERE t.is_external=1     ",7,7,0,1014,0,7
"       SELECT AVG(cells_per_object) AS CellsPerObjectAvg       , db_id() AS database_id       FROM sys.spatial_index_tessellations WITH(nolock)     ",6,3,3,1340,0,6
" CREATE PROCEDURE dbo.USP_GET_CONFIGS 	 as  	select  		CONFIG_KEY as [Key], 		CONFIG_VALUE as Value, 		REMARKS as Remarks, 		ORGANIZATION_TYPE_CD as OrganizationTypeCd 	from A_CONFIG  ",6,5,1,244,0,368066
"       SELECT db_id() AS database_id,       COUNT_BIG(*) AS [NumExternalStats]       FROM sys.tables t WITH(nolock) INNER JOIN sys.stats s WITH(nolock) ON t.object_id = s.object_id       WHERE t.is_external=1     ",6,6,0,1810,0,6
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",6,6,0,1552,0,6
"       SELECT AVG(cells_per_object) AS CellsPerObjectAvg       , db_id() AS database_id       FROM sys.spatial_index_tessellations WITH(nolock)     ",6,2,4,588,0,6
"     SELECT     db_id() AS database_id,     desired_state AS QueryStoreDesiredState,     actual_state AS QueryStoreActualState,     current_storage_size_mb AS QueryStoreCurrentStorageSizeMb     FROM sys.database_query_store_options WITH(nolock)",6,3,3,1022,0,6
"       SELECT db_id() AS database_id,       COUNT_BIG(*) AS [NumExternalStats]       FROM sys.tables t WITH(nolock) INNER JOIN sys.stats s WITH(nolock) ON t.object_id = s.object_id       WHERE t.is_external=1     ",6,6,0,1123,0,6
"       SELECT COUNT_BIG(*) AS number_of_message_types       , db_id() AS database_id       FROM sys.service_message_types WITH(nolock)       WHERE message_type_id > 65535     ",6,0,6,18,0,6
"(@1 varchar(8000))SELECT [succeeded] FROM [msdb]..[sysmaintplan_logdetail] WHERE [task_detail_id]=@1 ORDER BY [start_time] ASC,[end_time] ASC",6,5,1,968,0,37
"     SELECT     db_id() AS database_id,     desired_state AS QueryStoreDesiredState,     actual_state AS QueryStoreActualState,     current_storage_size_mb AS QueryStoreCurrentStorageSizeMb     FROM sys.database_query_store_options WITH(nolock)",6,3,3,998,0,6
"     SELECT     db_id() AS database_id,     desired_state AS QueryStoreDesiredState,     actual_state AS QueryStoreActualState,     current_storage_size_mb AS QueryStoreCurrentStorageSizeMb     FROM sys.database_query_store_options WITH(nolock)",6,3,3,1051,0,6
"       SELECT db_id() AS database_id, o.[type] as ModuleType, COUNT_BIG(*) as ModuleCount       FROM sys.objects AS o WITH(nolock)       WHERE o.type in ('AF', 'F', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TA', 'TF', 'TR', 'X', 'C', 'D', 'PG', 'SN', 'SO', 'SQ', 'TT', 'UQ', 'V')       GROUP BY o.[type]     ",5,5,0,61,0,5
"CREATE PROCEDURE [core].[sp_purge_data]     @retention_days smallint = NULL,     @instance_name sysname = NULL,     @collection_set_uid uniqueidentifier = NULL,     @duration smallint = NULL,     @delete_batch_size int = 500 AS BEGIN     -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'mdw_admin'), 0) = 1) AND NOT (ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0) = 1))     BEGIN         RAISERROR(14677, 16, -1, 'mdw_admin')         RETURN(1) -- Failure     END      -- Validate parameters     IF ((@retention_days IS NOT NULL) AND (@retention_days < 0))     BEGIN         RAISERROR(14200, -1, -1, '@retention_days')         RETURN(1) -- Failure     END      IF ((@duration IS NOT NULL) AND (@duration < 0))     BEGIN         RAISERROR(14200, -1, -1, '@duration')         RETURN(1) -- Failure     END      -- This table will contain a record if somebody requests purge to stop     -- If user requested us to purge data - we reset the content of it - and proceed with purge     -- If somebody in a different session wants purge operations to stop he adds a record     -- that we will discover while purge in progress     --     -- We dont clear this flag when we exit since multiple purge operations with differnet     -- filters may proceed, and we want all of them to stop.     DELETE FROM [core].[purge_info_internal]      SET @instance_name = NULLIF(LTRIM(RTRIM(@instance_name)), N'')      -- Calculate the time when the operation should stop (NULL otherwise)     DECLARE @end_time datetime     IF (@duration IS NOT NULL)     BEGIN         SET @end_time = DATEADD(minute, @duration, GETUTCDATE())     END      -- Declare table that will be used to find what are the valid     -- candidate snapshots that could be selected for purge     DECLARE @purge_candidates table     (         snapshot_id int NOT NULL,         snapshot_time datetime NOT NULL,         instance_name sysname NOT NULL,         collection_set_uid uniqueidentifier NOT NULL     )      -- Find candidates that match the retention_days criteria (if specified)     IF (@retention_days IS NULL)     BEGIN         -- User did not specified a value for @retention_days, therfore we         -- will use the default expiration day as marked in the source info         INSERT INTO @purge_candidates         SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid         FROM core.snapshots s         WHERE (GETUTCDATE() >= s.valid_through)     END     ELSE     BEGIN         -- User specified a value for @retention_days, we will use this overriden value         -- when deciding what means old enough to qualify for purge this overrides         -- the days_until_expiration value specified in the source_info_internal table         INSERT INTO @purge_candidates         SELECT s.snapshot_id, s.snapshot_time, s.instance_name, s.collection_set_uid         FROM core.snapshots s         WHERE GETUTCDATE() >= DATEADD(DAY, @retention_days, s.snapshot_time)     END      -- Determine which is the oldest snapshot, from the list of candidates     DECLARE oldest_snapshot_cursor CURSOR FORWARD_ONLY READ_ONLY FOR     SELECT p.snapshot_id, p.instance_name, p.collection_set_uid     FROM @purge_candidates p     WHERE          ((@instance_name IS NULL) or (p.instance_name = @instance_name)) AND         ((@collection_set_uid IS NULL) or (p.collection_set_uid = @collection_set_uid))     ORDER BY p.snapshot_time ASC          OPEN oldest_snapshot_cursor      DECLARE @stop_purge int     DECLARE @oldest_snapshot_id int     DECLARE @oldest_instance_name sysname     DECLARE @oldest_collection_set_uid uniqueidentifier      FETCH NEXT FROM oldest_snapshot_cursor     INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid      -- As long as there are snapshots that matched the time criteria     WHILE @@FETCH_STATUS = 0     BEGIN          -- Filter out records that do not match the other filter crieria         IF ((@instance_name IS NULL) or (@oldest_instance_name = @instance_name))         BEGIN              -- There was no filter specified for instance_name or the instance matches the filter             IF ((@collection_set_uid IS NULL) or (@oldest_collection_set_uid = @collection_set_uid))             BEGIN                  -- There was no filter specified for the collection_set_uid or the collection_set_uid matches the filter                 BEGIN TRANSACTION tran_sp_purge_data                  -- Purge data associated with this snapshot. Note: deleting this snapshot                 -- triggers cascade delete in all warehouse tables based on the foreign key                  -- relationship to snapshots table                  -- Cascade cleanup of all data related referencing oldest snapshot                 DELETE core.snapshots_internal                 FROM core.snapshots_internal s                 WHERE s.snapshot_id = @oldest_snapshot_id                  COMMIT TRANSACTION tran_sp_purge_data                  PRINT 'Snapshot #' + CONVERT(VARCHAR, @oldest_snapshot_id) + ' purged.';             END          END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN                 PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END          -- Move to next oldest snapshot         FETCH NEXT FROM oldest_snapshot_cursor         INTO @oldest_snapshot_id, @oldest_instance_name, @oldest_collection_set_uid      END      CLOSE oldest_snapshot_cursor     DEALLOCATE oldest_snapshot_cursor      -- delete orphaned query plans     EXEC [core].[sp_purge_orphaned_notable_query_plan] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size      -- delete orphaned query text     EXEC [core].[sp_purge_orphaned_notable_query_text] @duration = @duration, @end_time = @end_time, @delete_batch_size = @delete_batch_size         END ",5,1,4,251,1,246
"CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_plan]     @duration smallint = NULL,     @end_time datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     PRINT 'Begin purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())      DECLARE @stop_purge int      -- Delete orphaned rows from snapshots.notable_query_plan.  Query plans are not deleted by the generic purge      -- process that deletes other data (above) because query plan rows are not tied to a particular snapshot ID.      -- Purging query plans table  as a special case, by looking for plans that      -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these      -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and      -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).       DECLARE @rows_affected int;     -- set expected rows affected as delete batch size     SET @rows_affected = @delete_batch_size;          -- select set of orphaned query plans to be deleted into a temp table      SELECT qp.[sql_handle],         qp.plan_handle,         qp.plan_generation_num,         qp.statement_start_offset,         qp.statement_end_offset,         qp.creation_time     INTO #tmp_notable_query_plan     FROM snapshots.notable_query_plan AS qp      WHERE NOT EXISTS (         SELECT snapshot_id          FROM snapshots.query_stats AS qs         WHERE qs.[sql_handle] = qp.[sql_handle] AND qs.plan_handle = qp.plan_handle              AND qs.plan_generation_num = qp.plan_generation_num              AND qs.statement_start_offset = qp.statement_start_offset              AND qs.statement_end_offset = qp.statement_end_offset              AND qs.creation_time = qp.creation_time)      WHILE (@rows_affected = @delete_batch_size)     BEGIN         -- Deleting TOP N orphaned rows in query plan table by joining info from temp table variable         -- This is done to speed up delete query.          DELETE TOP (@delete_batch_size) snapshots.notable_query_plan          FROM snapshots.notable_query_plan AS qp , #tmp_notable_query_plan AS tmp         WHERE tmp.[sql_handle] = qp.[sql_handle]              AND tmp.plan_handle = qp.plan_handle              AND tmp.plan_generation_num = qp.plan_generation_num              AND tmp.statement_start_offset = qp.statement_start_offset              AND tmp.statement_end_offset = qp.statement_end_offset              AND tmp.creation_time = qp.creation_time                  SET @rows_affected = @@ROWCOUNT;         IF(@rows_affected > 0)         BEGIN             RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_plan', 0, 1, @rows_affected) WITH NOWAIT;         END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN             PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END     END;          PRINT 'End purging orphaned records in snapshots.notable_query_plan Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE()) END  ",4,2,2,186,2,14
" CREATE PROCEDURE dbo.USP_GET_OFFICES 	@LANGUAGE_CD char(2) as  	select  		OFFICE_CD as Code, 		OFFICE_NM As Name, 		LOCAL_NM as LocName, 		COUNTRY_CD as Country, 		VALID as ValidInd		 	from M_OFFICES left join A_LOCALIZATIONS on LANGUAGE_CD = @LANGUAGE_CD and PARENT_TABLE = 'M_OFFICES' and ENTITY_KEY = OFFICE_CD  ",4,3,1,22,0,48
"       SELECT DB_ID() AS database_id, COUNT_BIG(*) as MemoryOptimizedScalarUDFCount       FROM sys.sql_modules m WITH(nolock) JOIN sys.objects o WITH(nolock) ON m.object_id=o.object_id       WHERE uses_native_compilation=1 and o.type='FN'     ",4,2,2,137,0,4
"use ""CDS_POST_THA""; SELECT SUM (CAST (COALESCE(FILEPROPERTY(dbfile.name, 'SpaceUsed'), dbfile.size) AS FLOAT(53))) / 128.0 AS FileSizeInMB FROM sys.database_files AS dbfile WHERE dbfile.drop_lsn IS NULL AND dbfile.type <> 1",4,4,0,70,0,4
"       SELECT ISNULL(AVG(c),0) AS [XTPAvgNumOfIndexes],       ISNULL(MAX(c),0) AS [XTPMaxNumOfIndexes], db_id() AS database_id       FROM (SELECT COUNT_BIG(*) AS c       FROM sys.indexes i WITH(nolock) JOIN sys.tables t WITH(nolock) ON i.object_id=t.object_id WHERE t.is_memory_optimized=1       GROUP BY i.object_id) a     ",4,4,0,794,0,4
"       SELECT ISNULL(AVG(c),0) AS [XTPAvgNumOfIndexes],       ISNULL(MAX(c),0) AS [XTPMaxNumOfIndexes], db_id() AS database_id       FROM (SELECT COUNT_BIG(*) AS c       FROM sys.indexes i WITH(nolock) JOIN sys.tables t WITH(nolock) ON i.object_id=t.object_id WHERE t.is_memory_optimized=1       GROUP BY i.object_id) a     ",4,4,0,831,0,4
"       SELECT COUNT_BIG(*) AS [NumOfNativeProcs], db_id() AS database_id FROM sys.sql_modules m WITH(nolock) JOIN sys.procedures p WITH(nolock) ON m.object_id=p.object_id WHERE uses_native_compilation=1     ",4,4,0,196,0,4
"CREATE PROCEDURE [core].[sp_purge_orphaned_notable_query_text]     @duration smallint = NULL,     @end_time datetime = NULL,     @delete_batch_size int = 500 AS BEGIN     PRINT 'Begin purging orphaned records in snapshots.notable_query_text Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())      DECLARE @stop_purge int      -- Delete orphaned rows from snapshots.notable_query_text.  Query texts are not deleted by the generic purge      -- process that deletes other data (above) because query text rows are not tied to a particular snapshot ID.      -- Purging  query text table as a special case, by looking for plans that      -- are no longer referenced by any of the rows in the snapshots.query_stats table.  We need to delete these      -- rows in small chunks, since deleting many GB in a single delete statement would cause lock escalation and      -- an explosion in the size of the transaction log (individual query plans can be 10-50MB).       DECLARE @rows_affected int;     -- set expected rows affected as delete batch size     SET @rows_affected = @delete_batch_size;      SELECT qt.[sql_handle]     INTO #tmp_notable_query_text     FROM snapshots.notable_query_text AS qt     WHERE NOT EXISTS (         SELECT snapshot_id          FROM snapshots.query_stats AS qs         WHERE qs.[sql_handle] = qt.[sql_handle])      WHILE (@rows_affected = @delete_batch_size)     BEGIN         -- Deleting TOP N orphaned rows in query text table by joining info from temp table         -- This is done to speed up delete query.          DELETE TOP (@delete_batch_size) snapshots.notable_query_text           FROM snapshots.notable_query_text AS qt, #tmp_notable_query_text AS tmp         WHERE tmp.[sql_handle] = qt.[sql_handle]                  SET @rows_affected = @@ROWCOUNT;         IF(@rows_affected > 0)         BEGIN             RAISERROR ('Deleted %d orphaned rows from snapshots.notable_query_text', 0, 1, @rows_affected) WITH NOWAIT;         END          -- Check if the execution of the stored proc exceeded the @duration specified         IF (@duration IS NOT NULL)         BEGIN             IF (GETUTCDATE()>=@end_time)             BEGIN                 PRINT 'Stopping purge. More than ' + CONVERT(VARCHAR, @duration) + ' minutes passed since the start of operation.';                 BREAK             END         END          -- Check if somebody wanted to stop the purge operation         SELECT @stop_purge = COUNT(stop_purge) FROM [core].[purge_info_internal]         IF (@stop_purge > 0)         BEGIN             PRINT 'Stopping purge. Detected a user request to stop purge.';             BREAK         END     END;      PRINT 'End purging orphaned records in snapshots.notable_query_text Current UTC Time:' + CONVERT(VARCHAR, GETUTCDATE())  END  ",4,1,3,107,3,8
" ------------------------------- xp_logininfo ----------------------------------  create procedure sys.xp_logininfo 	@acctname		sysname = null,				-- IN: NT login name 	@option			varchar(10) = null,			-- IN: 'all' | 'members' | null 	@privilege		varchar(10) = 'Not wanted' OUTPUT	-- OUT: 'admin' | 'user' | null as 	set nocount on  	declare @ret		int  	-- VALIDATE PARAMETERS -- 	if (@acctname is null AND (@option is not null OR (@privilege is null OR @privilege <> 'Not wanted'))) 		OR ((@option is null OR @option <> 'all') AND (@privilege is null OR @privilege <> 'Not wanted')) 		OR (@option is not null and @option not in ('all', 'members')) 	begin         raiserror(15600,-1,-1,'sys.xp_logininfo')         return 1 	end   	-- HANDLE case where NO @acctname GIVEN -- 	if (@acctname is null) 	begin 		select	'account name' = loginname, 				'type' = convert(varchar(8), case when isntuser = 1 then 'user' else 'group' end), 				'privilege' = convert(varchar(8), case when sysadmin = 1 then 'admin' else 'user' end), 				'mapped login name' = loginname, 				'permission path' = convert(sysname, null) 		from master..syslogins where isntname = 1 and hasaccess = 1 		order by 3, 1 		return @@error 	end  	-- HANDLE 'members' QUERY -- 	if (@option = 'members') 	begin 		declare @priv varchar(8) 		select @priv = case when sysadmin = 1 then 'admin' else 'user' end 			from master..syslogins where isntname = 1 and loginname = @acctname and hasaccess = 1 		if @priv is not null 			select	'account name' = domain+N'\'+name, 					'type' = convert(varchar(8), case when sidtype = 1 then 'user' else 'group' end), 					'privilege' = @priv, 					'mapped login name' = domain+N'\'+name, 					'permission path' = @acctname 			from OpenRowset(TABLE NETGROUPGETMEMBERS, @acctname) order by 3, 1 		else 			select	'account name' = convert(sysname, null), 					'type' = convert(varchar(8), null), 					'privilege' = @priv, 					'mapped login name' = convert(sysname, null), 					'permission path' = convert(sysname, null) 			where 0=1	-- empty result set 		return @@error 	end   	-- CREATE TEMP TABLE AND POPULATE WITH THE REQUIRED DATA -- 	CREATE TABLE #nt (name sysname collate catalog_default, sid varbinary(85), sidtype int) 	insert #nt select loginname, sid, isntgroup + 1 from master..syslogins 			where isntname = 1 and loginname = @acctname 	insert #nt select distinct domain+N'\'+name, sid, sidtype 			from OpenRowset(TABLE NETUSERGETGROUPS, @acctname) 	select @ret = @@error 	if @ret <> 0 		return @ret 	-- IF ANY DENY, THEN NO ACCESS -- 	if exists (select * from master..syslogins where sid in (select #nt.sid from #nt) and denylogin = 1) 		delete #nt   	-- HANDLE case where OUTPUT REQUESTED -- 	if (@privilege is null OR @privilege <> 'Not wanted') 	begin 		select @privilege = case max(sysadmin) 			when 1 then 'admin' 			when 0 then 'user' 			else NULL end 		from master..syslogins where isntname = 1 and hasaccess = 1 			AND sid in (select sid from #nt) 		return @@error 	end   	-- GET NT TYPE FOR NEXT OPTIONS -- 	declare @type varchar(8) 	select @type = case when get_sid('\U'+@acctname) is null then 'group' else 'user' end  	-- HANDLE 'all' QUERY -- 	if (@option = 'all') 	begin 		select	'account name' = @acctname, 				'type' = @type, 				'privilege' = convert(varchar(8), case when sysadmin = 1 then 'admin' else 'user' end), 				'mapped login name' = @acctname, 				'permission path' = case when l.loginname = @acctname then NULL else l.loginname end 		from master..syslogins l join #nt n on l.isntname = 1 and l.sid = n.sid 		where l.loginname = n.name and hasaccess = 1 		order by 3, 5 		return @@error 	end   	-- HANDLE DEFAULT QUERY -- 	select	TOP 1 			'account name' = @acctname, 			'type' = @type, 			'privilege' = convert(varchar(8), case when sysadmin = 1 then 'admin' else 'user' end), 			'mapped login name' = @acctname, 			'permission path' = case when l.loginname = @acctname then NULL else l.loginname end 	from master..syslogins l join #nt n on l.isntname = 1 and l.sid = n.sid 	where l.loginname = n.name and hasaccess = 1 	order by 3, 5 	return @@error ",4,3,1,5,0,28
"       SELECT DB_ID() AS database_id, COUNT_BIG(*) as MemoryOptimizedScalarUDFCount       FROM sys.sql_modules m WITH(nolock) JOIN sys.objects o WITH(nolock) ON m.object_id=o.object_id       WHERE uses_native_compilation=1 and o.type='FN'     ",3,2,1,178,0,3
"       --In the following query, the certificate certificate key length, and the certificate encryption type for TDE are collected.       SELECT key_length, pvt_key_encryption_type, COUNT_BIG(*) AS cert_count FROM sys.certificates WITH(nolock) GROUP BY key_length, pvt_key_encryption_type     ",3,2,1,98,0,3
" CREATE PROCEDURE dbo.USP_RUN_ARCHIVE 		 	@ArchSrv		varchar(128), 	@ArchDb			varchar(128) as 	declare @mainserver varchar(128) 	declare @maindb varchar(128) 	declare @msg varchar(max) 	declare @dt datetime 	declare @postal_org_cd varchar(5) 	declare @retention int	 	declare @p_retention int	 	declare @c_retention int	 	declare @cmd varchar(8000) 	declare @eol char(2) 	declare @arch varchar(100)	 	declare @nsql nvarchar(4000) 	declare @canarchive bit 	declare @usesLinkedServer bit 		 	set @mainserver = convert(varchar(128), SERVERPROPERTY('ServerName')) 	set @maindb = db_name() 	set @eol = char(13) + char(10) 	set @arch = '[' + @ArchSrv + '].[' + @ArchDb + '].dbo.' 	 	if @ArchDb is not null 		set @canarchive = 1 	else 		set @canarchive = 0 	 	if @canarchive = 1 	begin 		if @mainserver = @ArchSrv 			set @usesLinkedServer = 0 		else 			set @usesLinkedServer = 1 	end  	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		if not exists(select * from sys.servers where name = @ArchSrv) 			exec sp_addlinkedserver @ArchSrv 		exec sp_serveroption @ArchSrv, 'DATA ACCESS', TRUE 	 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_XML_DATA_TYPE_TO_VARCHAR' 		exec sp_executesql @nsql 	end 	 	 	 	update M_OFFICES set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	update M_ORGANIZATIONS set COUNTRY_CD = 'ZZ' where COUNTRY_CD not in(select COUNTRY_CD from R_COUNTRIES) 	 	if @canarchive = 1 	begin 		 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_TRANSPORT_MODES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_ORGANIZATION_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_NATURE_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_FLOWS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_OBJECT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_MAIL_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_LANGUAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_HANDLING_CLASSES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_EDI_MESSAGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CUSTOMS_DECISION_CATEGORIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_COUNTRIES_CURRENCIES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'R_CDS_TYPES' 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ORGANIZATIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_OFFICES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_MAIL_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EXCHANGE_RATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_EDI_EXCHANGES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENT_TYPES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_STATES' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_CDS_EVENTTYPES_JOBS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_ALLOWED_CUSTOMS_DECISIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_STATE_ZIPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'M_HS_CHAPTERS_STD' 		 		 		 	 		 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_USERS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_FUNCTIONS_USER_GROUPS' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_CONFIG' 		exec USP_SYNCHRONIZE_TABLE @maindb, @ArchSrv, @ArchDb, 'A_LOCALIZATIONS' 	end 	 	declare @purge_dt datetime  	declare @log_retention int 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'GeneralLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 183), getdate())  	 	delete from M_EXCHANGE_RATES where MODIF_DT < @purge_dt 	 	 	delete from A_LOG_ENTRIES where LOG_ENTRY_DT < @purge_dt	 	 	select top 1 @log_retention = CONFIG_VALUE from A_CONFIG where CONFIG_KEY = 'AuditLogsRetentionDays' 	set @purge_dt = DATEADD(day, -isnull(@log_retention, 3286), getdate()) 	delete from A_AUDIT where CHANGE_DT < @purge_dt  	 	 	 	set @dt = getdate() 	select @msg = 'Archive/purge job, statistics before archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg 	 	create table #DECL_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	create table #RESP_PIDS(PID uniqueidentifier NOT NULL PRIMARY KEY) 	declare postal_org_cursor cursor for 	select ORGANIZATION_CD from M_ORGANIZATIONS  	where ORGANIZATION_TYPE_CD = 'P' and 		(exists(select 1 from O_DECLARATIONS (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD) or 		exists(select 1 from O_RESPONSES (nolock) where POST_ORGANIZATION_CD = ORGANIZATION_CD)) 		 	open postal_org_cursor 	fetch next from postal_org_cursor into @postal_org_cd 	while @@FETCH_STATUS = 0 	begin 		 		set @cmd = 'determine retention' 			 		if exists(select 1 from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention') 			select top 1 @retention = isnull(convert(int, CONFIG_VALUE), 0) from A_CONFIG where CONFIG_KEY = 'ArchivePurgeRetention' 		else 		begin 			select  				@p_retention = isnull(p.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0), 				@c_retention = isnull(c.PREFERENCES.value('(//CDSObjRetention)[1]', 'int'), 0) 			from M_ORGANIZATIONS p left join M_ORGANIZATIONS c on c.ORGANIZATION_CD = p.CUST_ORGANIZATION_CD 			where p.ORGANIZATION_CD = @postal_org_cd			 			 			set @retention =  				case 					when @p_retention >= @c_retention then @p_retention 					else @c_retention 				end 		end 				 		if @retention = 0   			set @retention = 60 			 		begin try 			truncate table #DECL_PIDS 							 			 			 			set @cmd = 'select declarations' 			insert into #DECL_PIDS 			select d.DECLARATION_PID  			from O_DECLARATIONS d (nolock)  			where  				d.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = d.DECLARATION_PID and dateadd(day, @retention, de.D_EVENT_GMT_DT) > getdate())   			select @msg = convert(varchar(30), (select count(1) from #DECL_PIDS (nolock))) + ' declarations selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = d.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd = 'insert into ' + @arch + 'O_DECLARATIONS(DECLARATION_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA, AN_DECLARATION_ID)' + @eol + 				'select d.DECLARATION_PID, d.MAIL_OBJECT_PID, d.POST_ORGANIZATION_CD, d.CUST_ORGANIZATION_CD, d.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), d.DATA), ' 				else  					set @cmd = @cmd + 'd.DATA, ' 				set @cmd = @cmd + 'd.AN_DECLARATION_ID from #DECL_PIDS dp inner join O_DECLARATIONS d on d.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS ad where ad.DECLARATION_PID = d.DECLARATION_PID)' + @eol 				print @Cmd 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATION_EVENTS(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select de.DECLARATION_PID, de.CDS_EVENT_TYPE_CD, de.D_EVENT_GMT_DT, de.EVENT_LOCAL_OFFSET, de.USER_CD, de.OFFICE_CD from #DECL_PIDS dp inner join O_DECLARATION_EVENTS de on de.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATION_EVENTS ade where ade.DECLARATION_PID = de.DECLARATION_PID and ade.CDS_EVENT_TYPE_CD = de.CDS_EVENT_TYPE_CD and ade.D_EVENT_GMT_DT = de.D_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_DECLARATIONS_HIST(DECLARATION_PID, CDS_EVENT_TYPE_CD, D_EVENT_GMT_DT, DATA)' + @eol + 				'select dh.DECLARATION_PID, dh.CDS_EVENT_TYPE_CD, dh.D_EVENT_GMT_DT, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), dh.DATA) ' 				else  					set @cmd = @cmd + 'dh.DATA ' 				set @cmd = @cmd + 'from #DECL_PIDS dp inner join O_DECLARATIONS_HIST dh on dh.DECLARATION_PID = dp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_DECLARATIONS_HIST adh where adh.DECLARATION_PID = dh.DECLARATION_PID and adh.CDS_EVENT_TYPE_CD = dh.CDS_EVENT_TYPE_CD and adh.D_EVENT_GMT_DT = dh.D_EVENT_GMT_DT)' + @eol  				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete declarations' 			delete from O_DECLARATIONS_HIST where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS_FOR_EXPORT where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATION_EVENTS where DECLARATION_PID in (select PID from #DECL_PIDS) 			delete from O_DECLARATIONS where DECLARATION_PID in (select PID from #DECL_PIDS) 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging declarations for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg 			 			delete from O_DECLARATIONS 			where not exists(select 1 from O_DECLARATION_EVENTS de where de.DECLARATION_PID = O_DECLARATIONS.DECLARATION_PID) 		end catch 		 		begin try 			truncate table #RESP_PIDS 			 			 			set @cmd = 'select responses' 			insert into #RESP_PIDS 			select r.RESPONSE_PID  			from O_RESPONSES r (nolock)  			where  				r.POST_ORGANIZATION_CD = @postal_org_cd and 				not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = r.RESPONSE_PID and dateadd(day, @retention, re.R_EVENT_GMT_DT) > getdate())  			 			select @msg = convert(varchar(30), (select count(1) from #RESP_PIDS (nolock))) + ' responses selected for archiving/purging' 			exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg  			if @canarchive = 1 			begin				 				 				set @cmd =  				'insert into ' + @arch + 'O_MAIL_OBJECTS(MAIL_OBJECT_PID, MAIL_OBJECT_ID, MAIL_OBJECT_LOCAL_ID, MAIL_OBJECT_TYPE_CD, MAIL_CLASS_CD, ORIG_POST_ORGANIZATION_CD, DEST_POST_ORGANIZATION_CD, MAIL_STATE_CD, MAIL_STATE_REMARKS, POSTING_DATE, MAIL_OBJECT_LOCAL_ID2, MAIL_CATEGORY_CD)' + @eol + 				'select distinct m.MAIL_OBJECT_PID, m.MAIL_OBJECT_ID, m.MAIL_OBJECT_LOCAL_ID, m.MAIL_OBJECT_TYPE_CD, m.MAIL_CLASS_CD, m.ORIG_POST_ORGANIZATION_CD, m.DEST_POST_ORGANIZATION_CD, m.MAIL_STATE_CD, m.MAIL_STATE_REMARKS, m.POSTING_DATE, m.MAIL_OBJECT_LOCAL_ID2, m.MAIL_CATEGORY_CD from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID inner join O_MAIL_OBJECTS m on m.MAIL_OBJECT_PID = r.MAIL_OBJECT_PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_MAIL_OBJECTS am where am.MAIL_OBJECT_PID = m.MAIL_OBJECT_PID) OPTION (FORCE ORDER)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES(RESPONSE_PID, MAIL_OBJECT_PID, POST_ORGANIZATION_CD, CUST_ORGANIZATION_CD, CDS_STATE_CD, DATA)' + @eol + 				'select r.RESPONSE_PID, r.MAIL_OBJECT_PID, r.POST_ORGANIZATION_CD, r.CUST_ORGANIZATION_CD, r.CDS_STATE_CD, '+ @eol 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), r.DATA) ' 				else  					set @cmd = @cmd + 'r.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES r on r.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES ar where ar.RESPONSE_PID = r.RESPONSE_PID)' + @eol			 				print @Cmd			 				exec(@cmd)	 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSE_EVENTS(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, EVENT_LOCAL_OFFSET, USER_CD, OFFICE_CD)' + @eol + 				'select re.RESPONSE_PID, re.CDS_EVENT_TYPE_CD, re.R_EVENT_GMT_DT, re.EVENT_LOCAL_OFFSET, re.USER_CD, re.OFFICE_CD from #RESP_PIDS rp inner join O_RESPONSE_EVENTS re on re.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSE_EVENTS are where are.RESPONSE_PID = re.RESPONSE_PID and are.CDS_EVENT_TYPE_CD = re.CDS_EVENT_TYPE_CD and are.R_EVENT_GMT_DT = re.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			 				 				set @cmd =  				'insert into ' + @arch + 'O_RESPONSES_HIST(RESPONSE_PID, CDS_EVENT_TYPE_CD, R_EVENT_GMT_DT, DATA)' + @eol + 				'select rh.RESPONSE_PID, rh.CDS_EVENT_TYPE_CD, rh.R_EVENT_GMT_DT, ' 				if @usesLinkedServer = 1  					set @cmd = @cmd + 'convert(nvarchar(max), rh.DATA) ' 				else  					set @cmd = @cmd + 'rh.DATA ' 				set @cmd = @cmd + 'from #RESP_PIDS rp inner join O_RESPONSES_HIST rh on rh.RESPONSE_PID = rp.PID' + @eol + 				'where not exists(select 1 from ' + @arch + 'O_RESPONSES_HIST arh where arh.RESPONSE_PID = rh.RESPONSE_PID and arh.CDS_EVENT_TYPE_CD = rh.CDS_EVENT_TYPE_CD and arh.R_EVENT_GMT_DT = rh.R_EVENT_GMT_DT)' + @eol			 				print @Cmd			 				exec(@cmd) 			end 			 			 			set @cmd = 'delete responses' 			delete from O_RESPONSES_HIST where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS_FOR_EXPORT where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSE_EVENTS where RESPONSE_PID in (select PID from #RESP_PIDS) 			delete from O_RESPONSES where RESPONSE_PID in (select PID from #RESP_PIDS) 			 			 			set @cmd = 'delete mail objects' 			delete from O_MAIL_OBJECTS  			where dateadd(day, @retention, POSTING_DATE) < getdate() and 				not exists(select 1 from O_DECLARATIONS d where d.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) and 				not exists(select 1 from O_RESPONSES r where r.MAIL_OBJECT_PID = O_MAIL_OBJECTS.MAIL_OBJECT_PID) 									 									 		end try 		begin catch 			select @msg = 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			print 'Archive/purge job, error archiving/purging responses for organization ' + @postal_org_cd + ', Error:' + ERROR_MESSAGE() + ', Command:' + @cmd 			set @dt = getdate() 			exec USP_SET_LOG_ENTRY 3, 1, @dt, @msg  			delete from O_RESPONSES 			where not exists(select 1 from O_RESPONSE_EVENTS re where re.RESPONSE_PID = O_RESPONSES.RESPONSE_PID) 		end catch 		 		fetch next from postal_org_cursor into @postal_org_cd 	end 	close postal_org_cursor 	deallocate postal_org_cursor  	 	declare @an_decl_dt_cutoff datetime 	set @an_decl_dt_cutoff = DATEADD(m, -1, getdate()) 	delete from O_AN_DECLARATIONS 	where POSTING_DATE < @an_decl_dt_cutoff 	 	set @dt = getdate()	 	select @msg = 'Archive/purge job, statistics after archiving/purging: ' + convert(varchar(30), (select count(1) from O_MAIL_OBJECTS (nolock))) + ' mail objects, ' + convert(varchar(30),(select count(1) from O_DECLARATIONS (nolock))) + ' declarations, ' + convert(varchar(30),(select count(1) from O_RESPONSES (nolock))) + ' responses, '  + convert(varchar(30),(select count(1) from O_AN_DECLARATIONS (nolock))) + ' anonymous declarations'  	exec USP_SET_LOG_ENTRY 3, 3, @dt, @msg						 	 	if @canarchive = 1 and @usesLinkedServer = 1 	begin 		 		set @nsql = N'exec ' + convert(nvarchar(max), @arch) + N'USP_CHANGE_VARCHAR_DATA_TYPE_TO_XML' 		exec sp_executesql @nsql	 	end ",3,3,0,6,0,850
"       SELECT DB_ID() AS database_id, COUNT_BIG(*) as MemoryOptimizedScalarUDFCount       FROM sys.sql_modules m WITH(nolock) JOIN sys.objects o WITH(nolock) ON m.object_id=o.object_id       WHERE uses_native_compilation=1 and o.type='FN'     ",3,2,1,139,0,3
"       SELECT DB_ID() AS database_id, COUNT_BIG(*) as MemoryOptimizedScalarUDFCount       FROM sys.sql_modules m WITH(nolock) JOIN sys.objects o WITH(nolock) ON m.object_id=o.object_id       WHERE uses_native_compilation=1 and o.type='FN'     ",3,2,1,221,0,3
"       SELECT COUNT_BIG(*) AS [NumOfNativeProcs], db_id() AS database_id FROM sys.sql_modules m WITH(nolock) JOIN sys.procedures p WITH(nolock) ON m.object_id=p.object_id WHERE uses_native_compilation=1     ",3,3,0,158,0,3
"   USE [master]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [tempdb]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [model]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [msdb]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [THPNSW]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [CDS_POST_THA]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [CDS_Achive]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;     USE [MDW_CDS]     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, 'SpaceUsed') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;",3,3,0,42,0,3
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       t.object_type,       i.is_disabled     ",3,3,0,422,0,3
" CREATE PROCEDURE [dbo].[sp_syscollector_event_oncollectionbegin]     @collection_set_id int,     @mode smallint = NULL,     @operator nvarchar(128) = NULL,     @log_id bigint OUTPUT AS BEGIN     SET NOCOUNT ON      -- Security check (role membership)     IF (NOT (ISNULL(IS_MEMBER(N'dc_proxy'), 0) = 1) AND NOT (ISNULL(IS_MEMBER(N'db_owner'), 0) = 1))     BEGIN         RAISERROR(14677, -1, -1, 'dc_proxy')         RETURN(1) -- Failure     END      -- Verify parameters     --      -- Check the collection_set_id     IF (@collection_set_id IS NULL)     BEGIN         RAISERROR(14606, -1, -1, '@collection_set_id')         RETURN (1)     END     ELSE IF (NOT EXISTS (SELECT collection_set_id FROM dbo.syscollector_collection_sets WHERE collection_set_id = @collection_set_id))     BEGIN         DECLARE @collection_set_id_as_char VARCHAR(36)         SELECT @collection_set_id_as_char = CONVERT(VARCHAR(36), @collection_set_id)          RAISERROR(14262, -1, -1, '@collection_set_id', @collection_set_id_as_char)         RETURN (1)     END       -- Default operator to currently logged in user     SET @operator = NULLIF(LTRIM(RTRIM(@operator)), '')     SET @operator = ISNULL(@operator, suser_sname())      -- Default mode to Collection     SET @mode = ISNULL(@mode, 0)      -- Find the parent log id.     -- It will be a log entry for the same collection set, with no parent and not finished     DECLARE @parent_log_id bigint     SELECT TOP 1 @parent_log_id = log_id FROM dbo.syscollector_execution_log_internal          WHERE collection_set_id = @collection_set_id          AND parent_log_id IS NULL         AND (@mode = 1 OR finish_time IS NULL)         ORDER BY start_time DESC      -- Insert the log record     --     INSERT INTO dbo.syscollector_execution_log_internal (         parent_log_id,          collection_set_id,          collection_item_id,         start_time,         last_iteration_time,         finish_time,         runtime_execution_mode,         [status],         operator,         package_id,         package_execution_id,         failure_message     ) VALUES (         @parent_log_id,         @collection_set_id,         NULL,         GETDATE(),         NULL,         NULL,         @mode,         0, -- Running         @operator,         NULL,         NULL,         NULL     )      SET @log_id = SCOPE_IDENTITY()                          RETURN (0) END ",3,3,0,1901,0,323
"       WITH CTE AS (       SELECT DISTINCT i.object_id oid, i.index_id iid       FROM sys.indexes i WITH(nolock)       JOIN sys.index_columns ic WITH(nolock) ON i.object_id = ic.object_id       JOIN sys.columns c WITH(nolock) ON ic.column_id = c.column_id AND c.object_id = i.object_id       WHERE c.system_type_id = 41 AND c.user_type_id = 41 -- only time columns       AND ic.key_ordinal != 0 -- only key columns       )       SELECT COUNT_BIG(*) AS [NumTimeIndices], db_id() AS database_id       FROM CTE     ",3,3,0,349,0,3
"       WITH CTE AS (       SELECT DISTINCT i.object_id oid, i.index_id iid       FROM sys.indexes i WITH(nolock)       JOIN sys.index_columns ic WITH(nolock) ON i.object_id = ic.object_id       JOIN sys.columns c WITH(nolock) ON ic.column_id = c.column_id AND c.object_id = i.object_id       WHERE c.system_type_id = 43 AND c.user_type_id = 43 -- only datetimeoffset columns       AND ic.key_ordinal != 0 -- only key columns       )       SELECT COUNT_BIG(*) AS [NumDatetimeoffsetCols], db_id() AS database_id       FROM CTE     ",2,2,0,540,0,2
