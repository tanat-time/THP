"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000),@_msparam_6 nvarchar(4000),@_msparam_7 nvarchar(4000))                 create table #tmp_sp_catalogs (is_catalog_support bit null,server_name nvarchar(128) null, product_name nvarchar(128) null,provider_name nvarchar(128) null,catalog_name nvarchar(128) null, description nvarchar(4000) null)                 declare @ServerName sysname                 declare @ProductName sysname                         declare @ProviderName sysname                 declare crs cursor local fast_forward                 for ( SELECT srv.name AS [Name], srv.product AS [ProductName], srv.provider AS [ProviderName] FROM sys.servers AS srv WHERE (srv.server_id != 0)and(srv.name=@_msparam_0) )                  open crs                  fetch crs into @ServerName,@ProductName,@ProviderName                 while @@fetch_status >= 0                  begin                 create table #tmp_catalog_exist_test (id int null,description sysname null,flags varchar null)                         DECLARE @IsCatalogSupport bit                   if (UPPER(@ProviderName) like 'SQLNCLI%' or UPPER(@ProviderName) like 'MSOLEDBSQL%' )                            begin                      set @IsCatalogSupport = 1                 end                 else                 begin                     insert into #tmp_catalog_exist_test(id,description,flags) EXEC master.dbo.xp_prop_oledb_provider @ProviderName                     select @IsCatalogSupport = count(*) from #tmp_catalog_exist_test  where id = 233                   end            if (@IsCatalogSupport = 0)                     begin                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                     end                     else                     begin                     BEGIN TRY                     insert into #tmp_sp_catalogs (catalog_name,description) EXEC master.dbo.sp_catalogs @server_name = @ServerName                     update #tmp_sp_catalogs set is_catalog_support = 1                     END TRY                     BEGIN CATCH                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                        END CATCH                     end                     update #tmp_sp_catalogs set server_name = @ServerName                     update #tmp_sp_catalogs set product_name = @ProductName                     update #tmp_sp_catalogs set provider_name = @ProviderName                     fetch crs into @ServerName,@ProductName,@ProviderName                 end                 close crs                 deallocate crs    				create table #tmp_sp_tables_ex (is_catalog_error bit null,server_name nvarchar(128) null,server_catalog_name nvarchar(128) null,TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null) 				 				create table #tmp_sp_tables_ex_all (TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null)                 declare @TableServerName sysname 				declare @TableCatalogName sysname 				declare @IsCatalogSupportExist bit                 declare TableServerCrs cursor local fast_forward                 for ( SELECT tsc.server_name AS [ServerName], tsc.catalog_name AS [Name], tsc.is_catalog_support AS [IsCatalogSupport] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name WHERE (tsc.catalog_name=@_msparam_1 and tsc.is_catalog_support=@_msparam_2)and((srv.server_id != 0)and(srv.name=@_msparam_3)) )                  open TableServerCrs                  fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 while @@fetch_status >= 0                  begin 				IF (@IsCatalogSupportExist=0) 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = NULL 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM TABLE','TABLE') 				update #tmp_sp_tables_ex set server_catalog_name = NULL 				END 				ELSE 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = @TableCatalogName 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM TABLE','TABLE') 				update #tmp_sp_tables_ex set server_catalog_name = @TableCatalogName 				END				                 update #tmp_sp_tables_ex set server_name = @TableServerName																                 fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 end                 close TableServerCrs                 deallocate TableServerCrs   SELECT tste.TABLE_NAME AS [Name], ISNULL(tste.TABLE_SCHEM,'') AS [Schema], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/LinkedServer[@Name=' + quotename(srv.name,'''') + ']' + '/LinkedServerCatalog[@Name=' + quotename(tsc.catalog_name,'''') + ' and @IsCatalogSupport=' + quotename(tsc.is_catalog_support,'''') + ']' + '/LinkedServerTable[@Name=' + quotename(tste.TABLE_NAME,'''') + ' and @Schema=' + quotename(ISNULL(tste.TABLE_SCHEM,''),'''') + ']' AS [Urn], case when ( tste.TABLE_SCHEM in ('') or (tste.TABLE_SCHEM IS NULL) ) then tste.TABLE_NAME else ISNULL(tste.TABLE_SCHEM,'')+'.'+tste.TABLE_NAME end AS [SchemaObjectName], case when tste.TABLE_TYPE in ('SYSTEM TABLE') then 1 else 0 end AS [IsSystemObject] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name INNER JOIN #tmp_sp_tables_ex AS tste ON tste.server_name=tsc.server_name WHERE (case when tste.TABLE_TYPE in ('SYSTEM TABLE') then 1 else 0 end=@_msparam_4)and((tsc.catalog_name=@_msparam_5 and tsc.is_catalog_support=@_msparam_6)and((srv.server_id != 0)and(srv.name=@_msparam_7))) ORDER BY [SchemaObjectName] ASC  			drop table #tmp_sp_tables_ex 			drop table #tmp_sp_tables_ex_all 		                   drop table #tmp_sp_catalogs                 drop table #tmp_catalog_exist_test               ",3118,2944,174,12783,83,6237
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000),@_msparam_6 nvarchar(4000),@_msparam_7 nvarchar(4000))                 create table #tmp_sp_catalogs (is_catalog_support bit null,server_name nvarchar(128) null, product_name nvarchar(128) null,provider_name nvarchar(128) null,catalog_name nvarchar(128) null, description nvarchar(4000) null)                 declare @ServerName sysname                 declare @ProductName sysname                         declare @ProviderName sysname                 declare crs cursor local fast_forward                 for ( SELECT srv.name AS [Name], srv.product AS [ProductName], srv.provider AS [ProviderName] FROM sys.servers AS srv WHERE (srv.server_id != 0)and(srv.name=@_msparam_0) )                  open crs                  fetch crs into @ServerName,@ProductName,@ProviderName                 while @@fetch_status >= 0                  begin                 create table #tmp_catalog_exist_test (id int null,description sysname null,flags varchar null)                         DECLARE @IsCatalogSupport bit                   if (UPPER(@ProviderName) like 'SQLNCLI%' or UPPER(@ProviderName) like 'MSOLEDBSQL%' )                            begin                      set @IsCatalogSupport = 1                 end                 else                 begin                     insert into #tmp_catalog_exist_test(id,description,flags) EXEC master.dbo.xp_prop_oledb_provider @ProviderName                     select @IsCatalogSupport = count(*) from #tmp_catalog_exist_test  where id = 233                   end            if (@IsCatalogSupport = 0)                     begin                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                     end                     else                     begin                     BEGIN TRY                     insert into #tmp_sp_catalogs (catalog_name,description) EXEC master.dbo.sp_catalogs @server_name = @ServerName                     update #tmp_sp_catalogs set is_catalog_support = 1                     END TRY                     BEGIN CATCH                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                        END CATCH                     end                     update #tmp_sp_catalogs set server_name = @ServerName                     update #tmp_sp_catalogs set product_name = @ProductName                     update #tmp_sp_catalogs set provider_name = @ProviderName                     fetch crs into @ServerName,@ProductName,@ProviderName                 end                 close crs                 deallocate crs    				create table #tmp_sp_tables_ex (is_catalog_error bit null,server_name nvarchar(128) null,server_catalog_name nvarchar(128) null,TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null) 				 				create table #tmp_sp_tables_ex_all (TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null)		                 declare @TableServerName sysname 				declare @TableCatalogName sysname 				declare @IsCatalogSupportExist bit                 declare TableServerCrs cursor local fast_forward                 for ( SELECT tsc.server_name AS [ServerName], tsc.catalog_name AS [Name], tsc.is_catalog_support AS [IsCatalogSupport] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name WHERE (tsc.catalog_name=@_msparam_1 and tsc.is_catalog_support=@_msparam_2)and((srv.server_id != 0)and(srv.name=@_msparam_3)) )                  open TableServerCrs                  fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 while @@fetch_status >= 0                  				begin 				IF (@IsCatalogSupportExist=0) 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = NULL 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = NULL 				END 				ELSE 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = @TableCatalogName 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = @TableCatalogName 				END				                 update #tmp_sp_tables_ex set server_name = @TableServerName																                 fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 end                 close TableServerCrs                 deallocate TableServerCrs   SELECT tste.TABLE_NAME AS [Name], ISNULL(tste.TABLE_SCHEM,'') AS [Schema], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/LinkedServer[@Name=' + quotename(srv.name,'''') + ']' + '/LinkedServerCatalog[@Name=' + quotename(tsc.catalog_name,'''') + ' and @IsCatalogSupport=' + quotename(tsc.is_catalog_support,'''') + ']' + '/LinkedServerView[@Name=' + quotename(tste.TABLE_NAME,'''') + ' and @Schema=' + quotename(ISNULL(tste.TABLE_SCHEM,''),'''') + ']' AS [Urn], case when ( tste.TABLE_SCHEM in ('') or (tste.TABLE_SCHEM IS NULL) ) then tste.TABLE_NAME else ISNULL(tste.TABLE_SCHEM,'')+'.'+tste.TABLE_NAME end AS [SchemaObjectName], case when tste.TABLE_TYPE in ('SYSTEM VIEW') then 1 else 0 end AS [IsSystemObject] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name INNER JOIN #tmp_sp_tables_ex AS tste ON tste.server_name=tsc.server_name WHERE (case when tste.TABLE_TYPE in ('SYSTEM VIEW') then 1 else 0 end=@_msparam_4)and((tsc.catalog_name=@_msparam_5 and tsc.is_catalog_support=@_msparam_6)and((srv.server_id != 0)and(srv.name=@_msparam_7))) ORDER BY [SchemaObjectName] ASC  			drop table #tmp_sp_tables_ex 			drop table #tmp_sp_tables_ex_all 		                   drop table #tmp_sp_catalogs                 drop table #tmp_catalog_exist_test               ",2771,2618,153,12823,81,2771
" create procedure sys.sp_tables_ex (     @table_server       sysname,     @table_name         sysname = null,     @table_schema       sysname = null,     @table_catalog      sysname = null,     @table_type         sysname = null,     @fUsePattern        bit = 1 -- To allow users to explicitly disable all pattern matching. ) as     if (@fUsePattern = 1) -- Does the user want it?     begin         if ((isnull(charindex('%', @table_name),0) = 0) and             (isnull(charindex('[', @table_name),0) = 0) and             (isnull(charindex('_', @table_name),0) = 0) and             (isnull(charindex('%', @table_schema),0) = 0) and             (isnull(charindex('[', @table_schema),0) = 0) and             (isnull(charindex('_', @table_schema),0) = 0) and             (isnull(charindex('%', @table_catalog),0) = 0) and             (isnull(charindex('[', @table_catalog),0) = 0) and             (isnull(charindex('_', @table_catalog),0) = 0))         begin             select @fUsePattern = 0 -- not a single wild char, so go the fast way.         end     end      if @fUsePattern = 0     begin         /* -- Debug output, do not remove it.         print '*************'         print 'No pattern matching.'         print @fUsePattern         print isnull(@table_server, '@table_server = null')         print isnull(@table_name, '@table_name = null')         print isnull(@table_schema, '@table_schema = null')         print isnull(@table_catalog, '@table_catalog = null')         print isnull(@table_type, '@table_type = null')         print '*************'         */         select             TABLE_CAT   = rt.TABLE_CATALOG,             TABLE_SCHEM = rt.TABLE_SCHEMA,             TABLE_NAME  = rt.TABLE_NAME,             TABLE_TYPE  = rt.TABLE_TYPE,             REMARKS     = convert(nvarchar(255),rt.DESCRIPTION)         from             -- We can not pass @table_type directly here, because in ODBC we enclose             -- it in '', which is not acceptable for OLEDB SProc.             sys.fn_remote_tables(@table_server,                                  @table_catalog,                                  @table_schema,                                  @table_name,                                  NULL) rt         where             (charindex ('' + TABLE_TYPE + '', @table_type) <> 0 or @table_type is NULL)         order by 4, 1, 2, 3     end     else     begin         /* -- Debug output, do not remove it.         print '*************'         print 'THERE IS pattern matching!'         print @fUsePattern         print isnull(@table_server, '@table_server = null')         print isnull(@table_name, '@table_name = null')         print isnull(@table_schema, '@table_schema = null')         print isnull(@table_catalog, '@table_catalog = null')         print isnull(@table_type, '@table_type = null')         print '*************'         */         select             TABLE_CAT   = TABLE_CATALOG,             TABLE_SCHEM = TABLE_SCHEMA,             TABLE_NAME  = TABLE_NAME,             TABLE_TYPE  = TABLE_TYPE,             REMARKS     = convert(nvarchar(255),DESCRIPTION)         from             sys.fn_remote_tables(@table_server,                                  @table_catalog,                                  NULL,                                  NULL,                                  NULL)         where             (TABLE_SCHEMA like @table_schema or              @table_schema is NULL or              (TABLE_SCHEMA is NULL and @table_schema = N'%')) and             (TABLE_CATALOG like @table_catalog or              @table_catalog is NULL or              (TABLE_CATALOG is NULL and @table_catalog = N'%')) and             (charindex ('' + TABLE_TYPE + '', @table_type) <> 0 or @table_type is NULL) and             (TABLE_NAME like @table_name or              @table_name is NULL)         order by 4, 1, 2, 3     end ",2647,2494,153,8024,50,21181
" create procedure sys.sp_columns_ex (     @table_server       sysname,     @table_name         sysname = null,     @table_schema       sysname = null,     @table_catalog      sysname = null,     @column_name        sysname = null,     @ODBCVer            int = 2 ) as     set nocount on     declare         @DBCOLUMNFLAGS_ISFIXEDLENGTH binary(1), @DBCOLUMNFLAGS_ISLONG   binary(1),         @DBCOLUMNFLAGS_ISROWVER binary(2),      @DBCOLUMNFLAGS_SS_ISVARIABLESCALE binary(4),         @fUsePattern bit      select @fUsePattern = 1      select         @DBCOLUMNFLAGS_ISFIXEDLENGTH    = 0x10, @DBCOLUMNFLAGS_ISLONG   = 0x80,         @DBCOLUMNFLAGS_ISROWVER      = 0x0200,  @DBCOLUMNFLAGS_SS_ISVARIABLESCALE = 0x40000000      declare         @DBTYPE_I2 smallint,            @DBTYPE_I4 smallint,         @DBTYPE_R4 smallint,            @DBTYPE_R8 smallint,         @DBTYPE_CY smallint,            @DBTYPE_DATE smallint,         @DBTYPE_BSTR smallint,          @DBTYPE_BOOL smallint,         @DBTYPE_VARNUMERIC smallint,    @DBTYPE_DECIMAL smallint,         @DBTYPE_UI1 smallint,           @DBTYPE_BYREF smallint,         @DBTYPE_I1 smallint,            @DBTYPE_UI2 smallint,         @DBTYPE_UI4 smallint,           @DBTYPE_I8 smallint,         @DBTYPE_UI8 smallint,           @DBTYPE_GUID smallint,         @DBTYPE_BYTES smallint,         @DBTYPE_STR smallint,         @DBTYPE_WSTR smallint,          @DBTYPE_NUMERIC smallint,         @DBTYPE_DBDATE smallint,        @DBTYPE_DBTIME smallint,         @DBTYPE_DBTIMESTAMP smallint,   @DBTYPE_XML smallint,         @DBTYPE_DBTIME2 smallint,       @DBTYPE_DBTIMESTAMPOFFSET smallint      if (@ODBCVer is null) or (@ODBCVer <> 3)         select @ODBCVer = 2      select         @DBTYPE_I2          = 2,    @DBTYPE_I4          = 3,         @DBTYPE_R4          = 4,    @DBTYPE_R8          = 5,         @DBTYPE_CY          = 6,    @DBTYPE_DATE        = 7,         @DBTYPE_BSTR        = 8,    @DBTYPE_BOOL        = 11,         @DBTYPE_VARNUMERIC  = 139,  @DBTYPE_DECIMAL     = 14,         @DBTYPE_UI1         = 17,   @DBTYPE_BYREF       = 16384,         @DBTYPE_I1          = 16,   @DBTYPE_UI2         = 18,         @DBTYPE_UI4         = 19,   @DBTYPE_I8          = 20,         @DBTYPE_UI8         = 21,   @DBTYPE_GUID        = 72,         @DBTYPE_BYTES       = 128,  @DBTYPE_STR         = 129,         @DBTYPE_WSTR        = 130,  @DBTYPE_NUMERIC     = 131,         @DBTYPE_DBDATE      = 133,  @DBTYPE_DBTIME      = 134,         @DBTYPE_DBTIMESTAMP = 135,  @DBTYPE_XML         = 141,         @DBTYPE_DBTIME2     = 145,  @DBTYPE_DBTIMESTAMPOFFSET = 146      declare         @ODS_SMALLINT_NOT_NULL tinyint, @ODS_INT_NULL tinyint,         @ODS_INT_NOT_NULL tinyint,      @ODS_TINYINT_NOT_NULL tinyint,         @ODS_REAL_NOT_NULL tinyint,     @ODS_FLOAT_NULL tinyint,         @ODS_FLOAT_NOT_NULL tinyint,    @ODS_MONEY_NULL tinyint,         @ODS_MONEY_NOT_NULL tinyint,    @ODS_DATETIME_NULL tinyint,         @ODS_DATETIME_NOT_NULL tinyint, @ODS_TEXT tinyint,         @ODS_BIT tinyint,               @ODS_DECIMAL tinyint,         @ODS_NUMERIC tinyint,           @ODS_GUID tinyint,         @ODS_IMAGE tinyint,             @ODS_TIMESTAMP tinyint,         @ODS_BINARY_NULL tinyint,       @ODS_BINARY_NOT_NULL tinyint,         @ODS_VARBINARY tinyint,         @ODS_CHAR_NULL tinyint,         @ODS_CHAR_NOT_NULL tinyint,     @ODS_VARCHAR tinyint,         @ODS_DATE tinyint,              @ODS_TIME tinyint,         @ODS_DATETIME2 tinyint,         @ODS_DATETIMEOFFSET tinyint      select         @ODS_IMAGE = 34,            @ODS_TEXT = 35,         @ODS_GUID = 36,             @ODS_BINARY_NULL = 37,         @ODS_VARBINARY = 37,        @ODS_INT_NULL = 38,         @ODS_CHAR_NULL = 39,        @ODS_VARCHAR = 39,         @ODS_TIMESTAMP = 45,        @ODS_BINARY_NOT_NULL = 45,         @ODS_CHAR_NOT_NULL = 47,    @ODS_TINYINT_NOT_NULL = 48,         @ODS_BIT = 50,              @ODS_SMALLINT_NOT_NULL = 52,         @ODS_INT_NOT_NULL = 56,     @ODS_REAL_NOT_NULL = 59,         @ODS_MONEY_NOT_NULL = 60,   @ODS_DATETIME_NOT_NULL = 61,         @ODS_FLOAT_NOT_NULL = 62,   @ODS_DECIMAL = 106,         @ODS_NUMERIC = 108,         @ODS_FLOAT_NULL = 109,         @ODS_MONEY_NULL = 110,      @ODS_DATETIME_NULL = 111,         @ODS_DATE = 40,             @ODS_TIME = 41,         @ODS_DATETIME2 = 42,        @ODS_DATETIMEOFFSET = 43      declare         @ODBC_GUID smallint,        @ODBC_NTEXT smallint,         @ODBC_NVARCHAR smallint,    @ODBC_NCHAR smallint,         @ODBC_BIT smallint,         @ODBC_TINYINT smallint,         @ODBC_IMAGE smallint,       @ODBC_VARBINARY smallint,         @ODBC_TIMESTAMP smallint,   @ODBC_BINARY smallint,         @ODBC_TEXT smallint,        @ODBC_CHAR smallint,         @ODBC_NUMERIC smallint,     @ODBC_DECIMAL smallint,         @ODBC_MONEY smallint,       @ODBC_INT smallint,         @ODBC_SMALLINT smallint,    @ODBC_FLOAT smallint,         @ODBC_REAL smallint,        @ODBC_VARCHAR smallint,         @ODBC_DATETIME smallint,    @ODBC_DATE smallint,         @ODBC_TIME2 smallint,       @ODBC_DATETIMEOFFSET smallint      select         @ODBC_GUID      = -11,  @ODBC_NTEXT     = -10,         @ODBC_NVARCHAR  = -9,   @ODBC_NCHAR     = -8,         @ODBC_BIT       = -7,   @ODBC_TINYINT   = -6,         @ODBC_IMAGE     = -4,   @ODBC_VARBINARY = -3,         @ODBC_TIMESTAMP = -2,   @ODBC_BINARY    = -2,         @ODBC_TEXT      = -1,   @ODBC_CHAR      = 1,         @ODBC_NUMERIC   = 2,    @ODBC_DECIMAL   = 3,         @ODBC_MONEY     = 3,    @ODBC_INT       = 4,         @ODBC_SMALLINT  = 5,    @ODBC_FLOAT     = 6,         @ODBC_REAL      = 7,    @ODBC_VARCHAR   = 12,         @ODBC_DATETIME  =   case @ODBCVer                                 when 2 then 11                                 else 93                             end,         @ODBC_DATE =        case @ODBCVer                                 when 2 then 9                                 else 91                             end,         @ODBC_TIME2 = -154,     @ODBC_DATETIMEOFFSET = -155      create table #tmp_columns     (         TABLE_CAT sysname collate catalog_default NULL,         TABLE_SCHEM sysname collate catalog_default NULL,         TABLE_NAME sysname  collate catalog_default NOT NULL,         COLUMN_NAME sysname collate catalog_default NULL,         DATA_TYPE smallint NOT NULL,         TYPE_NAME sysname  collate catalog_default NULL,         COLUMN_SIZE int NULL,         BUFFER_LENGTH int NULL,         DECIMAL_DIGITS smallint NULL,         NUM_PREC_RADIX smallint NULL,         NULLABLE smallint NOT NULL,         REMARKS nvarchar(254) collate catalog_default NULL,         COLUMN_DEF nvarchar(254) collate catalog_default NULL,         SQL_DATA_TYPE smallint null,         SQL_DATETIME_SUB smallint NULL,         CHAR_OCTET_LENGTH int NULL,         ORDINAL_POSITION smallint,         IS_NULLABLE varchar(254) collate catalog_default NOT NULL,         SS_DATA_TYPE tinyint null,-- Info here is for backward compatibility - SQL 6.5         COLUMN_FLAGS int NOT NULL -- This is not returned in the final resultset, but used in conditional logic     )      --     -- Gathers column info through DQ(OLEDB) from remote server.     --     if (@fUsePattern = 1) -- Does the user want it?     begin         if ((isnull(charindex('%', @table_name),0) = 0) and             (isnull(charindex('_', @table_name),0) = 0) and             (isnull(charindex('[', @table_name),0) = 0) and             (isnull(charindex('%', @table_schema),0) = 0) and             (isnull(charindex('_', @table_schema),0) = 0) and             (isnull(charindex('[', @table_schema),0) = 0))         begin             select @fUsePattern = 0 -- not a single wild char, so go the fast way.         end     end      if @fUsePattern = 0     begin         /* -- Debug output, do not remove it.         print '*************'         print 'No pattern matching.'         print @fUsePattern         print isnull(@table_name, '@table_name = null')         print isnull(@table_schema, '@table_schema = null')         print isnull(@column_name, '@column_name = null')         print '*************'         */         insert into #tmp_columns         select             TABLE_CAT           = c.TABLE_CATALOG,             TABLE_SCHEM         = c.TABLE_SCHEMA,             TABLE_NAME          = c.TABLE_NAME,             COLUMN_NAME         = c.COLUMN_NAME,             DATA_TYPE           = case c.DATA_TYPE & ~@DBTYPE_BYREF                                       when @DBTYPE_I2             then @ODBC_SMALLINT                                       when @DBTYPE_I4             then @ODBC_INT                                       when @DBTYPE_R4             then @ODBC_REAL                                       when @DBTYPE_R8             then @ODBC_FLOAT                                       when @DBTYPE_CY             then @ODBC_MONEY                                       when @DBTYPE_DATE           then @ODBC_DATETIME                                       when @DBTYPE_DBDATE         then @ODBC_DATE                                       when @DBTYPE_DBTIME         then @ODBC_DATETIME                                       when @DBTYPE_DBTIMESTAMP    then @ODBC_DATETIME                                       when @DBTYPE_BOOL           then @ODBC_BIT                                       when @DBTYPE_DECIMAL        then @ODBC_DECIMAL                                       when @DBTYPE_UI1            then @ODBC_TINYINT                                       when @DBTYPE_I1             then @ODBC_NUMERIC                                       when @DBTYPE_UI2            then @ODBC_NUMERIC                                       when @DBTYPE_UI4            then @ODBC_NUMERIC                                       when @DBTYPE_I8             then @ODBC_NUMERIC                                       when @DBTYPE_UI8            then @ODBC_NUMERIC                                       when @DBTYPE_NUMERIC        then @ODBC_NUMERIC                                       when @DBTYPE_VARNUMERIC     then @ODBC_NUMERIC                                       when @DBTYPE_GUID           then @ODBC_GUID                                       when @DBTYPE_DBTIME2        then @ODBC_TIME2                                       when @DBTYPE_DBTIMESTAMPOFFSET then @ODBC_DATETIMEOFFSET                                       when @DBTYPE_BYTES then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_IMAGE -- exclude varbinary(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                                       (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                                        p.COLUMN_SIZE = 8                                                   then @ODBC_TIMESTAMP                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                                   then @ODBC_BINARY                                               else @ODBC_VARBINARY -- default                                           end                                       when @DBTYPE_STR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_TEXT -- exclude varchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_CHAR                                               else @ODBC_VARCHAR -- default                                           end                                       when @DBTYPE_WSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_BSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_XML then @ODBC_NVARCHAR                                       else @ODBC_NVARCHAR -- Unknown OleDB datatype                                   end,             TYPE_NAME           = p.TYPE_NAME,             COLUMN_SIZE         = COALESCE(c.CHARACTER_MAXIMUM_LENGTH, c.NUMERIC_PRECISION, p.COLUMN_SIZE),             BUFFER_LENGTH       = c.CHARACTER_OCTET_LENGTH,             DECIMAL_DIGITS      = c.NUMERIC_SCALE,             NUM_PREC_RADIX      = NULL,             NULLABLE            = convert(smallint, c.IS_NULLABLE),             REMARKS             = convert(nvarchar(254),c.DESCRIPTION),             COLUMN_DEF          = convert(nvarchar(254),c.COLUMN_DEFAULT),             SQL_DATA_TYPE       = NULL,             SQL_DATETIME_SUB    = convert(smallint, c.DATETIME_PRECISION), -- temporary holder (to be updated later)             CHAR_OCTET_LENGTH   = c.CHARACTER_OCTET_LENGTH,             ORDINAL_POSITION    = c.ORDINAL_POSITION,             IS_NULLABLE         = case c.IS_NULLABLE                                     when 1 then 'YES'                                     else 'NO'                                   end,             SS_DATA_TYPE        = null,             COLUMN_FLAGS        = c.COLUMN_FLAGS         from             sys.fn_remote_columns (@table_server,@table_catalog,@table_schema,@table_name,NULL) c,             sys.fn_remote_provider_types (@table_server, NULL, NULL) p -- LUXOR/KAGERA don't support restricting DATA_TYPE         where             c.DATA_TYPE = p.DATA_TYPE and p.BEST_MATCH = 1             and             (                 c.COLUMN_NAME like @column_name or                 @column_name is NULL             )     end     else     begin         /* -- Debug output, do not remove it.         print '*************'         print 'THERE IS pattern matching!'         print @fUsePattern         print isnull(@table_name, '@table_name = null')         print isnull(@table_schema, '@table_schema = null')         print isnull(@column_name, '@column_name = null')         print '*************'         */         -- copy&pasted from above, but (1) and (2) are different         insert into #tmp_columns         select             TABLE_CAT           = c.TABLE_CATALOG,             TABLE_SCHEM         = c.TABLE_SCHEMA,             TABLE_NAME          = c.TABLE_NAME,             COLUMN_NAME         = c.COLUMN_NAME,             DATA_TYPE           = case c.DATA_TYPE & ~@DBTYPE_BYREF                                       when @DBTYPE_I2             then @ODBC_SMALLINT                                       when @DBTYPE_I4             then @ODBC_INT                                       when @DBTYPE_R4             then @ODBC_REAL                                       when @DBTYPE_R8             then @ODBC_FLOAT                                       when @DBTYPE_CY             then @ODBC_MONEY                                       when @DBTYPE_DATE           then @ODBC_DATETIME                                       when @DBTYPE_DBDATE         then @ODBC_DATE                                       when @DBTYPE_DBTIME         then @ODBC_DATETIME                                       when @DBTYPE_DBTIMESTAMP    then @ODBC_DATETIME                                       when @DBTYPE_BOOL           then @ODBC_BIT                                       when @DBTYPE_DECIMAL        then @ODBC_DECIMAL                                       when @DBTYPE_UI1            then @ODBC_TINYINT                                       when @DBTYPE_I1             then @ODBC_NUMERIC                                       when @DBTYPE_UI2            then @ODBC_NUMERIC                                       when @DBTYPE_UI4            then @ODBC_NUMERIC                                       when @DBTYPE_I8             then @ODBC_NUMERIC                                       when @DBTYPE_UI8            then @ODBC_NUMERIC                                       when @DBTYPE_NUMERIC        then @ODBC_NUMERIC                                       when @DBTYPE_VARNUMERIC     then @ODBC_NUMERIC                                       when @DBTYPE_GUID           then @ODBC_GUID                                       when @DBTYPE_DBTIME2        then @ODBC_TIME2                                       when @DBTYPE_DBTIMESTAMPOFFSET then @ODBC_DATETIMEOFFSET                                       when @DBTYPE_BYTES then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_IMAGE -- exclude varbinary(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                                       (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                                        p.COLUMN_SIZE = 8                                                   then @ODBC_TIMESTAMP                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                                   then @ODBC_BINARY                                               else @ODBC_VARBINARY -- default                                           end                                       when @DBTYPE_STR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_TEXT -- exclude varchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_CHAR                                               else @ODBC_VARCHAR -- default                                           end                                       when @DBTYPE_WSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_BSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_XML then @ODBC_NVARCHAR                                       else @ODBC_NVARCHAR -- Unknown OleDB datatype                                   end,             TYPE_NAME           = p.TYPE_NAME,             COLUMN_SIZE         = COALESCE(c.CHARACTER_MAXIMUM_LENGTH, c.NUMERIC_PRECISION, p.COLUMN_SIZE),             BUFFER_LENGTH       = c.CHARACTER_OCTET_LENGTH,             DECIMAL_DIGITS      = c.NUMERIC_SCALE,             NUM_PREC_RADIX      = NULL,             NULLABLE            = convert(smallint, c.IS_NULLABLE),             REMARKS             = convert(nvarchar(254),c.DESCRIPTION),             COLUMN_DEF          = convert(nvarchar(254),c.COLUMN_DEFAULT),             SQL_DATA_TYPE       = NULL,             SQL_DATETIME_SUB    = convert(smallint, c.DATETIME_PRECISION), -- temporary holder (to be updated later)             CHAR_OCTET_LENGTH   = c.CHARACTER_OCTET_LENGTH,             ORDINAL_POSITION    = c.ORDINAL_POSITION,             IS_NULLABLE         = case c.IS_NULLABLE                                       when 1 then 'YES'                                       else 'NO'                                   end,             SS_DATA_TYPE        = null,             COLUMN_FLAGS        = c.COLUMN_FLAGS         from             sys.fn_remote_columns (@table_server,@table_catalog,NULL,NULL,NULL) c, -- (1)             sys.fn_remote_provider_types (@table_server, NULL, NULL) p -- LUXOR/KAGERA don't support restricting DATA_TYPE         where             c.DATA_TYPE = p.DATA_TYPE and p.BEST_MATCH = 1 and             (                 TABLE_SCHEMA like @table_schema or                 @table_schema is NULL or                 (TABLE_SCHEMA is NULL and @table_schema = N'%')             )             and             (                 c.COLUMN_NAME like @column_name or                 @column_name is NULL             ) and             c.TABLE_NAME like @table_name -- (2)     end      --     -- Converts OLEDB types to ODBC types.     --     update #tmp_columns     set         DATA_TYPE               = case                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then @ODBC_NVARCHAR                                       when #tmp_columns.DATA_TYPE IN (@ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then @ODBC_NVARCHAR                                       else #tmp_columns.DATA_TYPE                                   end,         TYPE_NAME               = case                                       when #tmp_columns.DATA_TYPE = @ODBC_BINARY and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                            BUFFER_LENGTH = 8                                           then 'timestamp'                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then 'datetime2'                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 3                                           then 'datetime'                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 0                                           then 'smalldatetime'                                       when #tmp_columns.DATA_TYPE = @ODBC_MONEY and                                            #tmp_columns.COLUMN_SIZE = 10                                           then 'smallmoney'                                       when (#tmp_columns.DATA_TYPE in (@ODBC_BINARY, @ODBC_CHAR) and                                             (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH) or                                            #tmp_columns.DATA_TYPE in (@ODBC_TEXT, @ODBC_NTEXT, @ODBC_IMAGE)                                           then spt_dt.TYPE_NAME collate catalog_default                                       else isnull(#tmp_columns.TYPE_NAME, spt_dt.TYPE_NAME collate catalog_default)                                   end,         COLUMN_SIZE             = case                                       when #tmp_columns.DATA_TYPE IN (@ODBC_REAL, @ODBC_FLOAT) then -- app. numeric types                                           spt_dt.data_precision                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 19                                                   else                                                       (20 + #tmp_columns.SQL_DATETIME_SUB)                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 0                                           then 16                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 3                                           then 23                                       when #tmp_columns.DATA_TYPE = @ODBC_TIME2                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 8                                                   else                                                       (9 + #tmp_columns.SQL_DATETIME_SUB)                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIMEOFFSET                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 26                                                   else                                                       (27 + #tmp_columns.SQL_DATETIME_SUB)                                                   end                                       else #tmp_columns.COLUMN_SIZE                                   end,         BUFFER_LENGTH           = case                                       when #tmp_columns.DATA_TYPE IN (@ODBC_NUMERIC, @ODBC_DECIMAL) then  -- decimal/numeric types                                           COLUMN_SIZE+2                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 38 -- 19*2                                                   else                                                       (20 + #tmp_columns.SQL_DATETIME_SUB)*2                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATE                                           then 20                                       when #tmp_columns.DATA_TYPE = @ODBC_TIME2                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 16 -- 8*2                                                   else                                                       (9 + #tmp_columns.SQL_DATETIME_SUB)*2                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIMEOFFSET                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 52 -- 26*2                                                   else                                                       (27 + #tmp_columns.SQL_DATETIME_SUB)*2                                                   end                                       when isnull (#tmp_columns.BUFFER_LENGTH,0) = 0 then coalesce(spt_dt.length, spt_dt.data_precision)                                       else #tmp_columns.BUFFER_LENGTH                                   end,         DECIMAL_DIGITS          = case                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = 0                                           then #tmp_columns.SQL_DATETIME_SUB                                       when #tmp_columns.DATA_TYPE IN (@ODBC_DATETIME, @ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then NULL                                       else COALESCE (DECIMAL_DIGITS, spt_dt.numeric_scale)                                   end,         NUM_PREC_RADIX          = spt_dt.RADIX,         SQL_DATA_TYPE           = case                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then @ODBC_NVARCHAR                                       when #tmp_columns.DATA_TYPE IN (@ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then @ODBC_NVARCHAR                                       else spt_dt.SQL_DATA_TYPE                                   end,         SQL_DATETIME_SUB        = case -- used to be temporary holder for DATETIME_PRECISION, update it here                                       when #tmp_columns.DATA_TYPE in (@ODBC_DATETIME) and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = 0                                             then 3 -- SQL_CODE_TIMESTAMP                                       else null                                   end,         -- Info here is for backward compatibility - SQL 6.5         SS_DATA_TYPE            = case                                       when #tmp_columns.DATA_TYPE in ( @ODBC_TINYINT, @ODBC_SMALLINT, @ODBC_INT )                                           and #tmp_columns.NULLABLE = 1                                               then @ODS_INT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_TINYINT and #tmp_columns.NULLABLE = 0                                           then @ODS_TINYINT_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_SMALLINT    and #tmp_columns.NULLABLE = 0                                           then @ODS_SMALLINT_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_INT  and #tmp_columns.NULLABLE = 0                                           then @ODS_INT_NOT_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_REAL, @ODBC_FLOAT) and #tmp_columns.NULLABLE = 1                                           then @ODS_FLOAT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_REAL and #tmp_columns.NULLABLE = 0                                           then @ODS_REAL_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_FLOAT and #tmp_columns.NULLABLE = 0                                           then @ODS_FLOAT_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_MONEY and #tmp_columns.NULLABLE = 1                                           then @ODS_MONEY_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_MONEY and #tmp_columns.NULLABLE = 0                                           then @ODS_MONEY_NOT_NULL                                       -- New date/time types introduced in Katmai return 0                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then 0                                       when #tmp_columns.DATA_TYPE in (@ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then 0                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and #tmp_columns.NULLABLE = 1                                           then @ODS_DATETIME_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and #tmp_columns.NULLABLE = 0                                           then @ODS_DATETIME_NOT_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_NTEXT, @ODBC_TEXT)                                           then @ODS_TEXT                                       when #tmp_columns.DATA_TYPE = @ODBC_BIT                                           then @ODS_BIT                                       when #tmp_columns.DATA_TYPE = @ODBC_DECIMAL                                           then @ODS_DECIMAL                                       when #tmp_columns.DATA_TYPE = @ODBC_NUMERIC                                           then @ODS_NUMERIC                                       when #tmp_columns.DATA_TYPE = @ODBC_GUID                                           then @ODS_GUID                                       when #tmp_columns.DATA_TYPE = @ODBC_IMAGE                                           then @ODS_IMAGE                                       when #tmp_columns.DATA_TYPE = @ODBC_TIMESTAMP                                           and (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                               (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                               BUFFER_LENGTH = 8                                           then @ODS_TIMESTAMP                                       when #tmp_columns.DATA_TYPE = @ODBC_BINARY and #tmp_columns.NULLABLE =  1                                           and (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                           then  @ODS_BINARY_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_BINARY and #tmp_columns.NULLABLE =  0                                           and (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                           then @ODS_BINARY_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_VARBINARY                                           then @ODS_VARBINARY                                       when #tmp_columns.DATA_TYPE in (@ODBC_CHAR, @ODBC_NCHAR) and #tmp_columns.NULLABLE = 1                                           then @ODS_CHAR_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_CHAR, @ODBC_NCHAR) and #tmp_columns.NULLABLE = 0                                           then @ODS_CHAR_NOT_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_VARCHAR, @ODBC_NVARCHAR)                                           then @ODS_VARCHAR                                       else null                                   end         from             sys.spt_datatype_info spt_dt         where             spt_dt.DATA_TYPE = #tmp_columns.DATA_TYPE and             spt_dt.ODBCVer = @ODBCVer and             spt_dt.AUTO_INCREMENT = 0 and             spt_dt.TYPE_NAME <> 'smalldatetime' and             spt_dt.TYPE_NAME <> 'xml' -- DATA_TYPE for ntext and xml are the same, so allow just ntext here.     --     -- Final result is retunrned from the temporary table.     --     select         TABLE_CAT,         TABLE_SCHEM,         TABLE_NAME,         COLUMN_NAME,         DATA_TYPE,         TYPE_NAME,         COLUMN_SIZE,         BUFFER_LENGTH,         DECIMAL_DIGITS,         NUM_PREC_RADIX,         NULLABLE,         REMARKS,         COLUMN_DEF,         SQL_DATA_TYPE,         SQL_DATETIME_SUB,         CHAR_OCTET_LENGTH,         ORDINAL_POSITION,         IS_NULLABLE,         SS_DATA_TYPE     from         #tmp_columns     order by TABLE_CAT, TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION      drop table #tmp_columns ",2563,1812,751,198,0,10252
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000),@_msparam_6 nvarchar(4000),@_msparam_7 nvarchar(4000),@_msparam_8 nvarchar(4000))                 create table #tmp_sp_catalogs (is_catalog_support bit null,server_name nvarchar(128) null, product_name nvarchar(128) null,provider_name nvarchar(128) null,catalog_name nvarchar(128) null, description nvarchar(4000) null)                 declare @ServerName sysname                 declare @ProductName sysname                         declare @ProviderName sysname                 declare crs cursor local fast_forward                 for ( SELECT srv.name AS [Name], srv.product AS [ProductName], srv.provider AS [ProviderName] FROM sys.servers AS srv WHERE (srv.server_id != 0)and(srv.name=@_msparam_0) )                  open crs                  fetch crs into @ServerName,@ProductName,@ProviderName                 while @@fetch_status >= 0                  begin                 create table #tmp_catalog_exist_test (id int null,description sysname null,flags varchar null)                         DECLARE @IsCatalogSupport bit                   if (UPPER(@ProviderName) like 'SQLNCLI%' or UPPER(@ProviderName) like 'MSOLEDBSQL%' )                            begin                      set @IsCatalogSupport = 1                 end                 else                 begin                     insert into #tmp_catalog_exist_test(id,description,flags) EXEC master.dbo.xp_prop_oledb_provider @ProviderName                     select @IsCatalogSupport = count(*) from #tmp_catalog_exist_test  where id = 233                   end            if (@IsCatalogSupport = 0)                     begin                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                     end                     else                     begin                     BEGIN TRY                     insert into #tmp_sp_catalogs (catalog_name,description) EXEC master.dbo.sp_catalogs @server_name = @ServerName                     update #tmp_sp_catalogs set is_catalog_support = 1                     END TRY                     BEGIN CATCH                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                        END CATCH                     end                     update #tmp_sp_catalogs set server_name = @ServerName                     update #tmp_sp_catalogs set product_name = @ProductName                     update #tmp_sp_catalogs set provider_name = @ProviderName                     fetch crs into @ServerName,@ProductName,@ProviderName                 end                 close crs                 deallocate crs    				create table #tmp_sp_tables_ex (is_catalog_error bit null,server_name nvarchar(128) null,server_catalog_name nvarchar(128) null,TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null) 				 				create table #tmp_sp_tables_ex_all (TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null)		                 declare @TableServerName sysname 				declare @TableCatalogName sysname 				declare @IsCatalogSupportExist bit                 declare TableServerCrs cursor local fast_forward                 for ( SELECT tsc.server_name AS [ServerName], tsc.catalog_name AS [Name], tsc.is_catalog_support AS [IsCatalogSupport] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name WHERE (tsc.catalog_name=@_msparam_1 and tsc.is_catalog_support=@_msparam_2)and((srv.server_id != 0)and(srv.name=@_msparam_3)) )                  open TableServerCrs                  fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 while @@fetch_status >= 0                  				begin 				IF (@IsCatalogSupportExist=0) 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = NULL 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = NULL 				END 				ELSE 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = @TableCatalogName 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = @TableCatalogName 				END				                 update #tmp_sp_tables_ex set server_name = @TableServerName																                 fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 end                 close TableServerCrs                 deallocate TableServerCrs   SELECT ISNULL(tste.TABLE_CAT,'') AS [CatalogName] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name INNER JOIN #tmp_sp_tables_ex AS tste ON tste.server_name=tsc.server_name WHERE (tste.TABLE_NAME=@_msparam_4 and ISNULL(tste.TABLE_SCHEM,'')=@_msparam_5)and((tsc.catalog_name=@_msparam_6 and tsc.is_catalog_support=@_msparam_7)and((srv.server_id != 0)and(srv.name=@_msparam_8)))  			drop table #tmp_sp_tables_ex 			drop table #tmp_sp_tables_ex_all 		                   drop table #tmp_sp_catalogs                 drop table #tmp_catalog_exist_test               ",2541,2359,182,12775,73,7623
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000),@_msparam_6 nvarchar(4000),@_msparam_7 nvarchar(4000),@_msparam_8 nvarchar(4000))                 create table #tmp_sp_catalogs (is_catalog_support bit null,server_name nvarchar(128) null, product_name nvarchar(128) null,provider_name nvarchar(128) null,catalog_name nvarchar(128) null, description nvarchar(4000) null)                 declare @ServerName sysname                 declare @ProductName sysname                         declare @ProviderName sysname                 declare crs cursor local fast_forward                 for ( SELECT srv.name AS [Name], srv.product AS [ProductName], srv.provider AS [ProviderName] FROM sys.servers AS srv WHERE (srv.server_id != 0)and(srv.name=@_msparam_0) )                  open crs                  fetch crs into @ServerName,@ProductName,@ProviderName                 while @@fetch_status >= 0                  begin                 create table #tmp_catalog_exist_test (id int null,description sysname null,flags varchar null)                         DECLARE @IsCatalogSupport bit                   if (UPPER(@ProviderName) like 'SQLNCLI%' or UPPER(@ProviderName) like 'MSOLEDBSQL%' )                            begin                      set @IsCatalogSupport = 1                 end                 else                 begin                     insert into #tmp_catalog_exist_test(id,description,flags) EXEC master.dbo.xp_prop_oledb_provider @ProviderName                     select @IsCatalogSupport = count(*) from #tmp_catalog_exist_test  where id = 233                   end            if (@IsCatalogSupport = 0)                     begin                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                     end                     else                     begin                     BEGIN TRY                     insert into #tmp_sp_catalogs (catalog_name,description) EXEC master.dbo.sp_catalogs @server_name = @ServerName                     update #tmp_sp_catalogs set is_catalog_support = 1                     END TRY                     BEGIN CATCH                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                        END CATCH                     end                     update #tmp_sp_catalogs set server_name = @ServerName                     update #tmp_sp_catalogs set product_name = @ProductName                     update #tmp_sp_catalogs set provider_name = @ProviderName                     fetch crs into @ServerName,@ProductName,@ProviderName                 end                 close crs                 deallocate crs    				create table #tmp_sp_tables_ex (is_catalog_error bit null,server_name nvarchar(128) null,server_catalog_name nvarchar(128) null,TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null) 				 				create table #tmp_sp_tables_ex_all (TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null)                 declare @TableServerName sysname 				declare @TableCatalogName sysname 				declare @IsCatalogSupportExist bit                 declare TableServerCrs cursor local fast_forward                 for ( SELECT tsc.server_name AS [ServerName], tsc.catalog_name AS [Name], tsc.is_catalog_support AS [IsCatalogSupport] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name WHERE (tsc.catalog_name=@_msparam_1 and tsc.is_catalog_support=@_msparam_2)and((srv.server_id != 0)and(srv.name=@_msparam_3)) )                  open TableServerCrs                  fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 while @@fetch_status >= 0                  begin 				IF (@IsCatalogSupportExist=0) 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = NULL 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM TABLE','TABLE') 				update #tmp_sp_tables_ex set server_catalog_name = NULL 				END 				ELSE 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = @TableCatalogName 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM TABLE','TABLE') 				update #tmp_sp_tables_ex set server_catalog_name = @TableCatalogName 				END				                 update #tmp_sp_tables_ex set server_name = @TableServerName																                 fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 end                 close TableServerCrs                 deallocate TableServerCrs   SELECT ISNULL(tste.TABLE_CAT,'') AS [CatalogName] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name INNER JOIN #tmp_sp_tables_ex AS tste ON tste.server_name=tsc.server_name WHERE (tste.TABLE_NAME=@_msparam_4 and ISNULL(tste.TABLE_SCHEM,'')=@_msparam_5)and((tsc.catalog_name=@_msparam_6 and tsc.is_catalog_support=@_msparam_7)and((srv.server_id != 0)and(srv.name=@_msparam_8)))  			drop table #tmp_sp_tables_ex 			drop table #tmp_sp_tables_ex_all 		                   drop table #tmp_sp_catalogs                 drop table #tmp_catalog_exist_test               ",2293,2203,90,12812,79,4586
"       SELECT       db_id() AS database_id,       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.is_filestream,       c.encryption_type,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END AS is_user,       COUNT_BIG(*) AS [ColCount],       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END AS collation_name,       AVG(c.max_length) AS avg_max_length       FROM sys.columns c WITH (NOLOCK)       LEFT OUTER JOIN sys.objects o WITH (NOLOCK)       ON o.object_id = c.object_id       AND o.type = 'U'       GROUP BY       c.system_type_id,       c.user_type_id,       c.is_sparse,       c.is_column_set,       c.encryption_type,       c.is_filestream,       CASE WHEN o.object_id IS NOT NULL THEN 1 ELSE 0 END,       CASE WHEN c.collation_name IS NULL THEN CONVERT(VARCHAR(128), SERVERPROPERTY('Collation')) ELSE c.collation_name END     ",225,127,98,132,0,15817
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0  SELECT sqlserver_start_time, (committed_kb/1024) AS Total_Server_Memory_MB, (committed_target_kb/1024)  AS Target_Server_Memory_MB FROM sys.dm_os_sys_info; ",172,12,160,8092,315,344
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000)) create table #OLEDBProv ( Name sysname NOT NULL, ParseName sysname NOT  			NULL,Description sysname NOT NULL ) insert #OLEDBProv EXECUTE master.dbo.xp_enum_oledb_providers    			create table #OLEDBProvProp (ID int NOT NULL,Description sysname NOT NULL , Flags int NOT NULL, Name sysname null)  			declare name_cursor cursor  				FOR SELECT op.Name AS [Name] FROM #OLEDBProv op WHERE (op.Name=@_msparam_0)  				for read only  			open name_cursor  			DECLARE @providername sysname  			FETCH NEXT FROM name_cursor INTO @providername  			WHILE (@@FETCH_STATUS <> -1)  			BEGIN  				IF (@@FETCH_STATUS <> -2)  				BEGIN  					SELECT @providername = RTRIM(@providername)  					insert #OLEDBProvProp (ID,Description, Flags) EXECUTE master.dbo.xp_prop_oledb_provider @providername  					update #OLEDBProvProp set Name = @providername where Name is null 				END  				FETCH NEXT FROM name_cursor INTO @providername  			END  			CLOSE name_cursor  			DEALLOCATE name_cursor   SELECT prop.Name AS [Name], prop.ID AS [ID], prop.Description AS [Description], prop.Flags AS [Flags] FROM #OLEDBProv op INNER JOIN #OLEDBProvProp prop ON prop.Name=op.Name WHERE (op.Name=@_msparam_1)   			drop table #OLEDBProvProp 		   drop table #OLEDBProv  ",161,160,1,26,0,1293
"SELECT     DB_NAME (database_id) as [Database Name],     name as [Database File Name],     [Type] = CASE WHEN Type_Desc = 'ROWS' THEN 'Data File(s)'             WHEN Type_Desc = 'LOG'  THEN 'Log File(s)'             ELSE Type_Desc END,     size*8/1024 as 'Size (MB)',     physical_name as [Database_File_Location] FROM sys.master_files ORDER BY 1,3  IF OBJECT_ID('tempdb.dbo.#space') IS NOT NULL     DROP TABLE #space  CREATE TABLE #space (       database_id INT PRIMARY KEY     , data_used_size DECIMAL(18,2)     , log_used_size DECIMAL(18,2) )  DECLARE @SQL NVARCHAR(MAX)  SELECT @SQL = STUFF((     SELECT '     USE [' + d.name + ']     INSERT INTO #space (database_id, data_used_size, log_used_size)     SELECT           DB_ID()         , SUM(CASE WHEN [type] = 0 THEN space_used END)         , SUM(CASE WHEN [type] = 1 THEN space_used END)     FROM (         SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, ''SpaceUsed'') * 8. / 1024)         FROM sys.database_files s         GROUP BY s.[type]     ) t;'     FROM sys.databases d     WHERE d.[state] = 0     FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')  EXEC sys.sp_executesql @SQL  SELECT       d.database_id     , d.name     , d.state_desc     , d.recovery_model_desc     , t.total_size     , t.data_size     , s.data_used_size     , t.log_size     , s.log_used_size     , bu.full_last_date     , bu.full_size     , bu.log_last_date     , bu.log_size FROM (     SELECT           database_id         , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2))         , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2))     FROM sys.master_files     GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN #space s ON d.database_id = s.database_id LEFT JOIN (     SELECT           database_name         , full_last_date = MAX(CASE WHEN [type] = 'D' THEN backup_finish_date END)         , full_size = MAX(CASE WHEN [type] = 'D' THEN backup_size END)         , log_last_date = MAX(CASE WHEN [type] = 'L' THEN backup_finish_date END)         , log_size = MAX(CASE WHEN [type] = 'L' THEN backup_size END)     FROM (         SELECT               s.database_name             , s.[type]             , s.backup_finish_date             , backup_size =                         CAST(CASE WHEN s.backup_size = s.compressed_backup_size                                     THEN s.backup_size                                     ELSE s.compressed_backup_size                         END / 1048576.0 AS DECIMAL(18,2))             , RowNum = ROW_NUMBER() OVER (PARTITION BY s.database_name, s.[type] ORDER BY s.backup_finish_date DESC)         FROM msdb.dbo.backupset s         WHERE s.[type] IN ('D', 'L')     ) f     WHERE f.RowNum = 1     GROUP BY f.database_name ) bu ON d.name = bu.database_name ORDER BY t.total_size DESC  SELECT      req.session_id     , req.total_elapsed_time AS duration_ms     , req.cpu_time AS cpu_time_ms     , req.total_elapsed_time - req.cpu_time AS wait_time     , req.logical_reads     , SUBSTRING (REPLACE (REPLACE (SUBSTRING (ST.text, (req.statement_start_offset/2) + 1,         ((CASE statement_end_offset            WHEN -1            THEN DATALENGTH(ST.text)              ELSE req.statement_end_offset          END - req.statement_start_offset)/2) + 1) , CHAR(10), ' '), CHAR(13), ' '),        1, 512)  AS statement_text   FROM sys.dm_exec_requests AS req     CROSS APPLY sys.dm_exec_sql_text(req.sql_handle) AS ST ORDER BY total_elapsed_time DESC;  SELECT top 100 t.text,      (qs.total_elapsed_time/1000) / qs.execution_count AS avg_elapsed_time,      (qs.total_worker_time/1000) / qs.execution_count AS avg_cpu_time,      ((qs.total_elapsed_time/1000) / qs.execution_count ) - ((qs.total_worker_time/1000) / qs.execution_count) AS avg_wait_time,      qs.total_logical_reads / qs.execution_count AS avg_logical_reads,      qs.total_logical_writes / qs.execution_count AS avg_writes,      (qs.total_elapsed_time/1000) AS cumulative_elapsed_time_all_executions FROM sys.dm_exec_query_stats qs      CROSS apply sys.Dm_exec_sql_text (sql_handle) t -- WHERE t.text like '<Your Query>%' -- Replace <Your Query> with your query or the beginning part of your query. The special chars like '[','_','%','^' in the query should be escaped. ORDER BY (qs.total_elapsed_time / qs.execution_count) DESC  --Deadlock sql check SELECT     session_id,     start_time,      [status],     command,     blocking_session_id,     wait_type,     wait_time,     open_transaction_count,     transaction_id,     total_elapsed_time,     Definition = CAST(text AS VARCHAR(MAX)) FROM     SYS.DM_EXEC_REQUESTS     CROSS APPLY sys.dm_exec_sql_text(sql_handle)  WHERE blocking_session_id != 0   ",139,9,130,5210,179,139
" create table #OLEDBProv ( Name sysname NOT NULL, ParseName sysname NOT  			NULL,Description sysname NOT NULL ) insert #OLEDBProv EXECUTE master.dbo.xp_enum_oledb_providers   SELECT op.Name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/OLEDBProvider[@Name=' + quotename(op.Name,'''') + ']' AS [Urn] FROM #OLEDBProv op ORDER BY [Name] ASC  drop table #OLEDBProv ",125,124,1,45,1,125
"(@_msparam_0 nvarchar(4000)) create table #OLEDBProv (id int identity(1,1), Name sysname NOT NULL, ParseName sysname NOT NULL,Description sysname NOT NULL ) 			   insert #OLEDBProv (Name, ParseName,Description) EXECUTE master.dbo.sp_enum_oledb_providers 			   			delete from #OLEDBProv where exists ( select 1 from #OLEDBProv oprov where oprov.Name = #OLEDBProv.Name and oprov.id < #OLEDBProv.id ) 		   SELECT op.Name AS [Name] FROM #OLEDBProv AS op WHERE (op.Name=@_msparam_0)  drop table #OLEDBProv ",122,121,1,49,0,244
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups        SELECT arcn.replica_server_name AS [ReplicaName], cm.member_name AS [NodeName], cm.member_type AS [MemberType], cm.member_state AS [MemberState], ISNULL(cm.number_of_quorum_votes, -1) AS [NumberOfQuorumVotes], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/ReplicaClusterNode[@ReplicaName=' + quotename(arcn.replica_server_name,'''') + ' and @NodeName=' + quotename(cm.member_name,'''') + ']' AS [Urn] FROM #tmpag_availability_groups AS AG INNER JOIN master.sys.dm_hadr_availability_replica_cluster_nodes AS arcn ON arcn.group_name=AG.name LEFT OUTER JOIN master.sys.dm_hadr_cluster_members AS cm ON UPPER(arcn.node_name) = UPPER(cm.member_name) WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups       ",121,95,26,5,0,121
"(@_msparam_0 nvarchar(4000)) create table #OLEDBProv (id int identity(1,1), Name sysname NOT NULL, ParseName sysname NOT NULL,Description sysname NOT NULL ) 			   insert #OLEDBProv (Name, ParseName,Description) EXECUTE master.dbo.sp_enum_oledb_providers 			   			delete from #OLEDBProv where exists ( select 1 from #OLEDBProv oprov where oprov.Name = #OLEDBProv.Name and oprov.id < #OLEDBProv.id ) 		   create table #oledbprop (allow_in_process bit, disallow_adhoc_access bit, dynamic_parameters bit, index_as_access_path bit, 				level_zero_only bit, nested_queries bit, non_transacted_updates bit, sql_server_like bit, provider_name sysname null)  		 declare name_cursor cursor local fast_forward 	FOR (select Name from  #OLEDBProv) open name_cursor  DECLARE @providername sysname  FETCH NEXT FROM name_cursor INTO @providername  WHILE (@@FETCH_STATUS <> -1)  BEGIN  	IF (@@FETCH_STATUS <> -2)  	BEGIN  		SELECT @providername = RTRIM(@providername)   		insert #oledbprop (provider_name, allow_in_process, disallow_adhoc_access, dynamic_parameters, index_as_access_path, level_zero_only,  			nested_queries, non_transacted_updates, sql_server_like)  		exec master.dbo.sp_MSset_oledb_prop @providername 	END  	FETCH NEXT FROM name_cursor INTO @providername  END  CLOSE name_cursor  DEALLOCATE name_cursor 		   SELECT op.Name AS [Name], op.Description AS [Description], o.allow_in_process AS [AllowInProcess], o.disallow_adhoc_access AS [DisallowAdHocAccess], o.dynamic_parameters AS [DynamicParameters], o.index_as_access_path AS [IndexAsAccessPath], o.level_zero_only AS [LevelZeroOnly], o.nested_queries AS [NestedQueries], o.non_transacted_updates AS [NonTransactedUpdates], o.sql_server_like AS [SqlServerLike] FROM #OLEDBProv AS op INNER JOIN #oledbprop AS o ON o.provider_name=op.Name WHERE (op.Name=@_msparam_0)  drop table #OLEDBProv   drop table #oledbprop 		 ",120,119,1,49,0,241
" create procedure sys.sp_columns_ex (     @table_server       sysname,     @table_name         sysname = null,     @table_schema       sysname = null,     @table_catalog      sysname = null,     @column_name        sysname = null,     @ODBCVer            int = 2 ) as     set nocount on     declare         @DBCOLUMNFLAGS_ISFIXEDLENGTH binary(1), @DBCOLUMNFLAGS_ISLONG   binary(1),         @DBCOLUMNFLAGS_ISROWVER binary(2),      @DBCOLUMNFLAGS_SS_ISVARIABLESCALE binary(4),         @fUsePattern bit      select @fUsePattern = 1      select         @DBCOLUMNFLAGS_ISFIXEDLENGTH    = 0x10, @DBCOLUMNFLAGS_ISLONG   = 0x80,         @DBCOLUMNFLAGS_ISROWVER      = 0x0200,  @DBCOLUMNFLAGS_SS_ISVARIABLESCALE = 0x40000000      declare         @DBTYPE_I2 smallint,            @DBTYPE_I4 smallint,         @DBTYPE_R4 smallint,            @DBTYPE_R8 smallint,         @DBTYPE_CY smallint,            @DBTYPE_DATE smallint,         @DBTYPE_BSTR smallint,          @DBTYPE_BOOL smallint,         @DBTYPE_VARNUMERIC smallint,    @DBTYPE_DECIMAL smallint,         @DBTYPE_UI1 smallint,           @DBTYPE_BYREF smallint,         @DBTYPE_I1 smallint,            @DBTYPE_UI2 smallint,         @DBTYPE_UI4 smallint,           @DBTYPE_I8 smallint,         @DBTYPE_UI8 smallint,           @DBTYPE_GUID smallint,         @DBTYPE_BYTES smallint,         @DBTYPE_STR smallint,         @DBTYPE_WSTR smallint,          @DBTYPE_NUMERIC smallint,         @DBTYPE_DBDATE smallint,        @DBTYPE_DBTIME smallint,         @DBTYPE_DBTIMESTAMP smallint,   @DBTYPE_XML smallint,         @DBTYPE_DBTIME2 smallint,       @DBTYPE_DBTIMESTAMPOFFSET smallint      if (@ODBCVer is null) or (@ODBCVer <> 3)         select @ODBCVer = 2      select         @DBTYPE_I2          = 2,    @DBTYPE_I4          = 3,         @DBTYPE_R4          = 4,    @DBTYPE_R8          = 5,         @DBTYPE_CY          = 6,    @DBTYPE_DATE        = 7,         @DBTYPE_BSTR        = 8,    @DBTYPE_BOOL        = 11,         @DBTYPE_VARNUMERIC  = 139,  @DBTYPE_DECIMAL     = 14,         @DBTYPE_UI1         = 17,   @DBTYPE_BYREF       = 16384,         @DBTYPE_I1          = 16,   @DBTYPE_UI2         = 18,         @DBTYPE_UI4         = 19,   @DBTYPE_I8          = 20,         @DBTYPE_UI8         = 21,   @DBTYPE_GUID        = 72,         @DBTYPE_BYTES       = 128,  @DBTYPE_STR         = 129,         @DBTYPE_WSTR        = 130,  @DBTYPE_NUMERIC     = 131,         @DBTYPE_DBDATE      = 133,  @DBTYPE_DBTIME      = 134,         @DBTYPE_DBTIMESTAMP = 135,  @DBTYPE_XML         = 141,         @DBTYPE_DBTIME2     = 145,  @DBTYPE_DBTIMESTAMPOFFSET = 146      declare         @ODS_SMALLINT_NOT_NULL tinyint, @ODS_INT_NULL tinyint,         @ODS_INT_NOT_NULL tinyint,      @ODS_TINYINT_NOT_NULL tinyint,         @ODS_REAL_NOT_NULL tinyint,     @ODS_FLOAT_NULL tinyint,         @ODS_FLOAT_NOT_NULL tinyint,    @ODS_MONEY_NULL tinyint,         @ODS_MONEY_NOT_NULL tinyint,    @ODS_DATETIME_NULL tinyint,         @ODS_DATETIME_NOT_NULL tinyint, @ODS_TEXT tinyint,         @ODS_BIT tinyint,               @ODS_DECIMAL tinyint,         @ODS_NUMERIC tinyint,           @ODS_GUID tinyint,         @ODS_IMAGE tinyint,             @ODS_TIMESTAMP tinyint,         @ODS_BINARY_NULL tinyint,       @ODS_BINARY_NOT_NULL tinyint,         @ODS_VARBINARY tinyint,         @ODS_CHAR_NULL tinyint,         @ODS_CHAR_NOT_NULL tinyint,     @ODS_VARCHAR tinyint,         @ODS_DATE tinyint,              @ODS_TIME tinyint,         @ODS_DATETIME2 tinyint,         @ODS_DATETIMEOFFSET tinyint      select         @ODS_IMAGE = 34,            @ODS_TEXT = 35,         @ODS_GUID = 36,             @ODS_BINARY_NULL = 37,         @ODS_VARBINARY = 37,        @ODS_INT_NULL = 38,         @ODS_CHAR_NULL = 39,        @ODS_VARCHAR = 39,         @ODS_TIMESTAMP = 45,        @ODS_BINARY_NOT_NULL = 45,         @ODS_CHAR_NOT_NULL = 47,    @ODS_TINYINT_NOT_NULL = 48,         @ODS_BIT = 50,              @ODS_SMALLINT_NOT_NULL = 52,         @ODS_INT_NOT_NULL = 56,     @ODS_REAL_NOT_NULL = 59,         @ODS_MONEY_NOT_NULL = 60,   @ODS_DATETIME_NOT_NULL = 61,         @ODS_FLOAT_NOT_NULL = 62,   @ODS_DECIMAL = 106,         @ODS_NUMERIC = 108,         @ODS_FLOAT_NULL = 109,         @ODS_MONEY_NULL = 110,      @ODS_DATETIME_NULL = 111,         @ODS_DATE = 40,             @ODS_TIME = 41,         @ODS_DATETIME2 = 42,        @ODS_DATETIMEOFFSET = 43      declare         @ODBC_GUID smallint,        @ODBC_NTEXT smallint,         @ODBC_NVARCHAR smallint,    @ODBC_NCHAR smallint,         @ODBC_BIT smallint,         @ODBC_TINYINT smallint,         @ODBC_IMAGE smallint,       @ODBC_VARBINARY smallint,         @ODBC_TIMESTAMP smallint,   @ODBC_BINARY smallint,         @ODBC_TEXT smallint,        @ODBC_CHAR smallint,         @ODBC_NUMERIC smallint,     @ODBC_DECIMAL smallint,         @ODBC_MONEY smallint,       @ODBC_INT smallint,         @ODBC_SMALLINT smallint,    @ODBC_FLOAT smallint,         @ODBC_REAL smallint,        @ODBC_VARCHAR smallint,         @ODBC_DATETIME smallint,    @ODBC_DATE smallint,         @ODBC_TIME2 smallint,       @ODBC_DATETIMEOFFSET smallint      select         @ODBC_GUID      = -11,  @ODBC_NTEXT     = -10,         @ODBC_NVARCHAR  = -9,   @ODBC_NCHAR     = -8,         @ODBC_BIT       = -7,   @ODBC_TINYINT   = -6,         @ODBC_IMAGE     = -4,   @ODBC_VARBINARY = -3,         @ODBC_TIMESTAMP = -2,   @ODBC_BINARY    = -2,         @ODBC_TEXT      = -1,   @ODBC_CHAR      = 1,         @ODBC_NUMERIC   = 2,    @ODBC_DECIMAL   = 3,         @ODBC_MONEY     = 3,    @ODBC_INT       = 4,         @ODBC_SMALLINT  = 5,    @ODBC_FLOAT     = 6,         @ODBC_REAL      = 7,    @ODBC_VARCHAR   = 12,         @ODBC_DATETIME  =   case @ODBCVer                                 when 2 then 11                                 else 93                             end,         @ODBC_DATE =        case @ODBCVer                                 when 2 then 9                                 else 91                             end,         @ODBC_TIME2 = -154,     @ODBC_DATETIMEOFFSET = -155      create table #tmp_columns     (         TABLE_CAT sysname collate catalog_default NULL,         TABLE_SCHEM sysname collate catalog_default NULL,         TABLE_NAME sysname  collate catalog_default NOT NULL,         COLUMN_NAME sysname collate catalog_default NULL,         DATA_TYPE smallint NOT NULL,         TYPE_NAME sysname  collate catalog_default NULL,         COLUMN_SIZE int NULL,         BUFFER_LENGTH int NULL,         DECIMAL_DIGITS smallint NULL,         NUM_PREC_RADIX smallint NULL,         NULLABLE smallint NOT NULL,         REMARKS nvarchar(254) collate catalog_default NULL,         COLUMN_DEF nvarchar(254) collate catalog_default NULL,         SQL_DATA_TYPE smallint null,         SQL_DATETIME_SUB smallint NULL,         CHAR_OCTET_LENGTH int NULL,         ORDINAL_POSITION smallint,         IS_NULLABLE varchar(254) collate catalog_default NOT NULL,         SS_DATA_TYPE tinyint null,-- Info here is for backward compatibility - SQL 6.5         COLUMN_FLAGS int NOT NULL -- This is not returned in the final resultset, but used in conditional logic     )      --     -- Gathers column info through DQ(OLEDB) from remote server.     --     if (@fUsePattern = 1) -- Does the user want it?     begin         if ((isnull(charindex('%', @table_name),0) = 0) and             (isnull(charindex('_', @table_name),0) = 0) and             (isnull(charindex('[', @table_name),0) = 0) and             (isnull(charindex('%', @table_schema),0) = 0) and             (isnull(charindex('_', @table_schema),0) = 0) and             (isnull(charindex('[', @table_schema),0) = 0))         begin             select @fUsePattern = 0 -- not a single wild char, so go the fast way.         end     end      if @fUsePattern = 0     begin         /* -- Debug output, do not remove it.         print '*************'         print 'No pattern matching.'         print @fUsePattern         print isnull(@table_name, '@table_name = null')         print isnull(@table_schema, '@table_schema = null')         print isnull(@column_name, '@column_name = null')         print '*************'         */         insert into #tmp_columns         select             TABLE_CAT           = c.TABLE_CATALOG,             TABLE_SCHEM         = c.TABLE_SCHEMA,             TABLE_NAME          = c.TABLE_NAME,             COLUMN_NAME         = c.COLUMN_NAME,             DATA_TYPE           = case c.DATA_TYPE & ~@DBTYPE_BYREF                                       when @DBTYPE_I2             then @ODBC_SMALLINT                                       when @DBTYPE_I4             then @ODBC_INT                                       when @DBTYPE_R4             then @ODBC_REAL                                       when @DBTYPE_R8             then @ODBC_FLOAT                                       when @DBTYPE_CY             then @ODBC_MONEY                                       when @DBTYPE_DATE           then @ODBC_DATETIME                                       when @DBTYPE_DBDATE         then @ODBC_DATE                                       when @DBTYPE_DBTIME         then @ODBC_DATETIME                                       when @DBTYPE_DBTIMESTAMP    then @ODBC_DATETIME                                       when @DBTYPE_BOOL           then @ODBC_BIT                                       when @DBTYPE_DECIMAL        then @ODBC_DECIMAL                                       when @DBTYPE_UI1            then @ODBC_TINYINT                                       when @DBTYPE_I1             then @ODBC_NUMERIC                                       when @DBTYPE_UI2            then @ODBC_NUMERIC                                       when @DBTYPE_UI4            then @ODBC_NUMERIC                                       when @DBTYPE_I8             then @ODBC_NUMERIC                                       when @DBTYPE_UI8            then @ODBC_NUMERIC                                       when @DBTYPE_NUMERIC        then @ODBC_NUMERIC                                       when @DBTYPE_VARNUMERIC     then @ODBC_NUMERIC                                       when @DBTYPE_GUID           then @ODBC_GUID                                       when @DBTYPE_DBTIME2        then @ODBC_TIME2                                       when @DBTYPE_DBTIMESTAMPOFFSET then @ODBC_DATETIMEOFFSET                                       when @DBTYPE_BYTES then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_IMAGE -- exclude varbinary(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                                       (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                                        p.COLUMN_SIZE = 8                                                   then @ODBC_TIMESTAMP                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                                   then @ODBC_BINARY                                               else @ODBC_VARBINARY -- default                                           end                                       when @DBTYPE_STR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_TEXT -- exclude varchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_CHAR                                               else @ODBC_VARCHAR -- default                                           end                                       when @DBTYPE_WSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_BSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_XML then @ODBC_NVARCHAR                                       else @ODBC_NVARCHAR -- Unknown OleDB datatype                                   end,             TYPE_NAME           = p.TYPE_NAME,             COLUMN_SIZE         = COALESCE(c.CHARACTER_MAXIMUM_LENGTH, c.NUMERIC_PRECISION, p.COLUMN_SIZE),             BUFFER_LENGTH       = c.CHARACTER_OCTET_LENGTH,             DECIMAL_DIGITS      = c.NUMERIC_SCALE,             NUM_PREC_RADIX      = NULL,             NULLABLE            = convert(smallint, c.IS_NULLABLE),             REMARKS             = convert(nvarchar(254),c.DESCRIPTION),             COLUMN_DEF          = convert(nvarchar(254),c.COLUMN_DEFAULT),             SQL_DATA_TYPE       = NULL,             SQL_DATETIME_SUB    = convert(smallint, c.DATETIME_PRECISION), -- temporary holder (to be updated later)             CHAR_OCTET_LENGTH   = c.CHARACTER_OCTET_LENGTH,             ORDINAL_POSITION    = c.ORDINAL_POSITION,             IS_NULLABLE         = case c.IS_NULLABLE                                     when 1 then 'YES'                                     else 'NO'                                   end,             SS_DATA_TYPE        = null,             COLUMN_FLAGS        = c.COLUMN_FLAGS         from             sys.fn_remote_columns (@table_server,@table_catalog,@table_schema,@table_name,NULL) c,             sys.fn_remote_provider_types (@table_server, NULL, NULL) p -- LUXOR/KAGERA don't support restricting DATA_TYPE         where             c.DATA_TYPE = p.DATA_TYPE and p.BEST_MATCH = 1             and             (                 c.COLUMN_NAME like @column_name or                 @column_name is NULL             )     end     else     begin         /* -- Debug output, do not remove it.         print '*************'         print 'THERE IS pattern matching!'         print @fUsePattern         print isnull(@table_name, '@table_name = null')         print isnull(@table_schema, '@table_schema = null')         print isnull(@column_name, '@column_name = null')         print '*************'         */         -- copy&pasted from above, but (1) and (2) are different         insert into #tmp_columns         select             TABLE_CAT           = c.TABLE_CATALOG,             TABLE_SCHEM         = c.TABLE_SCHEMA,             TABLE_NAME          = c.TABLE_NAME,             COLUMN_NAME         = c.COLUMN_NAME,             DATA_TYPE           = case c.DATA_TYPE & ~@DBTYPE_BYREF                                       when @DBTYPE_I2             then @ODBC_SMALLINT                                       when @DBTYPE_I4             then @ODBC_INT                                       when @DBTYPE_R4             then @ODBC_REAL                                       when @DBTYPE_R8             then @ODBC_FLOAT                                       when @DBTYPE_CY             then @ODBC_MONEY                                       when @DBTYPE_DATE           then @ODBC_DATETIME                                       when @DBTYPE_DBDATE         then @ODBC_DATE                                       when @DBTYPE_DBTIME         then @ODBC_DATETIME                                       when @DBTYPE_DBTIMESTAMP    then @ODBC_DATETIME                                       when @DBTYPE_BOOL           then @ODBC_BIT                                       when @DBTYPE_DECIMAL        then @ODBC_DECIMAL                                       when @DBTYPE_UI1            then @ODBC_TINYINT                                       when @DBTYPE_I1             then @ODBC_NUMERIC                                       when @DBTYPE_UI2            then @ODBC_NUMERIC                                       when @DBTYPE_UI4            then @ODBC_NUMERIC                                       when @DBTYPE_I8             then @ODBC_NUMERIC                                       when @DBTYPE_UI8            then @ODBC_NUMERIC                                       when @DBTYPE_NUMERIC        then @ODBC_NUMERIC                                       when @DBTYPE_VARNUMERIC     then @ODBC_NUMERIC                                       when @DBTYPE_GUID           then @ODBC_GUID                                       when @DBTYPE_DBTIME2        then @ODBC_TIME2                                       when @DBTYPE_DBTIMESTAMPOFFSET then @ODBC_DATETIMEOFFSET                                       when @DBTYPE_BYTES then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_IMAGE -- exclude varbinary(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                                       (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                                        p.COLUMN_SIZE = 8                                                   then @ODBC_TIMESTAMP                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                                   then @ODBC_BINARY                                               else @ODBC_VARBINARY -- default                                           end                                       when @DBTYPE_STR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG ) or (p.COLUMN_SIZE > 8000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_TEXT -- exclude varchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_CHAR                                               else @ODBC_VARCHAR -- default                                           end                                       when @DBTYPE_WSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_BSTR then                                           case                                               when ((c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISLONG = @DBCOLUMNFLAGS_ISLONG) or (p.COLUMN_SIZE > 4000)) and                                                    (c.CHARACTER_MAXIMUM_LENGTH <> 0) then @ODBC_NTEXT -- exclude nvarchar(max) here and use default                                               when (c.COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH) then @ODBC_NCHAR                                               else @ODBC_NVARCHAR -- default                                           end                                       when @DBTYPE_XML then @ODBC_NVARCHAR                                       else @ODBC_NVARCHAR -- Unknown OleDB datatype                                   end,             TYPE_NAME           = p.TYPE_NAME,             COLUMN_SIZE         = COALESCE(c.CHARACTER_MAXIMUM_LENGTH, c.NUMERIC_PRECISION, p.COLUMN_SIZE),             BUFFER_LENGTH       = c.CHARACTER_OCTET_LENGTH,             DECIMAL_DIGITS      = c.NUMERIC_SCALE,             NUM_PREC_RADIX      = NULL,             NULLABLE            = convert(smallint, c.IS_NULLABLE),             REMARKS             = convert(nvarchar(254),c.DESCRIPTION),             COLUMN_DEF          = convert(nvarchar(254),c.COLUMN_DEFAULT),             SQL_DATA_TYPE       = NULL,             SQL_DATETIME_SUB    = convert(smallint, c.DATETIME_PRECISION), -- temporary holder (to be updated later)             CHAR_OCTET_LENGTH   = c.CHARACTER_OCTET_LENGTH,             ORDINAL_POSITION    = c.ORDINAL_POSITION,             IS_NULLABLE         = case c.IS_NULLABLE                                       when 1 then 'YES'                                       else 'NO'                                   end,             SS_DATA_TYPE        = null,             COLUMN_FLAGS        = c.COLUMN_FLAGS         from             sys.fn_remote_columns (@table_server,@table_catalog,NULL,NULL,NULL) c, -- (1)             sys.fn_remote_provider_types (@table_server, NULL, NULL) p -- LUXOR/KAGERA don't support restricting DATA_TYPE         where             c.DATA_TYPE = p.DATA_TYPE and p.BEST_MATCH = 1 and             (                 TABLE_SCHEMA like @table_schema or                 @table_schema is NULL or                 (TABLE_SCHEMA is NULL and @table_schema = N'%')             )             and             (                 c.COLUMN_NAME like @column_name or                 @column_name is NULL             ) and             c.TABLE_NAME like @table_name -- (2)     end      --     -- Converts OLEDB types to ODBC types.     --     update #tmp_columns     set         DATA_TYPE               = case                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then @ODBC_NVARCHAR                                       when #tmp_columns.DATA_TYPE IN (@ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then @ODBC_NVARCHAR                                       else #tmp_columns.DATA_TYPE                                   end,         TYPE_NAME               = case                                       when #tmp_columns.DATA_TYPE = @ODBC_BINARY and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                            BUFFER_LENGTH = 8                                           then 'timestamp'                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then 'datetime2'                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 3                                           then 'datetime'                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 0                                           then 'smalldatetime'                                       when #tmp_columns.DATA_TYPE = @ODBC_MONEY and                                            #tmp_columns.COLUMN_SIZE = 10                                           then 'smallmoney'                                       when (#tmp_columns.DATA_TYPE in (@ODBC_BINARY, @ODBC_CHAR) and                                             (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH) or                                            #tmp_columns.DATA_TYPE in (@ODBC_TEXT, @ODBC_NTEXT, @ODBC_IMAGE)                                           then spt_dt.TYPE_NAME collate catalog_default                                       else isnull(#tmp_columns.TYPE_NAME, spt_dt.TYPE_NAME collate catalog_default)                                   end,         COLUMN_SIZE             = case                                       when #tmp_columns.DATA_TYPE IN (@ODBC_REAL, @ODBC_FLOAT) then -- app. numeric types                                           spt_dt.data_precision                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 19                                                   else                                                       (20 + #tmp_columns.SQL_DATETIME_SUB)                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 0                                           then 16                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            #tmp_columns.SQL_DATETIME_SUB = 3                                           then 23                                       when #tmp_columns.DATA_TYPE = @ODBC_TIME2                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 8                                                   else                                                       (9 + #tmp_columns.SQL_DATETIME_SUB)                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIMEOFFSET                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 26                                                   else                                                       (27 + #tmp_columns.SQL_DATETIME_SUB)                                                   end                                       else #tmp_columns.COLUMN_SIZE                                   end,         BUFFER_LENGTH           = case                                       when #tmp_columns.DATA_TYPE IN (@ODBC_NUMERIC, @ODBC_DECIMAL) then  -- decimal/numeric types                                           COLUMN_SIZE+2                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 38 -- 19*2                                                   else                                                       (20 + #tmp_columns.SQL_DATETIME_SUB)*2                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATE                                           then 20                                       when #tmp_columns.DATA_TYPE = @ODBC_TIME2                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 16 -- 8*2                                                   else                                                       (9 + #tmp_columns.SQL_DATETIME_SUB)*2                                                   end                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIMEOFFSET                                           then                                               case                                                   when #tmp_columns.SQL_DATETIME_SUB = 0                                                       then 52 -- 26*2                                                   else                                                       (27 + #tmp_columns.SQL_DATETIME_SUB)*2                                                   end                                       when isnull (#tmp_columns.BUFFER_LENGTH,0) = 0 then coalesce(spt_dt.length, spt_dt.data_precision)                                       else #tmp_columns.BUFFER_LENGTH                                   end,         DECIMAL_DIGITS          = case                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = 0                                           then #tmp_columns.SQL_DATETIME_SUB                                       when #tmp_columns.DATA_TYPE IN (@ODBC_DATETIME, @ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then NULL                                       else COALESCE (DECIMAL_DIGITS, spt_dt.numeric_scale)                                   end,         NUM_PREC_RADIX          = spt_dt.RADIX,         SQL_DATA_TYPE           = case                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then @ODBC_NVARCHAR                                       when #tmp_columns.DATA_TYPE IN (@ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then @ODBC_NVARCHAR                                       else spt_dt.SQL_DATA_TYPE                                   end,         SQL_DATETIME_SUB        = case -- used to be temporary holder for DATETIME_PRECISION, update it here                                       when #tmp_columns.DATA_TYPE in (@ODBC_DATETIME) and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = 0                                             then 3 -- SQL_CODE_TIMESTAMP                                       else null                                   end,         -- Info here is for backward compatibility - SQL 6.5         SS_DATA_TYPE            = case                                       when #tmp_columns.DATA_TYPE in ( @ODBC_TINYINT, @ODBC_SMALLINT, @ODBC_INT )                                           and #tmp_columns.NULLABLE = 1                                               then @ODS_INT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_TINYINT and #tmp_columns.NULLABLE = 0                                           then @ODS_TINYINT_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_SMALLINT    and #tmp_columns.NULLABLE = 0                                           then @ODS_SMALLINT_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_INT  and #tmp_columns.NULLABLE = 0                                           then @ODS_INT_NOT_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_REAL, @ODBC_FLOAT) and #tmp_columns.NULLABLE = 1                                           then @ODS_FLOAT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_REAL and #tmp_columns.NULLABLE = 0                                           then @ODS_REAL_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_FLOAT and #tmp_columns.NULLABLE = 0                                           then @ODS_FLOAT_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_MONEY and #tmp_columns.NULLABLE = 1                                           then @ODS_MONEY_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_MONEY and #tmp_columns.NULLABLE = 0                                           then @ODS_MONEY_NOT_NULL                                       -- New date/time types introduced in Katmai return 0                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and                                            (COLUMN_FLAGS & @DBCOLUMNFLAGS_SS_ISVARIABLESCALE) = @DBCOLUMNFLAGS_SS_ISVARIABLESCALE                                           then 0                                       when #tmp_columns.DATA_TYPE in (@ODBC_DATE, @ODBC_TIME2, @ODBC_DATETIMEOFFSET)                                           then 0                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and #tmp_columns.NULLABLE = 1                                           then @ODS_DATETIME_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_DATETIME and #tmp_columns.NULLABLE = 0                                           then @ODS_DATETIME_NOT_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_NTEXT, @ODBC_TEXT)                                           then @ODS_TEXT                                       when #tmp_columns.DATA_TYPE = @ODBC_BIT                                           then @ODS_BIT                                       when #tmp_columns.DATA_TYPE = @ODBC_DECIMAL                                           then @ODS_DECIMAL                                       when #tmp_columns.DATA_TYPE = @ODBC_NUMERIC                                           then @ODS_NUMERIC                                       when #tmp_columns.DATA_TYPE = @ODBC_GUID                                           then @ODS_GUID                                       when #tmp_columns.DATA_TYPE = @ODBC_IMAGE                                           then @ODS_IMAGE                                       when #tmp_columns.DATA_TYPE = @ODBC_TIMESTAMP                                           and (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISROWVER) = @DBCOLUMNFLAGS_ISROWVER and                                               (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH) = @DBCOLUMNFLAGS_ISFIXEDLENGTH and                                               BUFFER_LENGTH = 8                                           then @ODS_TIMESTAMP                                       when #tmp_columns.DATA_TYPE = @ODBC_BINARY and #tmp_columns.NULLABLE =  1                                           and (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                           then  @ODS_BINARY_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_BINARY and #tmp_columns.NULLABLE =  0                                           and (COLUMN_FLAGS & @DBCOLUMNFLAGS_ISFIXEDLENGTH = @DBCOLUMNFLAGS_ISFIXEDLENGTH)                                           then @ODS_BINARY_NOT_NULL                                       when #tmp_columns.DATA_TYPE = @ODBC_VARBINARY                                           then @ODS_VARBINARY                                       when #tmp_columns.DATA_TYPE in (@ODBC_CHAR, @ODBC_NCHAR) and #tmp_columns.NULLABLE = 1                                           then @ODS_CHAR_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_CHAR, @ODBC_NCHAR) and #tmp_columns.NULLABLE = 0                                           then @ODS_CHAR_NOT_NULL                                       when #tmp_columns.DATA_TYPE in (@ODBC_VARCHAR, @ODBC_NVARCHAR)                                           then @ODS_VARCHAR                                       else null                                   end         from             sys.spt_datatype_info spt_dt         where             spt_dt.DATA_TYPE = #tmp_columns.DATA_TYPE and             spt_dt.ODBCVer = @ODBCVer and             spt_dt.AUTO_INCREMENT = 0 and             spt_dt.TYPE_NAME <> 'smalldatetime' and             spt_dt.TYPE_NAME <> 'xml' -- DATA_TYPE for ntext and xml are the same, so allow just ntext here.     --     -- Final result is retunrned from the temporary table.     --     select         TABLE_CAT,         TABLE_SCHEM,         TABLE_NAME,         COLUMN_NAME,         DATA_TYPE,         TYPE_NAME,         COLUMN_SIZE,         BUFFER_LENGTH,         DECIMAL_DIGITS,         NUM_PREC_RADIX,         NULLABLE,         REMARKS,         COLUMN_DEF,         SQL_DATA_TYPE,         SQL_DATETIME_SUB,         CHAR_OCTET_LENGTH,         ORDINAL_POSITION,         IS_NULLABLE,         SS_DATA_TYPE     from         #tmp_columns     order by TABLE_CAT, TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION      drop table #tmp_columns ",119,119,0,1809,4,119
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000)) create table #OLEDBProv ( Name sysname NOT NULL, ParseName sysname NOT  			NULL,Description sysname NOT NULL ) insert #OLEDBProv EXECUTE master.dbo.xp_enum_oledb_providers    			create table #OLEDBProvProp (ID int NOT NULL,Description sysname NOT NULL , Flags int NOT NULL, Name sysname null)  			declare name_cursor cursor  				FOR SELECT op.Name AS [Name] FROM #OLEDBProv op WHERE (op.Name=@_msparam_0)  				for read only  			open name_cursor  			DECLARE @providername sysname  			FETCH NEXT FROM name_cursor INTO @providername  			WHILE (@@FETCH_STATUS <> -1)  			BEGIN  				IF (@@FETCH_STATUS <> -2)  				BEGIN  					SELECT @providername = RTRIM(@providername)  					insert #OLEDBProvProp (ID,Description, Flags) EXECUTE master.dbo.xp_prop_oledb_provider @providername  					update #OLEDBProvProp set Name = @providername where Name is null 				END  				FETCH NEXT FROM name_cursor INTO @providername  			END  			CLOSE name_cursor  			DEALLOCATE name_cursor   SELECT prop.Name AS [Name], prop.ID AS [ID], prop.Description AS [Description], prop.Flags AS [Flags] FROM #OLEDBProv op INNER JOIN #OLEDBProvProp prop ON prop.Name=op.Name WHERE (op.Name=@_msparam_1)   			drop table #OLEDBProvProp 		   drop table #OLEDBProv  ",118,117,1,45,0,950
"()                 begin try                 declare @enable int;                 select top 1 @enable = convert(int,value_in_use) from sys.configurations where name = 'default trace enabled'                 if @enable = 1 --default trace is enabled                 begin                 declare @curr_tracefilename varchar(500);                 declare @base_tracefilename varchar(500);                 declare @indx int ;                 declare @temp_trace table (                 StartTime datetime                 ,       EventSubClass int                 ,       IntegerData int                 );                 declare @path_separator CHAR(1) ;                 set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;                  select @curr_tracefilename = path from sys.traces where is_default = 1 ;                 set @curr_tracefilename = reverse(@curr_tracefilename)                 select @indx  = PATINDEX('%'+@path_separator+'%', @curr_tracefilename)                 set @curr_tracefilename = reverse(@curr_tracefilename)                 set @base_tracefilename = LEFT( @curr_tracefilename, len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  insert into @temp_trace                 select StartTime                 ,       EventSubClass                 ,       IntegerData                 from ::fn_trace_gettable( @base_tracefilename, default )                 where EventClass = 81;                  update @temp_trace set IntegerData = -IntegerData where EventSubClass = 2;                  select   1 as row_no                 ,       StartTime                 ,       EventSubClass                 ,       IntegerData                 ,       case when IntegerData < 0                 then -IntegerData                 else IntegerData                 end ""Absolute""                 from @temp_trace                 where (datediff(dd,StartTime,getdate()) < 7) order by StartTime ;                 end                 else                 begin                 select top 0 1 as row_no, 1 as StartTime , 1 as EventSubClass, 1 as IntegerData, 1 as Absolute                 end                 end try                 begin catch                 select  -100 as row_no                 ,       ERROR_NUMBER()  as StartTime                 ,       ERROR_SEVERITY() as EventSubClass                 ,       ERROR_STATE()  as   IntegerData                 ,       ERROR_MESSAGE() as Absolute                 end catch               ",82,81,1,0,0,165
"SELECT 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/Collation[@Name=' + quotename(cl.name,'''') + ']' AS [Urn], cl.name AS [Name], CAST(COLLATIONPROPERTY(name, 'CodePage') AS int) AS [CodePage], CAST(COLLATIONPROPERTY(name, 'LCID') AS int) AS [LocaleID], CAST(COLLATIONPROPERTY(name, 'ComparisonStyle') AS int) AS [ComparisonStyle], cl.description AS [Description], CAST(COLLATIONPROPERTY(name, 'Version') AS int) AS [CollationVersion] FROM sys.fn_helpcollations() cl ORDER BY [Name] ASC",75,39,36,0,0,75
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",72,63,9,89471,0,217
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))SELECT 'XEStore[@Name=' + quotename(CAST(SERVERPROPERTY(N'ServerName') AS sysname),'''') + ']' + '/Session[@Name=' + quotename(session.name,'''') + ']' + '/Event[@Name=' + quotename(event.package + '.' + event.name,'''') + ']' AS [Urn], event.event_id AS [ID], event.package + '.' + event.name AS [Name], event.module AS [ModuleID], event.package AS [PackageName], event.predicate AS [PredicateExpression], event.predicate_xml AS [PredicateXml], object2.description AS [Description] FROM sys.server_event_sessions AS session LEFT OUTER JOIN sys.dm_xe_sessions AS running ON running.name = session.name, sys.server_event_session_events AS event INNER JOIN sys.dm_xe_objects AS object2 ON event.name = object2.name AND object2.object_type='event' INNER JOIN sys.dm_xe_packages AS package2 ON event.module = package2.module_guid AND event.package = package2.name AND package2.guid = object2.package_guid WHERE (session.event_session_id = event.event_session_id)and((session.name=@_msparam_0)and((CAST(SERVERPROPERTY(N'ServerName') AS sysname)=@_msparam_1)))",71,71,0,182,0,71
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",63,45,18,81204,0,382
" 	SELECT 	CASE 		WHEN name like  '%msdtcprx.dll%' THEN 'msdtcprx' 		WHEN name like  '%sqljdbc_xa.dll%' THEN 'sqljdbc_xa' 		ELSE NULL 	END AS LoadedModules, 	COUNT(1) AS ModuleCount         FROM sys.dm_os_loaded_modules WITH (NOLOCK)         WHERE name like  '%msdtcprx.dll%' 	OR name like  '%sqljdbc_xa.dll%'         GROUP BY 	CASE WHEN name like  '%msdtcprx.dll%' THEN 'msdtcprx' 		WHEN name like  '%sqljdbc_xa.dll%' THEN 'sqljdbc_xa' 		ELSE NULL 	END;     ",63,63,0,0,0,4420
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags        SELECT AR.replica_server_name AS [Name], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], ISNULL(arstates.operational_state, 6) AS [OperationalState], suser_sname(AR.owner_sid) AS [Owner], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], AR.replica_id AS [UniqueId], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_availability_replica_cluster_states              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_replica_rollupstate              drop table #tmpag_availability_groups       ",57,42,15,99,1,57
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",52,38,14,94,1,157
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups               select replica_id, group_id into #tmpardb_availability_replicas from master.sys.availability_replicas              select replica_id, group_database_id, database_name,is_database_joined,is_failover_ready,is_pending_secondary_suspend,recovery_lsn,truncation_lsn into #tmpardb_database_replica_cluster_states from master.sys.dm_hadr_database_replica_cluster_states              select replica_id, is_local into #tmpardb_availability_replica_states from master.sys.dm_hadr_availability_replica_states        SELECT dbcs.database_name AS [Name] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpardb_availability_replicas AS AR ON AR.group_id=AG.group_id INNER JOIN #tmpardb_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1 INNER JOIN #tmpardb_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpardb_availability_replicas              DROP TABLE #tmpardb_database_replica_cluster_states              DROP TABLE #tmpardb_availability_replica_states              drop table #tmpag_availability_groups       ",50,39,11,213,1,101
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT SCHEMA_NAME(sp.schema_id) AS [Schema], sp.name AS [Name], sp.object_id AS [ID], CAST(  case      when sp.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = sp.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CASE WHEN sp.type = N'P' THEN 1 WHEN sp.type = N'PC' THEN 2 ELSE 1 END AS [ImplementationType], CAST(CASE WHEN ISNULL(smsp.definition, ssmsp.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = @_msparam_0 OR sp.type = @_msparam_1 OR sp.type=@_msparam_2) ORDER BY [Schema] ASC,[Name] ASC",50,43,7,81179,0,151
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups               select replica_id, group_id into #tmpardb_availability_replicas from master.sys.availability_replicas              select replica_id, group_database_id, database_name,is_database_joined,is_failover_ready,is_pending_secondary_suspend,recovery_lsn,truncation_lsn into #tmpardb_database_replica_cluster_states from master.sys.dm_hadr_database_replica_cluster_states              select replica_id, is_local into #tmpardb_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id, group_database_id,synchronization_state, is_suspended into #tmpardb_database_replica_states from master.sys.dm_hadr_database_replica_states        SELECT dbcs.database_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityDatabase[@Name=' + quotename(dbcs.database_name,'''') + ']' AS [Urn], ISNULL(dbrs.synchronization_state, 0) AS [SynchronizationState], ISNULL(dbrs.is_suspended, 0) AS [IsSuspended], ISNULL(dbcs.is_database_joined, 0) AS [IsJoined] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpardb_availability_replicas AS AR ON AR.group_id=AG.group_id INNER JOIN #tmpardb_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1 INNER JOIN #tmpardb_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id LEFT OUTER JOIN #tmpardb_database_replica_states AS dbrs ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpardb_availability_replicas              DROP TABLE #tmpardb_database_replica_cluster_states              DROP TABLE #tmpardb_availability_replica_states              DROP TABLE #tmpardb_database_replica_states              drop table #tmpag_availability_groups       ",46,35,11,224,0,92
"SELECT DISTINCT s.*,ep.value as description FROM master.sys.schemas s LEFT OUTER JOIN master.sys.extended_properties ep ON ep.class=3 AND ep.major_id=s.schema_id AND ep.minor_id=0 AND ep.name='MS_Description' INNER JOIN master.sys.all_objects o ON s.schema_id=o.schema_id",45,32,13,2465,0,182
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",42,31,11,86,1,85
"       SELECT       db_id() AS database_id,       o.[type] AS object_type,       i.[type] AS index_type,       p.[data_compression],       COUNT_BIG(DISTINCT p.[object_id]) AS NumTables,       COUNT_BIG(DISTINCT CAST(p.[object_id] AS VARCHAR(30)) + '|' + CAST(p.[index_id] AS VARCHAR(10))) AS NumIndexes,       ISNULL(px.[IsPartitioned], 0) AS IsPartitioned,       IIF(px.[IsPartitioned] = 1, COUNT_BIG(1), 0) NumPartitions,       SUM(p.[rows]) NumRows       FROM sys.partitions p       INNER JOIN sys.objects o       ON o.[object_id] = p.[object_id]       INNER JOIN sys.indexes i       ON i.[object_id] = p.[object_id]       AND i.[index_id] = p.[index_id]       OUTER APPLY (SELECT       x.[object_id], 1 AS [IsPartitioned]       FROM sys.partitions x       WHERE x.[object_id] = p.[object_id]       GROUP by       x.[object_id]       HAVING MAX(x.partition_number) > 1) px       WHERE o.[type] NOT IN ('S', 'IT')       GROUP BY       o.[type]       ,i.[type]       ,p.[data_compression]       ,px.[IsPartitioned]     ",40,25,15,1669,0,2868
"       WITH CTE AS (       SELECT DISTINCT i.object_id oid, i.index_id iid       FROM sys.indexes i WITH(nolock)       JOIN sys.index_columns ic WITH(nolock) ON i.object_id = ic.object_id       JOIN sys.columns c WITH(nolock) ON ic.column_id = c.column_id AND c.object_id = i.object_id       WHERE c.system_type_id = 43 AND c.user_type_id = 43 -- only datetimeoffset columns       AND ic.key_ordinal != 0 -- only key columns       )       SELECT COUNT_BIG(*) AS [NumDatetimeoffsetCols], db_id() AS database_id       FROM CTE     ",40,22,18,739,0,2867
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",37,35,2,6431,73,112
"       WITH CTE AS (       SELECT DISTINCT i.object_id oid, i.index_id iid       FROM sys.indexes i WITH(nolock)       JOIN sys.index_columns ic WITH(nolock) ON i.object_id = ic.object_id       JOIN sys.columns c WITH(nolock) ON ic.column_id = c.column_id AND c.object_id = i.object_id       WHERE c.system_type_id = 42 AND c.user_type_id = 42 -- only datetime2 columns       AND ic.key_ordinal != 0 -- only key columns       )       SELECT COUNT_BIG(*) AS [NumDatetime2Indices], db_id() AS database_id       FROM CTE     ",37,20,17,531,0,2604
"       WITH TablesAndViews AS       (SELECT object_id, 'table' AS object_type FROM sys.tables WITH(nolock) UNION ALL SELECT object_id, 'view' AS object_type FROM sys.views WITH(nolock))       SELECT       db_id() as database_id,       i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.is_disabled,       i.has_filter,       i.optimize_for_sequential_key,       COUNT_BIG(1) CountOfIndexes,       t.object_type       FROM sys.indexes i WITH(nolock)       INNER JOIN TablesAndViews t       ON t.object_id = i.object_id       GROUP BY i.type,       i.is_unique,       i.is_primary_key,       i.is_unique_constraint,       i.has_filter,       i.optimize_for_sequential_key,       t.object_type,       i.is_disabled     ",36,20,16,90,0,2555
"       SELECT ISNULL(AVG(c),0) AS [XTPAvgNumOfIndexes],       ISNULL(MAX(c),0) AS [XTPMaxNumOfIndexes], db_id() AS database_id       FROM (SELECT COUNT_BIG(*) AS c       FROM sys.indexes i WITH(nolock) JOIN sys.tables t WITH(nolock) ON i.object_id=t.object_id WHERE t.is_memory_optimized=1       GROUP BY i.object_id) a     ",34,18,16,402,0,2393
"       WITH CTE AS (       SELECT DISTINCT i.object_id oid, i.index_id iid       FROM sys.indexes i WITH(nolock)       JOIN sys.index_columns ic WITH(nolock) ON i.object_id = ic.object_id       JOIN sys.columns c WITH(nolock) ON ic.column_id = c.column_id AND c.object_id = i.object_id       WHERE c.system_type_id = 41 AND c.user_type_id = 41 -- only time columns       AND ic.key_ordinal != 0 -- only key columns       )       SELECT COUNT_BIG(*) AS [NumTimeIndices], db_id() AS database_id       FROM CTE     ",33,18,15,475,0,2338
"       SELECT       db_id() as database_id,       sm.[is_inlineable] AS InlineableScalarCount,​       sm.[inline_type] AS InlineType,​       COUNT_BIG(*) AS ScalarCount, ​       COUNT_BIG(CASE WHEN sm.[definition] LIKE '%getdate%' OR       sm.[definition] LIKE '%getutcdate%' OR ​       sm.[definition] LIKE '%sysdatetime%' OR​       sm.[definition] LIKE '%sysu​tcdatetime%' OR​       sm.[definition] LIKE '%sysdatetimeoffset%' OR​       sm.[definition] LIKE '%CURRENT_TIMESTAMP%'​       THEN 1       END) AS ScalarCountWithDate       FROM    [sys].[objects] o​       INNER JOIN    [sys].[sql_modules] sm       ON o.[object_id] = sm.[object_id]​       WHERE   o.[type] = 'FN'​       GROUP BY ​       sm.[is_inlineable],​       sm.[inline_type]     ",33,22,11,2623,0,2315
"       select 1 as name, -- Temp DB       case mf.type_desc       when 'ROWS' then 1       when 'LOG' then 2       end as 'type',       CAST(SUM(num_of_reads) as nvarchar(128)) as total_num_of_reads,       CAST(SUM(num_of_bytes_read) as nvarchar(128)) as total_num_of_bytes_read,       CAST(SUM(io_stall_read_ms) as nvarchar(128)) as total_io_stall_read_ms,       CAST(SUM(num_of_writes) as nvarchar(128)) as total_num_of_writes,       CAST(SUM(num_of_bytes_written) as nvarchar(128)) as total_num_of_bytes_written,       CAST(SUM(io_stall_write_ms) as nvarchar(128)) as total_io_stall_write_ms,       COUNT_BIG(*) as total       from sys.dm_io_virtual_file_stats(NULL, NULL) fs, sys.master_files mf       where fs.database_id = mf.database_id and fs.file_id = mf.file_id and fs.database_id = 2 and (fs.num_of_reads != 0 OR fs.num_of_writes != 0)       group by mf.name, mf.type, mf.type_desc        UNION ALL        select 2 as name, -- User DBs       case mf.type_desc       when 'ROWS' then 1       when 'LOG' then 2       end as 'type',       CAST(SUM(num_of_reads) as nvarchar(128)) as total_num_of_reads,       CAST(SUM(num_of_bytes_read) as nvarchar(128)) as total_num_of_bytes_read,       CAST(SUM(io_stall_read_ms) as nvarchar(128)) as total_io_stall_read_ms,       CAST(SUM(num_of_writes) as nvarchar(128)) as total_num_of_writes,       CAST(SUM(num_of_bytes_written) as nvarchar(128)) as total_num_of_bytes_written,       CAST(SUM(io_stall_write_ms) as nvarchar(128)) as total_io_stall_write_ms,       COUNT_BIG(*) as total       from sys.dm_io_virtual_file_stats(NULL, NULL) fs, sys.master_files mf       where fs.database_id = mf.database_id and fs.file_id = mf.file_id and fs.database_id > 4 and (fs.num_of_reads != 0 OR fs.num_of_writes != 0)       group by mf.type, mf.type_desc        UNION ALL        select 3 as name, -- System DBs       case mf.type_desc       when 'ROWS' then 1       when 'LOG' then 2       end as 'type',       CAST(SUM(num_of_reads) as nvarchar(128)) as total_num_of_reads,       CAST(SUM(num_of_bytes_read) as nvarchar(128)) as total_num_of_bytes_read,       CAST(SUM(io_stall_read_ms) as nvarchar(128)) as total_io_stall_read_ms,       CAST(SUM(num_of_writes) as nvarchar(128)) as total_num_of_writes,       CAST(SUM(num_of_bytes_written) as nvarchar(128)) as total_num_of_bytes_written,       CAST(SUM(io_stall_write_ms) as nvarchar(128)) as total_io_stall_write_ms,       COUNT_BIG(*) as total       from sys.dm_io_virtual_file_stats(NULL, NULL) fs, sys.master_files mf WITH(nolock)       where fs.database_id = mf.database_id and fs.file_id = mf.file_id and (fs.database_id = 1 OR fs.database_id = 3 OR fs.database_id = 4) and (fs.num_of_reads != 0 OR fs.num_of_writes != 0)       group by mf.type, mf.type_desc      ",29,28,1,103,0,177
"SELECT [TABFAM_ID]       ,[SHARD_LEVEL]       ,[COL_NAME]       ,[COL_NAME]       ,[COL_NAME]       ,[COL_NAME]       ,[COL_IDX_IN_KEY]       ,[EFF_TYPE]       ,[CHARACTER_SET]       ,[COL_TYPE]       ,[COL_SIZE]   FROM [ADSDB_SRV]..[GSMADMIN_INTERNAL].[LOCAL_CHUNK_COLUMNS] ",29,28,1,2,0,29
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT 'XEStore[@Name=' + quotename(CAST(SERVERPROPERTY(N'ServerName') AS sysname),'''') + ']' + '/Session[@Name=' + quotename(session.name,'''') + ']' + '/Event[@Name=' + quotename(event.package + '.' + event.name,'''') + ']' + '/EventField[@Name=' + quotename(col.name,'''') + ']' AS [Urn], ISNULL(field.object_id, -1) AS [ID], col.name AS [Name], field.value AS [Value], col.description AS [Description] FROM sys.server_event_sessions AS session LEFT OUTER JOIN sys.dm_xe_sessions AS running ON running.name = session.name, sys.server_event_session_events AS event INNER JOIN sys.dm_xe_objects AS object2 ON event.name = object2.name AND object2.object_type='event' INNER JOIN sys.dm_xe_packages AS package2 ON event.module = package2.module_guid AND event.package = package2.name AND package2.guid = object2.package_guid INNER JOIN sys.dm_xe_object_columns AS col ON event.name = col.object_name AND col.column_type = 'customizable' LEFT OUTER JOIN sys.server_event_session_fields AS field ON event.event_session_id = field.event_session_id AND event.event_id = field.object_id AND col.name = field.name INNER JOIN sys.dm_xe_packages AS package ON event.package = package.name AND package.guid = col.object_package_guid WHERE (session.event_session_id = event.event_session_id)and(event.package + '.' + event.name=@_msparam_0)and((session.name=@_msparam_1)and((CAST(SERVERPROPERTY(N'ServerName') AS sysname)=@_msparam_2)))",24,24,0,32,0,296
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT udf.name AS [Name], udf.object_id AS [ID], udf.create_date AS [CreateDate], udf.modify_date AS [DateLastModified], ISNULL(sudf.name, N'') AS [Owner], CAST(case when udf.principal_id is null then 1 else 0 end AS bit) AS [IsSchemaOwned], SCHEMA_NAME(udf.schema_id) AS [Schema], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], usrt.name AS [DataType], s1ret_param.name AS [DataTypeSchema], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], CASE WHEN usrt.is_table_type = 1 THEN N'structured' ELSE N'' END AS [UserType], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id,N'ExecIsAnsiNullsOn'),0) AS bit) AS [AnsiNullsStatus], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], case when amudf.object_id is null then N'' else asmbludf.name end AS [AssemblyName], case when amudf.object_id is null then N'' else amudf.assembly_class end AS [ClassName], case when amudf.object_id is null then N'' else amudf.assembly_method end AS [MethodName], CAST(case when amudf.object_id is null then CAST(smudf.null_on_null_input AS bit) else amudf.null_on_null_input end AS bit) AS [ReturnsNullOnNullInput], case when amudf.object_id is null then case isnull(smudf.execute_as_principal_id, -1) when -1 then 1 when -2 then 2 else 3 end else case isnull(amudf.execute_as_principal_id, -1) when -1 then 1 when -2 then 2 else 3 end end AS [ExecutionContext], case when amudf.object_id is null then ISNULL(user_name(smudf.execute_as_principal_id),N'') else ISNULL(user_name(amudf.execute_as_principal_id), N'') end AS [ExecutionContextPrincipal], CAST(OBJECTPROPERTYEX(udf.object_id, N'IsDeterministic') AS bit) AS [IsDeterministic], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id,N'ExecIsQuotedIdentOn'),0) AS bit) AS [QuotedIdentifierStatus], ret_param.name AS [TableVariableName], ISNULL(sm.uses_native_compilation,0) AS [IsNativelyCompiled], CAST(ISNULL(sm.inline_type,0) AS bit) AS [InlineType], CAST(ISNULL(sm.is_inlineable,0) AS bit) AS [IsInlineable], ISNULL(smudf.definition, ssmudf.definition) AS [Definition] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.database_principals AS sudf ON sudf.principal_id = ISNULL(udf.principal_id, (OBJECTPROPERTY(udf.object_id, 'OwnerId'))) LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.assembly_modules AS amudf ON amudf.object_id = udf.object_id LEFT OUTER JOIN sys.assemblies AS asmbludf ON asmbludf.assembly_id = amudf.assembly_id LEFT OUTER JOIN sys.all_sql_modules AS sm ON sm.object_id = udf.object_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))and(udf.name=@_msparam_1 and SCHEMA_NAME(udf.schema_id)=@_msparam_2)",23,23,0,112,0,23
"()           declare @ms_now bigint            select @ms_now = ms_ticks from sys.dm_os_sys_info;            select top 15 record_id,           dateadd(ms, -1 * (@ms_now - [timestamp]), GetDate()) as EventTime,           SQLProcessUtilization,           SystemIdle,           100 - SystemIdle - SQLProcessUtilization as OtherProcessUtilization           from (           select           record.value('(./Record/@id)[1]', 'int') as record_id,           record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') as SystemIdle,           record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') as SQLProcessUtilization,           timestamp           from (           select timestamp, convert(xml, record) as record           from sys.dm_os_ring_buffers           where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'           and record like '%SystemHealth%') as x 		) as y  	order by record_id desc",23,23,0,0,0,47
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT udf.name AS [Name], udf.object_id AS [ID], udf.create_date AS [CreateDate], udf.modify_date AS [DateLastModified], ISNULL(sudf.name, N'') AS [Owner], CAST(case when udf.principal_id is null then 1 else 0 end AS bit) AS [IsSchemaOwned], SCHEMA_NAME(udf.schema_id) AS [Schema], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], usrt.name AS [DataType], s1ret_param.name AS [DataTypeSchema], ISNULL(baset.name, N'') AS [SystemType], CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND ret_param.max_length <> -1 THEN ret_param.max_length/2 ELSE ret_param.max_length END AS int) AS [Length], CAST(ret_param.precision AS int) AS [NumericPrecision], CAST(ret_param.scale AS int) AS [NumericScale], ISNULL(xscret_param.name, N'') AS [XmlSchemaNamespace], ISNULL(s2ret_param.name, N'') AS [XmlSchemaNamespaceSchema], ISNULL( (case ret_param.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint], CASE WHEN usrt.is_table_type = 1 THEN N'structured' ELSE N'' END AS [UserType], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id,N'ExecIsAnsiNullsOn'),0) AS bit) AS [AnsiNullsStatus], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], case when amudf.object_id is null then N'' else asmbludf.name end AS [AssemblyName], case when amudf.object_id is null then N'' else amudf.assembly_class end AS [ClassName], case when amudf.object_id is null then N'' else amudf.assembly_method end AS [MethodName], CAST(case when amudf.object_id is null then CAST(smudf.null_on_null_input AS bit) else amudf.null_on_null_input end AS bit) AS [ReturnsNullOnNullInput], case when amudf.object_id is null then case isnull(smudf.execute_as_principal_id, -1) when -1 then 1 when -2 then 2 else 3 end else case isnull(amudf.execute_as_principal_id, -1) when -1 then 1 when -2 then 2 else 3 end end AS [ExecutionContext], case when amudf.object_id is null then ISNULL(user_name(smudf.execute_as_principal_id),N'') else ISNULL(user_name(amudf.execute_as_principal_id), N'') end AS [ExecutionContextPrincipal], CAST(OBJECTPROPERTYEX(udf.object_id, N'IsDeterministic') AS bit) AS [IsDeterministic], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id,N'ExecIsQuotedIdentOn'),0) AS bit) AS [QuotedIdentifierStatus], ret_param.name AS [TableVariableName], ISNULL(sm.uses_native_compilation,0) AS [IsNativelyCompiled], CAST(ISNULL(sm.inline_type,0) AS bit) AS [InlineType], CAST(ISNULL(sm.is_inlineable,0) AS bit) AS [IsInlineable], ISNULL(smudf.definition, ssmudf.definition) AS [Definition] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.database_principals AS sudf ON sudf.principal_id = ISNULL(udf.principal_id, (OBJECTPROPERTY(udf.object_id, 'OwnerId'))) LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id LEFT OUTER JOIN sys.schemas AS s1ret_param ON s1ret_param.schema_id = usrt.schema_id LEFT OUTER JOIN sys.types AS baset ON (baset.user_type_id = ret_param.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = ret_param.system_type_id) and (baset.user_type_id = ret_param.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1))  LEFT OUTER JOIN sys.xml_schema_collections AS xscret_param ON xscret_param.xml_collection_id = ret_param.xml_collection_id LEFT OUTER JOIN sys.schemas AS s2ret_param ON s2ret_param.schema_id = xscret_param.schema_id LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.assembly_modules AS amudf ON amudf.object_id = udf.object_id LEFT OUTER JOIN sys.assemblies AS asmbludf ON asmbludf.assembly_id = amudf.assembly_id LEFT OUTER JOIN sys.all_sql_modules AS sm ON sm.object_id = udf.object_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT'))and(udf.name=@_msparam_1 and SCHEMA_NAME(udf.schema_id)=@_msparam_2)",23,23,0,116,0,23
"       SELECT COUNT_BIG(*) AS NumOfNodes FROM [sys].[dm_hadr_cluster_members] WHERE member_type = 0     ",22,20,2,0,0,1571
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",21,20,1,4185,38,126
SELECT target_data 									FROM sys.dm_xe_session_targets xet WITH(nolock) 									JOIN sys.dm_xe_sessions xes WITH(nolock) 									ON xes.address = xet.event_session_address 									WHERE xes.name = 'telemetry_xevents' 									AND xet.target_name = 'ring_buffer',20,16,4,0,0,414071
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000))SELECT 'XEStore[@Name=' + quotename(CAST(SERVERPROPERTY(N'ServerName') AS sysname),'''') + ']' + '/Session[@Name=' + quotename(session.name,'''') + ']' + '/Target[@Name=' + quotename(target.package + '.' + target.name,'''') + ']' + '/TargetField[@Name=' + quotename(col.name,'''') + ']' AS [Urn], ISNULL(field.object_id, -1) AS [ID], col.name AS [Name], field.value AS [Value], col.description AS [Description] FROM sys.server_event_sessions AS session LEFT OUTER JOIN sys.dm_xe_sessions AS running ON running.name = session.name, sys.server_event_session_targets AS target INNER JOIN sys.dm_xe_objects AS object2 ON target.name = object2.name AND object2.object_type='target' INNER JOIN sys.dm_xe_packages AS package2 ON target.module = package2.module_guid AND target.package = package2.name AND package2.guid = object2.package_guid INNER JOIN sys.dm_xe_object_columns AS col ON target.name = col.object_name AND col.column_type = 'customizable' LEFT OUTER JOIN sys.server_event_session_fields AS field ON target.event_session_id = field.event_session_id AND target.target_id = field.object_id AND col.name = field.name INNER JOIN sys.dm_xe_packages AS package ON target.package = package.name AND package.guid = col.object_package_guid WHERE (session.event_session_id = target.event_session_id)and(target.package + '.' + target.name=@_msparam_0)and((session.name=@_msparam_1)and((CAST(SERVERPROPERTY(N'ServerName') AS sysname)=@_msparam_2)))",20,20,0,130,0,20
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(udf.schema_id) AS [Schema], udf.name AS [Name], udf.object_id AS [ID], (case when 'FN' = udf.type then 1 when 'FS' = udf.type then 1 when 'IF' = udf.type then 3 when 'TF' = udf.type then 2 when 'FT' = udf.type then 2 else 0 end) AS [FunctionType], CASE WHEN udf.type IN ('FN','IF','TF') THEN 1 WHEN udf.type IN ('FS','FT') THEN 2 ELSE 1 END AS [ImplementationType], CAST(  case      when udf.is_ms_shipped = 1 then 1     when (         select              major_id          from              sys.extended_properties          where              major_id = udf.object_id and              minor_id = 0 and              class = 1 and              name = N'microsoft_database_tools_support')          is not null then 1     else 0 end                        AS bit) AS [IsSystemObject], CAST(CASE WHEN ISNULL(smudf.definition, ssmudf.definition) IS NULL THEN 1 ELSE 0 END AS bit) AS [IsEncrypted], CAST(ISNULL(OBJECTPROPERTYEX(udf.object_id, N'IsSchemaBound'),0) AS bit) AS [IsSchemaBound], usrt.name AS [DataType] FROM sys.all_objects AS udf LEFT OUTER JOIN sys.sql_modules AS smudf ON smudf.object_id = udf.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmudf ON ssmudf.object_id = udf.object_id LEFT OUTER JOIN sys.all_parameters AS ret_param ON ret_param.object_id = udf.object_id and ret_param.is_output = @_msparam_0 LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = ret_param.user_type_id WHERE (udf.type in ('TF', 'FN', 'IF', 'FS', 'FT')) ORDER BY [Schema] ASC,[Name] ASC",19,19,0,4179,37,59
"()                 begin try                 if (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1                 begin                 declare @curr_tracefilename varchar(500) ;                 declare @base_tracefilename varchar(500) ;                 declare @indx int ;                 declare @path_separator CHAR(1) ;                 set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;                  select @curr_tracefilename = path from sys.traces where is_default = 1 ;                 set @curr_tracefilename = reverse(@curr_tracefilename);                 select @indx  = patindex('%'+@path_separator+'%', @curr_tracefilename) ;                 set @curr_tracefilename = reverse(@curr_tracefilename) ;                 set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  select  (dense_rank() over (order by StartTime desc))%2 as l1                 ,       convert(int, EventClass) as EventClass                 ,       DatabaseName                 ,       Filename                 ,       (Duration/1000) as Duration                 ,       StartTime                 ,       EndTime                 ,       (IntegerData*8.0/1024) as ChangeInSize                 from ::fn_trace_gettable( @base_tracefilename, default )                 left outer join sys.databases as d on (d.name = DB_NAME())                 where EventClass >=  92      and EventClass <=  95        and ServerName = @@servername   and DatabaseName = db_name()  and (d.create_date < EndTime)                 order by StartTime desc ;                 end     else                 select -1 as l1, 0 as EventClass, 0 DatabaseName, 0 as Filename, 0 as Duration, 0 as StartTime, 0 as EndTime,0 as ChangeInSize                 end try                 begin catch                 select -100 as l1                 ,       ERROR_NUMBER() as EventClass                 ,       ERROR_SEVERITY() DatabaseName                 ,       ERROR_STATE() as Filename                 ,       ERROR_MESSAGE() as Duration                 ,       1 as StartTime, 1 as EndTime,1 as ChangeInSize                 end catch               ",19,18,1,4,0,19
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",18,15,3,233,0,37
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags        SELECT AR.replica_server_name AS [Name], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], ISNULL(arstates.operational_state, 6) AS [OperationalState], suser_sname(AR.owner_sid) AS [Owner], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], AR.replica_id AS [UniqueId], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_availability_replica_cluster_states              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_replica_rollupstate              drop table #tmpag_availability_groups       ",18,14,4,233,0,18
"       select COUNT_BIG(*) AS [NumReplicaPerAG]       from sys.dm_hadr_availability_replica_states where group_id in       (select group_id from sys.dm_hadr_availability_replica_states WITH(nolock) where is_local = 1 and role = 1) group by group_id     ",18,14,4,76,0,1283
"()begin try select top 10 rank() over(order by (total_worker_time+0.0)/execution_count desc,sql_handle,statement_start_offset ) as row_no ,       (rank() over(order by (total_worker_time+0.0)/execution_count desc,sql_handle,statement_start_offset ))%2 as l1 ,       creation_time ,       last_execution_time  ,       (total_worker_time+0.0)/1000 as total_worker_time ,       (total_worker_time+0.0)/(execution_count*1000) as [AvgCPUTime] ,       total_logical_reads as [LogicalReads] ,       total_logical_writes as [LogicalWrites] ,       execution_count ,       total_logical_reads+total_logical_writes as [AggIO] ,       (total_logical_reads+total_logical_writes)/(execution_count+0.0) as [AvgIO] ,       case when sql_handle IS NULL                 then ' '                 else ( substring(st.text,(qs.statement_start_offset+2)/2,       (case when qs.statement_end_offset = -1         then len(convert(nvarchar(MAX),st.text))*2      else qs.statement_end_offset    end - qs.statement_start_offset) /2  ) )         end as query_text  ,       db_name(st.dbid) as db_name ,       st.objectid as object_id from sys.dm_exec_query_stats  qs cross apply sys.dm_exec_sql_text(sql_handle) st where total_worker_time  > 0  order by [AvgCPUTime] desc end try begin catch select -100 as row_no ,       1 as l1, 1 as create_time,1 as last_execution_time,1 as total_worker_time,1 as AvgCPUTime,1 as LogicalReads,1 as LogicalWrites ,       ERROR_NUMBER() as execution_count ,       ERROR_SEVERITY() as AggIO ,       ERROR_STATE() as AvgIO ,       ERROR_MESSAGE() as query_text ,       0 as db_name ,       0 as object_name end catch",18,17,1,17012,663,36
"()begin try  use msdb;  declare @enable int; select @enable = convert(int, value_in_use) from sys.configurations where name = 'default trace enabled'  if @enable = 1   begin          declare @curr_tracefilename varchar(500);         declare @base_tracefilename varchar(500);         declare @status int;          declare @indx int;            declare @temp_trace table (                  Error int         ,       StartTime datetime         ,       HostName sysname collate database_default null         ,       ApplicationName sysname collate database_default  null         ,       LoginName sysname collate database_default null         ,       Severity int         ,       DatabaseName sysname collate database_default null         ,       TextData nvarchar(max) collate database_default          );          declare @path_separator CHAR(1) ;         set @path_separator = ISNULL(CONVERT(CHAR(1), serverproperty('PathSeparator')), '\') ;          select @status=status, @curr_tracefilename=path from sys.traces where is_default = 1 ;         set @curr_tracefilename = reverse(@curr_tracefilename)          select @indx  = patindex('%'+@path_separator+'%', @curr_tracefilename)           set @curr_tracefilename = reverse(@curr_tracefilename)          set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + @path_separator + 'log.trc';                  insert into @temp_trace          select Error         ,       StartTime         ,       HostName         ,       ApplicationName         ,       LoginName         ,       Severity         ,       DatabaseName         ,       TextData           from ::fn_trace_gettable( @base_tracefilename, default )          where substring(TextData, 20, 15) like '%Backup%' and TextData like '%Error%' and ServerName = @@servername ;                    select (row_number() over(order by StartTime desc))%2 as l1         ,       right( right( TextData, len(TextData) - patindex('%BACKUP%',TextData) ) , len(right( TextData, len(TextData) - patindex('%BACKUP%',TextData) )) - patindex('%BACKUP%',right( TextData, len(TextData) - patindex('%BACKUP%',TextData) )) - 10 ) as ErrorMessage         ,       Error         ,       Severity         ,       StartTime         ,       HostName         ,       ApplicationName         ,       LoginName         ,       DatabaseName           from @temp_trace            where DatabaseName = '""  & Parameters!DatabaseName.Value &  ""'           order by StartTime desc  end else  begin          select top 0 1 as ErrorMessage, 1 as Error, 1 as Severity, 1 as StartTime,1 as HostName, 1 as ApplicationName,1 as LoginName, 1 as DatabaseName, 1 as l1  end  end try  begin catch  select ERROR_MESSAGE() as ErrorMessage ,       ERROR_NUMBER() as Error ,       ERROR_SEVERITY() as Severity ,       ERROR_STATE() as StartTime ,       1 as HostName, 1 as ApplicationName,1 as LoginName, 1 as DatabaseName ,       -100 as l1  end catch",18,15,3,0,0,36
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",17,14,3,231,0,51
"         DECLARE @msticks bigint, @mstickstime datetime, @LastHour datetime                 SELECT @mstickstime = GETDATE(), @msticks = ms_ticks from sys.dm_os_sys_info                 SELECT @LastHour = DATEADD(HOUR, -1, @mstickstime);                  WITH Quartiles AS (                 SELECT DISTINCT                     CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) EventDate,                        CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114) AS [EventTime],                        PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS MedianSQLCPU                            ,                        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS Q3SQLCPU                      ,                        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')                            )                            OVER (PARTITION BY CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112),                                   CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)                            ) AS Q1SQLCPU                   FROM (                     SELECT timestamp, CONVERT (xml, record) AS 'record'                     FROM sys.dm_os_ring_buffers                     WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'                       AND record LIKE '%<SystemHealth>%'                             ) AS t                      WHERE DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)) = DATEPART(HOUR, @LastHour)                      AND CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE) = CAST(@LastHour AS DATE)               ),               SimpleStats AS (                 SELECT                     CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) EventDate,                        CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114) AS [EventTime],                     MAX(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [MaxSQLCPU],                        MIN(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [MinSQLCPU],                        AVG(record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int')) AS [AvgSQLCPU]                   FROM (                     SELECT timestamp, CONVERT (xml, record) AS 'record'                     FROM sys.dm_os_ring_buffers                     WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'                       AND record LIKE '%<SystemHealth>%'                             ) AS t               WHERE DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)) = DATEPART(HOUR, @LastHour)                      AND CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE) = CAST(@LastHour AS DATE)               GROUP BY                      CONVERT(VARCHAR(10), CAST(DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime) AS DATE), 112) ,                      CONVERT(VARCHAR(30), TIMEFROMPARTS(DATEPART(HOUR, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime)), 00,00,00,00), 114)               )               SELECT                      ss.EventDate AS EventDate,                      ss.EventTime AS EventTime,                      ss.MaxSQLCPU,                      ss.MinSQLCPU,                      ss.AvgSQLCPU,                      q.MedianSQLCPU,                      q.Q1SQLCPU,                      q.Q3SQLCPU               FROM SimpleStats ss                      INNER JOIN Quartiles q                            ON q.EventDate = ss.EventDate                            AND q.EventTime = ss.EventTime      ",16,16,0,781,0,28089
"       SELECT database_id, database_guid,       CASE       WHEN db_name(database_id) LIKE '%WideWorldImportersDW%' THEN 'WideWorldImportersDW'       WHEN db_name(database_id) LIKE '%WideWorldImporters%' THEN 'WideWorldImporters'       WHEN db_name(database_id) LIKE '%AdventureWorks2016CTP3%' THEN 'AdventureWorks2016CTP3'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2016CTP3%' THEN 'AdventureWorksDW2016CTP3'       WHEN db_name(database_id) LIKE '%AdventureWorks2014%' THEN 'AdventureWorks2014'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2014%' THEN 'AdventureWorksDW2014'       WHEN db_name(database_id) LIKE '%AdventureWorks2012%' THEN 'AdventureWorks2012'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2012%' THEN 'AdventureWorksDW2012'       WHEN db_name(database_id) LIKE '%AdventureWorks2008%' THEN 'AdventureWorks2008'       WHEN db_name(database_id) LIKE '%AdventureWorksDW2008%' THEN 'AdventureWorksDW2008'       WHEN db_name(database_id) LIKE '%AdventureWorksDW%' THEN 'AdventureWorksDW'       WHEN db_name(database_id) LIKE '%AdventureWorks%' THEN 'AdventureWorks'       WHEN db_name(database_id) LIKE '%ReportServerTempDB%' THEN 'ReportServerTempDB'       WHEN db_name(database_id) LIKE '%ReportServer%' THEN 'ReportServer'       WHEN db_name(database_id) LIKE '%WSS_Content%' THEN 'WSS_Content'       WHEN db_name(database_id) LIKE '%MDW%' THEN 'MDW'       WHEN db_name(database_id) LIKE '%MicrosoftDynamicsAX_baseline%' THEN 'MicrosoftDynamicsAX_baseline'       WHEN db_name(database_id) LIKE '%MicrosoftDynamicsAX%' THEN 'MicrosoftDynamicsAX'       WHEN db_name(database_id) = 'master' THEN 'master'       WHEN db_name(database_id) = 'msdb' THEN 'msdb'       WHEN db_name(database_id) = 'tempdb' THEN 'tempdb'       WHEN db_name(database_id) = 'model' THEN 'model'       WHEN db_name(database_id) LIKE '%SharePoint_Config%' THEN 'SharePoint_Config'       WHEN db_name(database_id) LIKE '%SharePoint_AdminContent%' THEN 'SharePoint_AdminContent'       WHEN db_name(database_id) LIKE '%AppManagement%' THEN 'AppManagement'       WHEN db_name(database_id) LIKE '%Bdc_Service_DB%' THEN 'Bdc_Service_DB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_DB%' THEN 'Search_Service_Application_DB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_AnalyticsReportingStoreDB%' THEN 'Search_Service_Application_AnalyticsReportingStoreDB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_CrawlStoreDB%' THEN 'Search_Service_Application_CrawlStoreDB'       WHEN db_name(database_id) LIKE '%Search_Service_Application_LinkStoreDB%' THEN 'Search_Service_Application_LinkStoreDB'       WHEN db_name(database_id) LIKE '%Secure_Store_Service_DB%' THEN 'Secure_Store_Service_DB'       WHEN db_name(database_id) LIKE '%SharePoint_Logging%' THEN 'SharePoint_Logging'       WHEN db_name(database_id) LIKE '%SettingsServiceDB%' THEN 'SettingsServiceDB'       WHEN db_name(database_id) LIKE '%User Profile Service Application_ProfileDB%' THEN 'User Profile Service Application_ProfileDB'       WHEN db_name(database_id) LIKE '%User Profile Service Application_SyncDB%' THEN 'User Profile Service Application_SyncDB'       WHEN db_name(database_id) LIKE '%User Profile Service Application_SocialDB%' THEN 'User Profile Service Application_SocialDB'       WHEN db_name(database_id) LIKE '%WordAutomationServices%' THEN 'WordAutomationServices'       WHEN db_name(database_id) LIKE '%Managed Metadata Service Application_Metadata%' THEN 'Managed Metadata Service Application_Metadata'       WHEN db_name(database_id) LIKE '%SharePoint Translation Services%' THEN 'SharePoint Translation Services'       WHEN db_name(database_id) LIKE '%ProjectWebApp%' THEN 'ProjectWebApp'       WHEN db_name(database_id) LIKE '%DefaultPowerPivotServiceApplicationDB%' THEN 'DefaultPowerPivotServiceApplicationDB'       WHEN db_name(database_id) LIKE '%PerformancePoint Service%' THEN 'PerformancePoint Service'       WHEN db_name(database_id) LIKE '%SessionStateService%' THEN 'SessionStateService'       WHEN db_name(database_id) = 'SSISDB' THEN 'SSISDB'       WHEN db_name(database_id) = 'DQS_MAIN' THEN 'DQS_MAIN'       ELSE 'Other'       END AS default_database_class       FROM sys.database_recovery_status WITH(nolock)     ",16,8,8,17,0,1169
"       select counter_name, cntr_value from sys.dm_os_performance_counters where object_name like '%External Scripts%'     ",16,16,0,0,0,1166
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))SELECT u.name AS [Name], CAST(CASE dp.state WHEN N'G' THEN 1 WHEN 'W' THEN 1 ELSE 0 END AS bit) AS [HasDBAccess], ISNULL(u.default_schema_name,N'') AS [DefaultSchema] FROM sys.database_principals AS u LEFT OUTER JOIN sys.database_permissions AS dp ON dp.grantee_principal_id = u.principal_id and dp.type = @_msparam_0 WHERE (u.type in ('U', 'S', 'G', 'C', 'K' ,'E', 'X'))and(ISNULL(suser_sname(u.sid),N'')=@_msparam_1)",16,16,0,15,0,133
"       select counter_name, cntr_value from sys.dm_os_performance_counters where object_name like '%JSON Doc Stats%'     ",16,16,0,0,0,1159
"SELECT (SELECT ISNULL(msdb.smart_admin.fn_is_master_switch_on (), 0)) AS [MasterSwitch], CAST(ISNULL(ic.is_managed_backup_enabled, 0) AS bit) AS [BackupEnabled], ISNULL(ic.credential_name, N'') AS [CredentialName], ISNULL(ic.retention_days, 0) AS [BackupRetentionPeriodInDays], ISNULL(ic.storage_url, N'') AS [StorageUrl], ISNULL(ic.encryption_algorithm, N'') AS [EncryptionAlgorithm], ISNULL(ic.encryptor_type, N'') AS [EncryptorType], ISNULL(ic.encryptor_name, N'') AS [EncryptorName] FROM msdb.smart_admin.fn_backup_instance_config () AS ic",15,14,1,70,0,30
"()                 begin try                 select  object_name                 ,       counter_name                 ,       convert(varchar(10),cntr_value) as cntr_value                 from sys.dm_os_performance_counters                 where ( (object_name like '%Manager%') and (counter_name = 'Memory Grants Pending' or counter_name='Memory Grants Outstanding' ))                 end try                 begin catch                 select top 0 0 as object_name, 0 as counter_name, 0 as cntr_value                 end catch               ",15,15,0,0,0,30
"       SELECT replica_id, group_id, is_local, role, operational_state, recovery_health, synchronization_health, connected_state, last_connect_error_number, last_connect_error_timestamp FROM sys.dm_hadr_availability_replica_states WITH(nolock)     ",15,13,2,66,0,1068
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states          SELECT AG.name AS [Name], AG.group_id AS [UniqueId], ISNULL(AG.automated_backup_preference, 4) AS [AutomatedBackupPreference], ISNULL(AG.failure_condition_level, 6) AS [FailureConditionLevel], ISNULL(AG.health_check_timeout, -1) AS [HealthCheckTimeout], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], AR2.replica_metadata_id AS [ID], CAST(ISNULL(AG.basic_features, 0) AS bit) AS [BasicAvailabilityGroup], CAST(ISNULL(AG.db_failover, 0) AS bit) AS [DatabaseHealthTrigger], CAST(ISNULL(AG.dtc_support, 0) AS bit) AS [DtcSupportEnabled], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], ISNULL(AG.required_synchronized_secondaries_to_commit, 0) AS [RequiredSynchronizedSecondariesToCommit], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states      ",15,12,3,100,0,30
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",14,12,2,176,0,29
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",14,14,0,0,0,29
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",14,14,0,0,0,14
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags        SELECT AR.replica_server_name AS [Name], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], ISNULL(arstates.operational_state, 6) AS [OperationalState], suser_sname(AR.owner_sid) AS [Owner], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], AR.replica_id AS [UniqueId], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_availability_replica_cluster_states              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_replica_rollupstate              drop table #tmpag_availability_groups       ",14,12,2,168,0,14
"       select       group_id,       replica_id,       availability_mode,       failover_mode,       primary_role_allow_connections,       secondary_role_allow_connections,       LEN(ISNULL(read_only_routing_url, '')) as read_only_routing_url_length,       seeding_mode,       session_timeout       from sys.availability_replicas WITH(nolock) where group_id in       (select group_id from sys.dm_hadr_availability_replica_states WITH(nolock) where is_local = 1 and role = 1)     ",14,11,3,98,0,86
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups               select replica_id, group_id into #tmpardb_availability_replicas from master.sys.availability_replicas              select replica_id, group_database_id, database_name,is_database_joined,is_failover_ready,is_pending_secondary_suspend,recovery_lsn,truncation_lsn into #tmpardb_database_replica_cluster_states from master.sys.dm_hadr_database_replica_cluster_states              select replica_id, is_local into #tmpardb_availability_replica_states from master.sys.dm_hadr_availability_replica_states        SELECT dbcs.database_name AS [Name] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpardb_availability_replicas AS AR ON AR.group_id=AG.group_id INNER JOIN #tmpardb_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1 INNER JOIN #tmpardb_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpardb_availability_replicas              DROP TABLE #tmpardb_database_replica_cluster_states              DROP TABLE #tmpardb_availability_replica_states              drop table #tmpag_availability_groups       ",14,11,3,93,0,28
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",13,11,2,172,0,41
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states                select TMIL.group_id, count(*) as is_managed_instance_link into #tmp_managed_instance_link from sys.availability_replicas AS TMIL where TMIL.endpoint_url LIKE '%Server=%' and (select count(*) from sys.availability_replicas as A1 where A1.group_id = TMIL.group_id) = 2 group by TMIL.group_id having count(*) = 1        SELECT AG.name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' AS [Urn], case when 1=(SELECT CONVERT(bit, current_value)         FROM msdb.dbo.syspolicy_configuration         WHERE name = 'Enabled') and exists (select * from msdb.dbo.syspolicy_system_health_state where target_query_expression_with_id like 'Server'+ '/AvailabilityGroup\[@ID=' + convert(nvarchar(20),AR2.replica_metadata_id) + '\]%' ESCAPE '\') then 1 else 0 end AS [PolicyHealthState], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], CAST(ISNULL(MIL.is_managed_instance_link, 0) & ISNULL(AG.is_distributed, 0) AS bit) AS [IsManagedInstanceLink], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 LEFT OUTER JOIN #tmp_managed_instance_link AS MIL ON AG.group_id = MIL.group_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmp_managed_instance_link      ",13,10,3,106,5,13
"(@_msparam_0 nvarchar(4000))       select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select * into #tmpag_availability_groups from master.sys.availability_groups              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states          SELECT grantee_principal.name AS [Grantee], CASE grantee_principal.type WHEN 'R' THEN 3 WHEN 'A' THEN 4 ELSE 2 END - CASE 'server' WHEN  'database' THEN 0 ELSE 2 END AS [GranteeType] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 INNER JOIN sys.server_permissions AS prmssn ON prmssn.major_id=AR2.replica_metadata_id AND prmssn.class=108 INNER JOIN sys.server_principals AS grantee_principal ON grantee_principal.principal_id = prmssn.grantee_principal_id WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmpag_availability_groups       ",13,11,2,98,0,13
"SELECT DISTINCT s.*,ep.value as description FROM MAPMAKER.sys.schemas s LEFT OUTER JOIN MAPMAKER.sys.extended_properties ep ON ep.class=3 AND ep.major_id=s.schema_id AND ep.minor_id=0 AND ep.name='MS_Description' INNER JOIN MAPMAKER.sys.all_objects o ON s.schema_id=o.schema_id",13,12,1,92,0,13
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states                select TMIL.group_id, count(*) as is_managed_instance_link into #tmp_managed_instance_link from sys.availability_replicas AS TMIL where TMIL.endpoint_url LIKE '%Server=%' and (select count(*) from sys.availability_replicas as A1 where A1.group_id = TMIL.group_id) = 2 group by TMIL.group_id having count(*) = 1        SELECT AG.name AS [Name], ISNULL(AG.automated_backup_preference, 4) AS [AutomatedBackupPreference], ISNULL(AG.failure_condition_level, 6) AS [FailureConditionLevel], ISNULL(AG.health_check_timeout, -1) AS [HealthCheckTimeout], AR2.replica_metadata_id AS [ID], CAST(ISNULL(MIL.is_managed_instance_link, 0) & ISNULL(AG.is_distributed, 0) AS bit) AS [IsManagedInstanceLink], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], AG.group_id AS [UniqueId], CAST(ISNULL(AG.basic_features, 0) AS bit) AS [BasicAvailabilityGroup], CAST(ISNULL(AG.db_failover, 0) AS bit) AS [DatabaseHealthTrigger], CAST(ISNULL(AG.dtc_support, 0) AS bit) AS [DtcSupportEnabled], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], ISNULL(AG.required_synchronized_secondaries_to_commit, 0) AS [RequiredSynchronizedSecondariesToCommit], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 LEFT OUTER JOIN #tmp_managed_instance_link AS MIL ON AG.group_id = MIL.group_id WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmp_managed_instance_link      ",13,10,3,101,0,13
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups               select replica_id, group_id into #tmpardb_availability_replicas from master.sys.availability_replicas              select replica_id, group_database_id, database_name,is_database_joined,is_failover_ready,is_pending_secondary_suspend,recovery_lsn,truncation_lsn into #tmpardb_database_replica_cluster_states from master.sys.dm_hadr_database_replica_cluster_states              select replica_id, is_local into #tmpardb_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id, group_database_id,synchronization_state, is_suspended into #tmpardb_database_replica_states from master.sys.dm_hadr_database_replica_states        SELECT dbcs.database_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityDatabase[@Name=' + quotename(dbcs.database_name,'''') + ']' AS [Urn], ISNULL(dbrs.synchronization_state, 0) AS [SynchronizationState], ISNULL(dbrs.is_suspended, 0) AS [IsSuspended], ISNULL(dbcs.is_database_joined, 0) AS [IsJoined] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpardb_availability_replicas AS AR ON AR.group_id=AG.group_id INNER JOIN #tmpardb_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1 INNER JOIN #tmpardb_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id LEFT OUTER JOIN #tmpardb_database_replica_states AS dbrs ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpardb_availability_replicas              DROP TABLE #tmpardb_database_replica_cluster_states              DROP TABLE #tmpardb_availability_replica_states              DROP TABLE #tmpardb_database_replica_states              drop table #tmpag_availability_groups       ",12,10,2,96,0,25
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",12,12,0,0,0,12
"       select       group_id,       automated_backup_preference AS [BackupPreference],       failure_condition_level,       health_check_timeout,       dtc_support,       db_failover,       is_distributed,       required_synchronized_secondaries_to_commit,       cluster_type,       sequence_number, 	  is_contained       from sys.availability_groups where group_id in       (select group_id from sys.dm_hadr_availability_replica_states WITH(nolock) where is_local = 1 and role = 1)     ",12,9,3,78,0,871
"declare      @CPU_Usage_Percentage int,      @Total_SQL_Server_Memory_MB int   -- CPU WITH y AS (     SELECT               CONVERT(VARCHAR(5), 100 - ca.c.value('.', 'INT')) AS system_idle,         CONVERT(VARCHAR(30), rb.event_date) AS event_date,         CONVERT(VARCHAR(8000), rb.record) AS record     FROM (            SELECT              CONVERT(XML, dorb.record) AS record,             DATEADD(ms, ( ts.ms_ticks - dorb.timestamp ), GETDATE()) AS event_date         FROM   sys.dm_os_ring_buffers AS dorb             CROSS JOIN (                  SELECT                      dosi.ms_ticks                  FROM sys.dm_os_sys_info AS dosi ) AS ts                 WHERE   dorb.ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'                         AND record LIKE '%%' ) AS rb             CROSS APPLY rb.record.nodes('/Record/SchedulerMonitorEvent/SystemHealth/SystemIdle') AS ca(c)         )     SELECT @CPU_Usage_Percentage = (select          TOP 1 y.system_idle     FROM y      ORDER BY y.event_date DESC)   -- memory select @Total_SQL_Server_Memory_MB = (select      cntr_value / 1024 from sys.dm_os_performance_counters pc where   [object_name] = 'SQLServer:Memory Manager'         and counter_name = 'Total Server Memory (KB)'                                                                                                         )   select      @CPU_Usage_Percentage           [CPU_Usage_Percentage],      @Total_SQL_Server_Memory_MB     [Total_SQL_Server_Memory_MB]; 	 WITH DB_CPU_Stats AS (SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)  CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID]               FROM sys.dm_exec_plan_attributes(qs.plan_handle)               WHERE attribute = N'dbid') AS pa  GROUP BY DatabaseID) SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],        [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)],        CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent] FROM DB_CPU_Stats WHERE DatabaseID <> 32767 -- ResourceDB ORDER BY [CPU Rank] OPTION (RECOMPILE);   DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",12,12,0,0,0,24
" DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",12,12,0,0,0,24
"         declare @HkeyLocal nvarchar(18)         declare @ServicesRegPath nvarchar(34)         declare @SqlServiceRegPath sysname         declare @BrowserServiceRegPath sysname         declare @MSSqlServerRegPath nvarchar(31)         declare @InstanceNamesRegPath nvarchar(59)         declare @InstanceRegPath sysname         declare @SetupRegPath sysname         declare @NpRegPath sysname         declare @TcpRegPath sysname         declare @RegPathParams sysname         declare @FilestreamRegPath sysname          select @HkeyLocal=N'HKEY_LOCAL_MACHINE'          -- Instance-based paths         select @MSSqlServerRegPath=N'SOFTWARE\Microsoft\MSSQLServer'         select @InstanceRegPath=@MSSqlServerRegPath + N'\MSSQLServer'         select @FilestreamRegPath=@InstanceRegPath + N'\Filestream'         select @SetupRegPath=@MSSqlServerRegPath + N'\Setup'         select @RegPathParams=@InstanceRegPath+'\Parameters'          -- Services         select @ServicesRegPath=N'SYSTEM\CurrentControlSet\Services'         select @SqlServiceRegPath=@ServicesRegPath + N'\MSSQLSERVER'         select @BrowserServiceRegPath=@ServicesRegPath + N'\SQLBrowser'          -- InstanceId setting         select @InstanceNamesRegPath=N'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'          -- Network settings         select @NpRegPath=@InstanceRegPath + N'\SuperSocketNetLib\Np'         select @TcpRegPath=@InstanceRegPath + N'\SuperSocketNetLib\Tcp'                  declare @SmoAuditLevel int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'AuditLevel', @SmoAuditLevel OUTPUT                  declare @NumErrorLogs int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'NumErrorLogs', @NumErrorLogs OUTPUT                  declare @SmoLoginMode int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'LoginMode', @SmoLoginMode OUTPUT                  declare @SmoMailProfile nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'MailAccountName', @SmoMailProfile OUTPUT                  declare @BackupDirectory nvarchar(512)         if 1=isnull(cast(SERVERPROPERTY('IsLocalDB') as bit), 0)         select @BackupDirectory=cast(SERVERPROPERTY('instancedefaultdatapath') as nvarchar(512))         else         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'BackupDirectory', @BackupDirectory OUTPUT                  declare @SmoPerfMonMode int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'Performance', @SmoPerfMonMode OUTPUT          if @SmoPerfMonMode is null         begin         set @SmoPerfMonMode = 1000         end                  declare @InstallSqlDataDir nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLDataRoot', @InstallSqlDataDir OUTPUT                  declare @MasterPath nvarchar(512)         declare @LogPath nvarchar(512)         declare @ErrorLog nvarchar(512)         declare @ErrorLogPath nvarchar(512)         declare @Slash varchar = convert(varchar, serverproperty('PathSeparator'))         select @MasterPath=substring(physical_name, 1, len(physical_name) - charindex(@Slash, reverse(physical_name))) from master.sys.database_files where file_id = 1         select @LogPath=substring(physical_name, 1, len(physical_name) - charindex(@Slash, reverse(physical_name))) from master.sys.database_files where file_id = 2         select @ErrorLog=cast(SERVERPROPERTY(N'errorlogfilename') as nvarchar(512))         select @ErrorLogPath=IIF(@ErrorLog IS NULL, N'', substring(@ErrorLog, 1, len(@ErrorLog) - charindex(@Slash, reverse(@ErrorLog))))                  declare @SmoRoot nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLPath', @SmoRoot OUTPUT                  declare @ServiceStartMode int         EXEC master.sys.xp_instance_regread @HkeyLocal, @SqlServiceRegPath, N'Start', @ServiceStartMode OUTPUT                  declare @ServiceAccount nvarchar(512)         EXEC master.sys.xp_instance_regread @HkeyLocal, @SqlServiceRegPath, N'ObjectName', @ServiceAccount OUTPUT                  declare @NamedPipesEnabled int         exec master.dbo.xp_instance_regread @HkeyLocal, @NpRegPath, N'Enabled', @NamedPipesEnabled OUTPUT                  declare @TcpEnabled int         EXEC master.sys.xp_instance_regread @HkeyLocal, @TcpRegPath, N'Enabled', @TcpEnabled OUTPUT                  declare @InstallSharedDirectory nvarchar(512)         EXEC master.sys.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLPath', @InstallSharedDirectory OUTPUT                  declare @SqlGroup nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLGroup', @SqlGroup OUTPUT                  declare @FilestreamLevel int         exec master.dbo.xp_instance_regread @HkeyLocal, @FilestreamRegPath, N'EnableLevel', @FilestreamLevel OUTPUT                  declare @FilestreamShareName nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @FilestreamRegPath, N'ShareName', @FilestreamShareName OUTPUT                  declare @cluster_name nvarchar(128)         declare @quorum_type tinyint         declare @quorum_state tinyint         BEGIN TRY         SELECT @cluster_name = cluster_name,         @quorum_type = quorum_type,         @quorum_state = quorum_state         FROM sys.dm_hadr_cluster         END TRY         BEGIN CATCH           IF(ERROR_NUMBER() NOT IN (297,300, 15562, 371))         BEGIN         THROW         END         END CATCH         SELECT @SmoAuditLevel AS [AuditLevel], ISNULL(@NumErrorLogs, -1) AS [NumberOfLogFiles], (case when @SmoLoginMode < 3 then @SmoLoginMode else 9 end) AS [LoginMode], ISNULL(@SmoMailProfile,N'') AS [MailProfile], @BackupDirectory AS [BackupDirectory], @SmoPerfMonMode AS [PerfMonMode], ISNULL(@InstallSqlDataDir,N'') AS [InstallDataDirectory], CAST(@@SERVICENAME AS sysname) AS [ServiceName], @ErrorLogPath AS [ErrorLogPath], @SmoRoot AS [RootDirectory], CAST(case when 'a' <> 'A' then 1 else 0 end AS bit) AS [IsCaseSensitive], @@MAX_PRECISION AS [MaxPrecision], CAST(FULLTEXTSERVICEPROPERTY('IsFullTextInstalled') AS bit) AS [IsFullTextInstalled], SERVERPROPERTY(N'ProductVersion') AS [VersionString], CAST(SERVERPROPERTY(N'Edition') AS sysname) AS [Edition], CAST(SERVERPROPERTY(N'ProductLevel') AS sysname) AS [ProductLevel], CAST(ISNULL(SERVERPROPERTY(N'ProductUpdateLevel'), N'') AS sysname) AS [ProductUpdateLevel], CAST(SERVERPROPERTY('IsSingleUser') AS bit) AS [IsSingleUser], CAST(SERVERPROPERTY('EngineEdition') AS int) AS [EngineEdition], convert(sysname, serverproperty(N'collation')) AS [Collation], CAST(ISNULL(SERVERPROPERTY('IsClustered'), 0) AS bit) AS [IsClustered], CAST(ISNULL(SERVERPROPERTY(N'MachineName'), N'') AS sysname) AS [NetName], ISNULL(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS'),N'') AS [ComputerNamePhysicalNetBIOS], ISNULL(@ServiceStartMode,2) AS [ServiceStartMode], @LogPath AS [MasterDBLogPath], @MasterPath AS [MasterDBPath], SERVERPROPERTY('instancedefaultdatapath') AS [DefaultFile], SERVERPROPERTY('instancedefaultlogpath') AS [DefaultLog], SERVERPROPERTY(N'ResourceVersion') AS [ResourceVersionString], SERVERPROPERTY(N'ResourceLastUpdateDateTime') AS [ResourceLastUpdateDateTime], SERVERPROPERTY(N'CollationID') AS [CollationID], SERVERPROPERTY(N'ComparisonStyle') AS [ComparisonStyle], SERVERPROPERTY(N'SqlCharSet') AS [SqlCharSet], SERVERPROPERTY(N'SqlCharSetName') AS [SqlCharSetName], SERVERPROPERTY(N'SqlSortOrder') AS [SqlSortOrder], SERVERPROPERTY(N'SqlSortOrderName') AS [SqlSortOrderName], SERVERPROPERTY(N'BuildClrVersion') AS [BuildClrVersionString], ISNULL(@ServiceAccount,N'') AS [ServiceAccount], CAST(@NamedPipesEnabled AS bit) AS [NamedPipesEnabled], CAST(@TcpEnabled AS bit) AS [TcpEnabled], ISNULL(@InstallSharedDirectory,N'') AS [InstallSharedDirectory], ISNULL(suser_sname(sid_binary(ISNULL(@SqlGroup,N''))),N'') AS [SqlDomainGroup], case when 1=msdb.dbo.fn_syspolicy_is_automation_enabled() and exists (select * from msdb.dbo.syspolicy_system_health_state  where target_query_expression_with_id like 'Server%' ) then 1 else 0 end AS [PolicyHealthState], @FilestreamLevel AS [FilestreamLevel], ISNULL(@FilestreamShareName,N'') AS [FilestreamShareName], -1 AS [TapeLoadWaitTime], CAST(SERVERPROPERTY(N'IsHadrEnabled') AS bit) AS [IsHadrEnabled], SERVERPROPERTY(N'HADRManagerStatus') AS [HadrManagerStatus], ISNULL(@cluster_name, '') AS [ClusterName], ISNULL(@quorum_type, 4) AS [ClusterQuorumType], ISNULL(@quorum_state, 3) AS [ClusterQuorumState], SUSER_SID(@ServiceAccount, 0) AS [ServiceAccountSid], CAST(SERVERPROPERTY('IsPolyBaseInstalled') AS bit) AS [IsPolyBaseInstalled], CAST(         serverproperty(N'Servername')        AS sysname) AS [Name], CAST(         ISNULL(serverproperty(N'instancename'),N'')        AS sysname) AS [InstanceName], CAST(0x0001 AS int) AS [Status], SERVERPROPERTY('PathSeparator') AS [PathSeparator], 0 AS [IsContainedAuthentication], CAST(null AS int) AS [ServerType]",11,11,0,0,0,23
"       SELECT quorum_type_desc FROM [sys].[dm_hadr_cluster]     ",11,11,0,0,0,830
"         declare @HkeyLocal nvarchar(18)         declare @ServicesRegPath nvarchar(34)         declare @SqlServiceRegPath sysname         declare @BrowserServiceRegPath sysname         declare @MSSqlServerRegPath nvarchar(31)         declare @InstanceNamesRegPath nvarchar(59)         declare @InstanceRegPath sysname         declare @SetupRegPath sysname         declare @NpRegPath sysname         declare @TcpRegPath sysname         declare @RegPathParams sysname         declare @FilestreamRegPath sysname          select @HkeyLocal=N'HKEY_LOCAL_MACHINE'          -- Instance-based paths         select @MSSqlServerRegPath=N'SOFTWARE\Microsoft\MSSQLServer'         select @InstanceRegPath=@MSSqlServerRegPath + N'\MSSQLServer'         select @FilestreamRegPath=@InstanceRegPath + N'\Filestream'         select @SetupRegPath=@MSSqlServerRegPath + N'\Setup'         select @RegPathParams=@InstanceRegPath+'\Parameters'          -- Services         select @ServicesRegPath=N'SYSTEM\CurrentControlSet\Services'         select @SqlServiceRegPath=@ServicesRegPath + N'\MSSQLSERVER'         select @BrowserServiceRegPath=@ServicesRegPath + N'\SQLBrowser'          -- InstanceId setting         select @InstanceNamesRegPath=N'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'          -- Network settings         select @NpRegPath=@InstanceRegPath + N'\SuperSocketNetLib\Np'         select @TcpRegPath=@InstanceRegPath + N'\SuperSocketNetLib\Tcp'                  declare @SmoAuditLevel int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'AuditLevel', @SmoAuditLevel OUTPUT                  declare @NumErrorLogs int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'NumErrorLogs', @NumErrorLogs OUTPUT                  declare @SmoLoginMode int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'LoginMode', @SmoLoginMode OUTPUT                  declare @SmoMailProfile nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'MailAccountName', @SmoMailProfile OUTPUT                  declare @BackupDirectory nvarchar(512)         if 1=isnull(cast(SERVERPROPERTY('IsLocalDB') as bit), 0)         select @BackupDirectory=cast(SERVERPROPERTY('instancedefaultdatapath') as nvarchar(512))         else         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'BackupDirectory', @BackupDirectory OUTPUT                  declare @SmoPerfMonMode int         exec master.dbo.xp_instance_regread @HkeyLocal, @InstanceRegPath, N'Performance', @SmoPerfMonMode OUTPUT          if @SmoPerfMonMode is null         begin         set @SmoPerfMonMode = 1000         end                  declare @InstallSqlDataDir nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLDataRoot', @InstallSqlDataDir OUTPUT                  declare @MasterPath nvarchar(512)         declare @LogPath nvarchar(512)         declare @ErrorLog nvarchar(512)         declare @ErrorLogPath nvarchar(512)         declare @Slash varchar = convert(varchar, serverproperty('PathSeparator'))         select @MasterPath=substring(physical_name, 1, len(physical_name) - charindex(@Slash, reverse(physical_name))) from master.sys.database_files where file_id = 1         select @LogPath=substring(physical_name, 1, len(physical_name) - charindex(@Slash, reverse(physical_name))) from master.sys.database_files where file_id = 2         select @ErrorLog=cast(SERVERPROPERTY(N'errorlogfilename') as nvarchar(512))         select @ErrorLogPath=IIF(@ErrorLog IS NULL, N'', substring(@ErrorLog, 1, len(@ErrorLog) - charindex(@Slash, reverse(@ErrorLog))))                  declare @SmoRoot nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLPath', @SmoRoot OUTPUT                  declare @ServiceStartMode int         EXEC master.sys.xp_instance_regread @HkeyLocal, @SqlServiceRegPath, N'Start', @ServiceStartMode OUTPUT                  declare @ServiceAccount nvarchar(512)         EXEC master.sys.xp_instance_regread @HkeyLocal, @SqlServiceRegPath, N'ObjectName', @ServiceAccount OUTPUT                  declare @NamedPipesEnabled int         exec master.dbo.xp_instance_regread @HkeyLocal, @NpRegPath, N'Enabled', @NamedPipesEnabled OUTPUT                  declare @TcpEnabled int         EXEC master.sys.xp_instance_regread @HkeyLocal, @TcpRegPath, N'Enabled', @TcpEnabled OUTPUT                  declare @InstallSharedDirectory nvarchar(512)         EXEC master.sys.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLPath', @InstallSharedDirectory OUTPUT                  declare @SqlGroup nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @SetupRegPath, N'SQLGroup', @SqlGroup OUTPUT                  declare @FilestreamLevel int         exec master.dbo.xp_instance_regread @HkeyLocal, @FilestreamRegPath, N'EnableLevel', @FilestreamLevel OUTPUT                  declare @FilestreamShareName nvarchar(512)         exec master.dbo.xp_instance_regread @HkeyLocal, @FilestreamRegPath, N'ShareName', @FilestreamShareName OUTPUT                  declare @cluster_name nvarchar(128)         declare @quorum_type tinyint         declare @quorum_state tinyint         BEGIN TRY         SELECT @cluster_name = cluster_name,         @quorum_type = quorum_type,         @quorum_state = quorum_state         FROM sys.dm_hadr_cluster         END TRY         BEGIN CATCH           IF(ERROR_NUMBER() NOT IN (297,300, 15562, 371))         BEGIN         THROW         END         END CATCH         SELECT @SmoAuditLevel AS [AuditLevel], ISNULL(@NumErrorLogs, -1) AS [NumberOfLogFiles], (case when @SmoLoginMode < 3 then @SmoLoginMode else 9 end) AS [LoginMode], ISNULL(@SmoMailProfile,N'') AS [MailProfile], @BackupDirectory AS [BackupDirectory], @SmoPerfMonMode AS [PerfMonMode], ISNULL(@InstallSqlDataDir,N'') AS [InstallDataDirectory], CAST(@@SERVICENAME AS sysname) AS [ServiceName], @ErrorLogPath AS [ErrorLogPath], @SmoRoot AS [RootDirectory], CAST(case when 'a' <> 'A' then 1 else 0 end AS bit) AS [IsCaseSensitive], @@MAX_PRECISION AS [MaxPrecision], CAST(FULLTEXTSERVICEPROPERTY('IsFullTextInstalled') AS bit) AS [IsFullTextInstalled], SERVERPROPERTY(N'ProductVersion') AS [VersionString], CAST(SERVERPROPERTY(N'Edition') AS sysname) AS [Edition], CAST(SERVERPROPERTY(N'ProductLevel') AS sysname) AS [ProductLevel], CAST(ISNULL(SERVERPROPERTY(N'ProductUpdateLevel'), N'') AS sysname) AS [ProductUpdateLevel], CAST(SERVERPROPERTY('IsSingleUser') AS bit) AS [IsSingleUser], CAST(SERVERPROPERTY('EngineEdition') AS int) AS [EngineEdition], convert(sysname, serverproperty(N'collation')) AS [Collation], CAST(ISNULL(SERVERPROPERTY('IsClustered'), 0) AS bit) AS [IsClustered], CAST(ISNULL(SERVERPROPERTY(N'MachineName'), N'') AS sysname) AS [NetName], ISNULL(SERVERPROPERTY(N'ComputerNamePhysicalNetBIOS'),N'') AS [ComputerNamePhysicalNetBIOS], ISNULL(@ServiceStartMode,2) AS [ServiceStartMode], @LogPath AS [MasterDBLogPath], @MasterPath AS [MasterDBPath], SERVERPROPERTY('instancedefaultdatapath') AS [DefaultFile], SERVERPROPERTY('instancedefaultlogpath') AS [DefaultLog], SERVERPROPERTY(N'ResourceVersion') AS [ResourceVersionString], SERVERPROPERTY(N'ResourceLastUpdateDateTime') AS [ResourceLastUpdateDateTime], SERVERPROPERTY(N'CollationID') AS [CollationID], SERVERPROPERTY(N'ComparisonStyle') AS [ComparisonStyle], SERVERPROPERTY(N'SqlCharSet') AS [SqlCharSet], SERVERPROPERTY(N'SqlCharSetName') AS [SqlCharSetName], SERVERPROPERTY(N'SqlSortOrder') AS [SqlSortOrder], SERVERPROPERTY(N'SqlSortOrderName') AS [SqlSortOrderName], SERVERPROPERTY(N'BuildClrVersion') AS [BuildClrVersionString], ISNULL(@ServiceAccount,N'') AS [ServiceAccount], CAST(@NamedPipesEnabled AS bit) AS [NamedPipesEnabled], CAST(@TcpEnabled AS bit) AS [TcpEnabled], ISNULL(@InstallSharedDirectory,N'') AS [InstallSharedDirectory], ISNULL(suser_sname(sid_binary(ISNULL(@SqlGroup,N''))),N'') AS [SqlDomainGroup], case when 1=msdb.dbo.fn_syspolicy_is_automation_enabled() and exists (select * from msdb.dbo.syspolicy_system_health_state  where target_query_expression_with_id like 'Server%' ) then 1 else 0 end AS [PolicyHealthState], @FilestreamLevel AS [FilestreamLevel], ISNULL(@FilestreamShareName,N'') AS [FilestreamShareName], -1 AS [TapeLoadWaitTime], CAST(SERVERPROPERTY(N'IsHadrEnabled') AS bit) AS [IsHadrEnabled], SERVERPROPERTY(N'HADRManagerStatus') AS [HadrManagerStatus], ISNULL(@cluster_name, '') AS [ClusterName], ISNULL(@quorum_type, 4) AS [ClusterQuorumType], ISNULL(@quorum_state, 3) AS [ClusterQuorumState], SUSER_SID(@ServiceAccount, 0) AS [ServiceAccountSid], CAST(SERVERPROPERTY('IsPolyBaseInstalled') AS bit) AS [IsPolyBaseInstalled], CAST(         serverproperty(N'Servername')        AS sysname) AS [Name], CAST(         ISNULL(serverproperty(N'instancename'),N'')        AS sysname) AS [InstanceName], CAST(0x0001 AS int) AS [Status], SERVERPROPERTY('PathSeparator') AS [PathSeparator], 0 AS [IsContainedAuthentication], CAST(null AS int) AS [ServerType]",11,10,1,0,0,303
"           create table #SVer(ID int,  Name  sysname, Internal_Value int, Value nvarchar(512))           insert #SVer exec master.dbo.xp_msver           insert #SVer select t.*           from sys.dm_os_host_info           CROSS APPLY (           VALUES           (1001, 'host_platform', 0, host_platform),           (1002, 'host_distribution', 0, host_distribution),           (1003, 'host_release', 0, host_release),           (1004, 'host_service_pack_level', 0, host_service_pack_level),           (1005, 'host_sku', host_sku, ''),           (1006, 'HardwareGeneration', '', ''),           (1007, 'ServiceTier', '', ''),           (1008, 'ReservedStorageSizeMB', '0', '0'),           (1009, 'UsedStorageSizeMB', '0', '0')           ) t(id, [name], internal_value, [value])                    -- Managed Instance-specific properties           if (SERVERPROPERTY('EngineEdition') = 8)           begin           DECLARE @gen4memoryPerCoreMB float = 7168.0           DECLARE @gen5memoryPerCoreMB float = 5223.0           DECLARE @physicalMemory float           DECLARE @virtual_core_count int           DECLARE @reservedStorageSize bigint           DECLARE @usedStorageSize decimal(18,2)           DECLARE @hwGeneration nvarchar(128)           DECLARE @serviceTier nvarchar(128)           SET @physicalMemory = (SELECT TOP 1 [virtual_core_count] *           (           CASE WHEN [hardware_generation] = 'Gen4' THEN @gen4memoryPerCoreMB           WHEN [hardware_generation] = 'Gen5' THEN @gen5memoryPerCoreMB           ELSE 0 END           )           FROM master.sys.server_resource_stats           ORDER BY start_time DESC)                    IF (@physicalMemory <> 0)            BEGIN             UPDATE #SVer SET [Internal_Value] =  @physicalMemory WHERE Name = N'PhysicalMemory'             UPDATE #SVer SET [Value] = CONCAT( @physicalMemory, ' (',  @physicalMemory * 1024, ')') WHERE Name = N'PhysicalMemory'           END           UPDATE #SVer SET [Internal_Value] = (SELECT TOP 1 [virtual_core_count] FROM master.sys.server_resource_stats ORDER BY start_time desc) WHERE Name = N'ProcessorCount'           UPDATE #SVer SET [Value] = [Internal_Value] WHERE Name = N'ProcessorCount'            SELECT TOP 1             @hwGeneration = [hardware_generation],             @serviceTier =[sku],             @virtual_core_count = [virtual_core_count],             @reservedStorageSize = [reserved_storage_mb],             @usedStorageSize = [storage_space_used_mb]           FROM master.sys.server_resource_stats           ORDER BY [start_time] DESC            UPDATE #SVer SET [Value] = @hwGeneration WHERE Name = N'HardwareGeneration'           UPDATE #SVer SET [Value] = @serviceTier WHERE Name = N'ServiceTier'           UPDATE #SVer SET [Value] = @reservedStorageSize WHERE Name = N'ReservedStorageSizeMB'           UPDATE #SVer SET [Value] = @usedStorageSize WHERE Name = N'UsedStorageSizeMB'         end         SELECT ( select Value from #SVer where Name =N'host_platform') AS [HostPlatform]          drop table #SVer        ",10,5,5,79,2,98
" DECLARE @total_buffer INT;  SELECT @total_buffer = cntr_value FROM sys.dm_os_performance_counters  WHERE RTRIM([object_name]) LIKE '%Buffer Manager' AND counter_name = 'Database Pages';  ;WITH src AS (   SELECT    database_id, db_buffer_pages = COUNT_BIG(*)   FROM sys.dm_os_buffer_descriptors   --WHERE database_id BETWEEN 5 AND 32766   GROUP BY database_id ) SELECT [db_name] = CASE [database_id] WHEN 32767  THEN 'Resource DB'  ELSE DB_NAME([database_id]) END, db_buffer_pages, db_buffer_MB = db_buffer_pages / 128, db_buffer_percent = CONVERT(DECIMAL(6,3),  db_buffer_pages * 100.0 / @total_buffer) FROM src ORDER BY db_buffer_MB DESC;  ",10,10,0,0,0,10
"       SELECT       ISNULL(sum(memory_allocated_for_table_kb+memory_allocated_for_indexes_kb) ,0) AS total_memory_allocated_for_user_data_kb, db_id() AS database_id       FROM sys.dm_db_xtp_table_memory_stats WITH(nolock)     ",10,5,5,20,0,748
"         declare @cluster_name nvarchar(128)         declare @quorum_type tinyint         declare @quorum_state tinyint         BEGIN TRY         SELECT @cluster_name = cluster_name,         @quorum_type = quorum_type,         @quorum_state = quorum_state         FROM sys.dm_hadr_cluster         END TRY         BEGIN CATCH           IF(ERROR_NUMBER() NOT IN (297,300, 15562, 371))         BEGIN         THROW         END         END CATCH         SELECT ISNULL(@quorum_state, 3) AS [ClusterQuorumState]",10,9,1,0,0,10
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000),@_msparam_6 nvarchar(4000),@_msparam_7 nvarchar(4000))                 create table #tmp_sp_catalogs (is_catalog_support bit null,server_name nvarchar(128) null, product_name nvarchar(128) null,provider_name nvarchar(128) null,catalog_name nvarchar(128) null, description nvarchar(4000) null)                 declare @ServerName sysname                 declare @ProductName sysname                         declare @ProviderName sysname                 declare crs cursor local fast_forward                 for ( SELECT srv.name AS [Name], srv.product AS [ProductName], srv.provider AS [ProviderName] FROM sys.servers AS srv WHERE (srv.server_id != 0)and(srv.name=@_msparam_0) )                  open crs                  fetch crs into @ServerName,@ProductName,@ProviderName                 while @@fetch_status >= 0                  begin                 create table #tmp_catalog_exist_test (id int null,description sysname null,flags varchar null)                         DECLARE @IsCatalogSupport bit                   if (UPPER(@ProviderName) like 'SQLNCLI%' or UPPER(@ProviderName) like 'MSOLEDBSQL%' )                            begin                      set @IsCatalogSupport = 1                 end                 else                 begin                     insert into #tmp_catalog_exist_test(id,description,flags) EXEC master.dbo.xp_prop_oledb_provider @ProviderName                     select @IsCatalogSupport = count(*) from #tmp_catalog_exist_test  where id = 233                   end            if (@IsCatalogSupport = 0)                     begin                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                     end                     else                     begin                     BEGIN TRY                     insert into #tmp_sp_catalogs (catalog_name,description) EXEC master.dbo.sp_catalogs @server_name = @ServerName                     update #tmp_sp_catalogs set is_catalog_support = 1                     END TRY                     BEGIN CATCH                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                        END CATCH                     end                     update #tmp_sp_catalogs set server_name = @ServerName                     update #tmp_sp_catalogs set product_name = @ProductName                     update #tmp_sp_catalogs set provider_name = @ProviderName                     fetch crs into @ServerName,@ProductName,@ProviderName                 end                 close crs                 deallocate crs    				create table #tmp_sp_tables_ex (is_catalog_error bit null,server_name nvarchar(128) null,server_catalog_name nvarchar(128) null,TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null) 				 				create table #tmp_sp_tables_ex_all (TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null)		                 declare @TableServerName sysname 				declare @TableCatalogName sysname 				declare @IsCatalogSupportExist bit                 declare TableServerCrs cursor local fast_forward                 for ( SELECT tsc.server_name AS [ServerName], tsc.catalog_name AS [Name], tsc.is_catalog_support AS [IsCatalogSupport] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name WHERE (tsc.catalog_name=@_msparam_1 and tsc.is_catalog_support=@_msparam_2)and((srv.server_id != 0)and(srv.name=@_msparam_3)) )                  open TableServerCrs                  fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 while @@fetch_status >= 0                  				begin 				IF (@IsCatalogSupportExist=0) 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = NULL 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = NULL 				END 				ELSE 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = @TableCatalogName 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = @TableCatalogName 				END				                 update #tmp_sp_tables_ex set server_name = @TableServerName																                 fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 end                 close TableServerCrs                 deallocate TableServerCrs   SELECT tste.TABLE_NAME AS [Name], ISNULL(tste.TABLE_SCHEM,'') AS [Schema], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/LinkedServer[@Name=' + quotename(srv.name,'''') + ']' + '/LinkedServerCatalog[@Name=' + quotename(tsc.catalog_name,'''') + ' and @IsCatalogSupport=' + quotename(tsc.is_catalog_support,'''') + ']' + '/LinkedServerView[@Name=' + quotename(tste.TABLE_NAME,'''') + ' and @Schema=' + quotename(ISNULL(tste.TABLE_SCHEM,''),'''') + ']' AS [Urn], case when ( tste.TABLE_SCHEM in ('') or (tste.TABLE_SCHEM IS NULL) ) then tste.TABLE_NAME else ISNULL(tste.TABLE_SCHEM,'')+'.'+tste.TABLE_NAME end AS [SchemaObjectName], case when tste.TABLE_TYPE in ('SYSTEM VIEW') then 1 else 0 end AS [IsSystemObject] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name INNER JOIN #tmp_sp_tables_ex AS tste ON tste.server_name=tsc.server_name WHERE (case when tste.TABLE_TYPE in ('SYSTEM VIEW') then 1 else 0 end=@_msparam_4)and((tsc.catalog_name=@_msparam_5 and tsc.is_catalog_support=@_msparam_6)and((srv.server_id != 0)and(srv.name=@_msparam_7))) ORDER BY [SchemaObjectName] ASC  			drop table #tmp_sp_tables_ex 			drop table #tmp_sp_tables_ex_all 		                   drop table #tmp_sp_catalogs                 drop table #tmp_catalog_exist_test               ",10,10,0,1117,6,10
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000),@_msparam_2 nvarchar(4000),@_msparam_3 nvarchar(4000),@_msparam_4 nvarchar(4000),@_msparam_5 nvarchar(4000),@_msparam_6 nvarchar(4000),@_msparam_7 nvarchar(4000),@_msparam_8 nvarchar(4000))                 create table #tmp_sp_catalogs (is_catalog_support bit null,server_name nvarchar(128) null, product_name nvarchar(128) null,provider_name nvarchar(128) null,catalog_name nvarchar(128) null, description nvarchar(4000) null)                 declare @ServerName sysname                 declare @ProductName sysname                         declare @ProviderName sysname                 declare crs cursor local fast_forward                 for ( SELECT srv.name AS [Name], srv.product AS [ProductName], srv.provider AS [ProviderName] FROM sys.servers AS srv WHERE (srv.server_id != 0)and(srv.name=@_msparam_0) )                  open crs                  fetch crs into @ServerName,@ProductName,@ProviderName                 while @@fetch_status >= 0                  begin                 create table #tmp_catalog_exist_test (id int null,description sysname null,flags varchar null)                         DECLARE @IsCatalogSupport bit                   if (UPPER(@ProviderName) like 'SQLNCLI%' or UPPER(@ProviderName) like 'MSOLEDBSQL%' )                            begin                      set @IsCatalogSupport = 1                 end                 else                 begin                     insert into #tmp_catalog_exist_test(id,description,flags) EXEC master.dbo.xp_prop_oledb_provider @ProviderName                     select @IsCatalogSupport = count(*) from #tmp_catalog_exist_test  where id = 233                   end            if (@IsCatalogSupport = 0)                     begin                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                     end                     else                     begin                     BEGIN TRY                     insert into #tmp_sp_catalogs (catalog_name,description) EXEC master.dbo.sp_catalogs @server_name = @ServerName                     update #tmp_sp_catalogs set is_catalog_support = 1                     END TRY                     BEGIN CATCH                     insert into #tmp_sp_catalogs (catalog_name,is_catalog_support) values ('default',0)                        END CATCH                     end                     update #tmp_sp_catalogs set server_name = @ServerName                     update #tmp_sp_catalogs set product_name = @ProductName                     update #tmp_sp_catalogs set provider_name = @ProviderName                     fetch crs into @ServerName,@ProductName,@ProviderName                 end                 close crs                 deallocate crs    				create table #tmp_sp_tables_ex (is_catalog_error bit null,server_name nvarchar(128) null,server_catalog_name nvarchar(128) null,TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null) 				 				create table #tmp_sp_tables_ex_all (TABLE_CAT sysname null, TABLE_SCHEM sysname null,TABLE_NAME sysname null,TABLE_TYPE varchar(32) null,REMARKS varchar(254) null)		                 declare @TableServerName sysname 				declare @TableCatalogName sysname 				declare @IsCatalogSupportExist bit                 declare TableServerCrs cursor local fast_forward                 for ( SELECT tsc.server_name AS [ServerName], tsc.catalog_name AS [Name], tsc.is_catalog_support AS [IsCatalogSupport] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name WHERE (tsc.catalog_name=@_msparam_1 and tsc.is_catalog_support=@_msparam_2)and((srv.server_id != 0)and(srv.name=@_msparam_3)) )                  open TableServerCrs                  fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 while @@fetch_status >= 0                  				begin 				IF (@IsCatalogSupportExist=0) 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = NULL 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = NULL 				END 				ELSE 				BEGIN 				insert into #tmp_sp_tables_ex_all (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) EXEC master.dbo.sp_tables_ex 			    @table_server = @TableServerName 			    ,@table_name = NULL 			    ,@table_schema = NULL 			    ,@table_catalog = @TableCatalogName 			    ,@table_type = NULL 				insert into #tmp_sp_tables_ex (TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS) select TABLE_CAT,TABLE_SCHEM,TABLE_NAME,TABLE_TYPE,REMARKS from #tmp_sp_tables_ex_all where TABLE_TYPE in  ('SYSTEM VIEW','VIEW') 				update #tmp_sp_tables_ex set server_catalog_name = @TableCatalogName 				END				                 update #tmp_sp_tables_ex set server_name = @TableServerName																                 fetch TableServerCrs into @TableServerName,@TableCatalogName,@IsCatalogSupportExist                 end                 close TableServerCrs                 deallocate TableServerCrs   SELECT ISNULL(tste.TABLE_CAT,'') AS [CatalogName] FROM sys.servers AS srv INNER JOIN #tmp_sp_catalogs AS tsc ON tsc.server_name=srv.name INNER JOIN #tmp_sp_tables_ex AS tste ON tste.server_name=tsc.server_name WHERE (tste.TABLE_NAME=@_msparam_4 and ISNULL(tste.TABLE_SCHEM,'')=@_msparam_5)and((tsc.catalog_name=@_msparam_6 and tsc.is_catalog_support=@_msparam_7)and((srv.server_id != 0)and(srv.name=@_msparam_8)))  			drop table #tmp_sp_tables_ex 			drop table #tmp_sp_tables_ex_all 		                   drop table #tmp_sp_catalogs                 drop table #tmp_catalog_exist_test               ",10,10,0,1119,3,30
"       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states                select TMIL.group_id, count(*) as is_managed_instance_link into #tmp_managed_instance_link from sys.availability_replicas AS TMIL where TMIL.endpoint_url LIKE '%Server=%' and (select count(*) from sys.availability_replicas as A1 where A1.group_id = TMIL.group_id) = 2 group by TMIL.group_id having count(*) = 1        SELECT AG.name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' AS [Urn], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], CAST(ISNULL(MIL.is_managed_instance_link, 0) & ISNULL(AG.is_distributed, 0) AS bit) AS [IsManagedInstanceLink], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 LEFT OUTER JOIN #tmp_managed_instance_link AS MIL ON AG.group_id = MIL.group_id ORDER BY [Name] ASC        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmp_managed_instance_link      ",10,8,2,88,0,51
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(v.schema_id) AS [Schema], v.name AS [Name], v.object_id AS [ID] FROM sys.all_views AS v WHERE (v.type = @_msparam_0) ORDER BY [Schema] ASC,[Name] ASC",9,6,3,72,0,29
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups              select agstates.group_id, agstates.primary_replica into #tmpag_availability_group_states from master.sys.dm_hadr_availability_group_states as agstates              select group_id, replica_id, replica_metadata_id into #tmpag_availability_replicas from master.sys.availability_replicas       select replica_id, is_local, role into #tmpag_availability_replica_states from master.sys.dm_hadr_availability_replica_states                select TMIL.group_id, count(*) as is_managed_instance_link into #tmp_managed_instance_link from sys.availability_replicas AS TMIL where TMIL.endpoint_url LIKE '%Server=%' and (select count(*) from sys.availability_replicas as A1 where A1.group_id = TMIL.group_id) = 2 group by TMIL.group_id having count(*) = 1        SELECT AG.name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' AS [Urn], case when 1=(SELECT CONVERT(bit, current_value)         FROM msdb.dbo.syspolicy_configuration         WHERE name = 'Enabled') and exists (select * from msdb.dbo.syspolicy_system_health_state where target_query_expression_with_id like 'Server'+ '/AvailabilityGroup\[@ID=' + convert(nvarchar(20),AR2.replica_metadata_id) + '\]%' ESCAPE '\') then 1 else 0 end AS [PolicyHealthState], ISNULL(agstates.primary_replica, '') AS [PrimaryReplicaServerName], ISNULL(arstates2.role, 3) AS [LocalReplicaRole], CAST(ISNULL(AG.is_distributed, 0) AS bit) AS [IsDistributedAvailabilityGroup], ISNULL(AG.cluster_type, 0) AS [ClusterType], CAST(ISNULL(MIL.is_managed_instance_link, 0) & ISNULL(AG.is_distributed, 0) AS bit) AS [IsManagedInstanceLink], CAST(ISNULL(AG.is_contained, 0) AS bit) AS [IsContained] FROM #tmpag_availability_groups AS AG LEFT OUTER JOIN #tmpag_availability_group_states as agstates ON AG.group_id = agstates.group_id INNER JOIN #tmpag_availability_replicas AS AR2 ON AG.group_id = AR2.group_id INNER JOIN #tmpag_availability_replica_states AS arstates2 ON AR2.replica_id = arstates2.replica_id AND arstates2.is_local = 1 LEFT OUTER JOIN #tmp_managed_instance_link AS MIL ON AG.group_id = MIL.group_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        drop table #tmpag_availability_groups              drop table #tmpag_availability_group_states              drop table #tmpag_availability_replicas       drop table #tmpag_availability_replica_states              drop table #tmp_managed_instance_link      ",9,8,1,174,2,9
"(@_msparam_0 nvarchar(4000))SELECT SCHEMA_NAME(v.schema_id) AS [Schema], v.name AS [Name], v.object_id AS [ID] FROM sys.all_views AS v WHERE (v.type = @_msparam_0) ORDER BY [Schema] ASC,[Name] ASC",9,4,5,58,0,28
"(@_msparam_0 nvarchar(4000)) create table #OLEDBProv (id int identity(1,1), Name sysname NOT NULL, ParseName sysname NOT NULL,Description sysname NOT NULL ) 			   insert #OLEDBProv (Name, ParseName,Description) EXECUTE master.dbo.sp_enum_oledb_providers 			   			delete from #OLEDBProv where exists ( select 1 from #OLEDBProv oprov where oprov.Name = #OLEDBProv.Name and oprov.id < #OLEDBProv.id ) 		   create table #oledbprop (allow_in_process bit, disallow_adhoc_access bit, dynamic_parameters bit, index_as_access_path bit, 				level_zero_only bit, nested_queries bit, non_transacted_updates bit, sql_server_like bit, provider_name sysname null)  		 declare name_cursor cursor local fast_forward 	FOR (select Name from  #OLEDBProv) open name_cursor  DECLARE @providername sysname  FETCH NEXT FROM name_cursor INTO @providername  WHILE (@@FETCH_STATUS <> -1)  BEGIN  	IF (@@FETCH_STATUS <> -2)  	BEGIN  		SELECT @providername = RTRIM(@providername)   		insert #oledbprop (provider_name, allow_in_process, disallow_adhoc_access, dynamic_parameters, index_as_access_path, level_zero_only,  			nested_queries, non_transacted_updates, sql_server_like)  		exec master.dbo.sp_MSset_oledb_prop @providername 	END  	FETCH NEXT FROM name_cursor INTO @providername  END  CLOSE name_cursor  DEALLOCATE name_cursor 		   SELECT op.Name AS [Name], op.Description AS [Description], o.allow_in_process AS [AllowInProcess], o.disallow_adhoc_access AS [DisallowAdHocAccess], o.dynamic_parameters AS [DynamicParameters], o.index_as_access_path AS [IndexAsAccessPath], o.level_zero_only AS [LevelZeroOnly], o.nested_queries AS [NestedQueries], o.non_transacted_updates AS [NonTransactedUpdates], o.sql_server_like AS [SqlServerLike] FROM #OLEDBProv AS op INNER JOIN #oledbprop AS o ON o.provider_name=op.Name WHERE (op.Name=@_msparam_0)  drop table #OLEDBProv   drop table #oledbprop 		 ",9,4,5,204,0,167
"(@_msparam_0 nvarchar(4000),@_msparam_1 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], AR.replica_id AS [UniqueId], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.operational_state, 6) AS [OperationalState], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], suser_sname(AR.owner_sid) AS [Owner], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AR.replica_server_name=@_msparam_0)and((AG.name=@_msparam_1))        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",9,7,2,183,0,18
"()           select           (select count(*) from sys.traces) as running_traces,           (select count(*) from sys.databases) as number_of_databases,           (select count(*) from sys.dm_db_missing_index_group_stats) as missing_index_count,           (select waiting_tasks_count from sys.dm_os_wait_stats where wait_type = N'SQLCLR_QUANTUM_PUNISHMENT') as clr_quantum_waits,           (select count(*) from sys.dm_os_ring_buffers where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' and record like N'%NonYieldSchedBegin%') as non_yield_count,           (select cpu_count from sys.dm_os_sys_info) as number_of_cpus,           (select scheduler_count from sys.dm_os_sys_info) as number_of_schedulers,           (select COUNT(*) from sys.dm_xe_sessions) as number_of_xevent_sessions",9,9,0,32,0,9
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups        SELECT AG.name AS [Name] FROM #tmpag_availability_groups AS AG WHERE (AG.name=@_msparam_0)        drop table #tmpag_availability_groups      ",9,7,2,179,0,36
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states        SELECT AR.replica_server_name AS [Name], 'Server[@Name=' + quotename(CAST(         serverproperty(N'Servername')        AS sysname),'''') + ']' + '/AvailabilityGroup[@Name=' + quotename(AG.name,'''') + ']' + '/AvailabilityReplica[@Name=' + quotename(AR.replica_server_name,'''') + ']' AS [Urn], ISNULL(arstates.role, 3) AS [Role], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(arcs.join_state, 99) AS [JoinState] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_replica_rollupstate              DROP TABLE #tmpar_availability_replica_cluster_states              drop table #tmpag_availability_groups       ",9,7,2,179,0,27
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups                 select group_id, replica_id, replica_server_name,create_date, modify_date, endpoint_url, read_only_routing_url, primary_role_allow_connections, secondary_role_allow_connections, availability_mode,failover_mode, session_timeout, backup_priority, owner_sid, seeding_mode into #tmpar_availability_replicas from master.sys.availability_replicas                select group_id, replica_id, role,operational_state,recovery_health,synchronization_health,connected_state, last_connect_error_number,last_connect_error_description, last_connect_error_timestamp into #tmpar_availability_replica_states from master.sys.dm_hadr_availability_replica_states              select replica_id,join_state into #tmpar_availability_replica_cluster_states from master.sys.dm_hadr_availability_replica_cluster_states              CREATE TABLE #ror_list_delimited (       replica_id uniqueidentifier,       read_only_routing_list nvarchar(max)       )       select replica_id,read_only_replica_id,routing_priority into #tmp_availability_read_only_routing_lists from sys.availability_read_only_routing_lists        INSERT INTO #ror_list_delimited       SELECT DISTINCT ars.replica_id, a.delimited       FROM #tmpar_availability_replicas AS ars       CROSS APPLY       (         SELECT STUFF(final_list.read_only_routing_list,1,1,'') FROM (         SELECT CASE          WHEN CHARINDEX(',', STUFF(priority_grouped_list.priority_group, 1, 1, '')) = 0 THEN priority_grouped_list.priority_group         ELSE ',(' + STUFF(priority_grouped_list.priority_group, 1, 1, '') + ')'            END          FROM (         SELECT (SELECT  ',N'''+ ars2.replica_server_name +''''         FROM #tmp_availability_read_only_routing_lists AS rrlists         INNER JOIN #tmpar_availability_replicas AS ars2         ON ars2.replica_id = rrlists.read_only_replica_id         WHERE rrlists.routing_priority = prioritylist.routing_priority         AND rrlists.replica_id = ars.replica_id         FOR XML PATH('') ) AS priority_group         FROM         (SELECT  distinct(routing_priority)         FROM #tmp_availability_read_only_routing_lists where replica_id = ars.replica_id) AS prioritylist(routing_priority)) priority_grouped_list         FOR XML PATH('') ) AS final_list(read_only_routing_list) ) AS a(delimited)              select * into #tmpar_ags from master.sys.dm_hadr_availability_group_states       select ar.group_id, ar.replica_id, ar.replica_server_name, ar.availability_mode, (case when UPPER(ags.primary_replica) = UPPER(ar.replica_server_name) then 1 else 0 end) as role, ars.synchronization_health into #tmpar_availabilty_mode from #tmpar_availability_replicas as ar       left join #tmpar_ags as ags on ags.group_id = ar.group_id       left join #tmpar_availability_replica_states as ars on ar.group_id = ars.group_id and ar.replica_id = ars.replica_id       select am1.replica_id, am1.role, (case when (am1.synchronization_health is null) then 3 else am1.synchronization_health end) as sync_state, (case when (am1.availability_mode is NULL) or (am3.availability_mode is NULL) then null when (am1.role = 1) then 1 when (am1.availability_mode = 0 or am3.availability_mode = 0) then 0 else 1 end) as effective_availability_mode       into #tmpar_replica_rollupstate from #tmpar_availabilty_mode as am1 left join (select group_id, role, availability_mode from #tmpar_availabilty_mode as am2 where am2.role = 1) as am3 on am1.group_id = am3.group_id       drop table #tmpar_availabilty_mode       drop table #tmpar_ags        SELECT AR.replica_server_name AS [Name], ISNULL(AR.availability_mode, 2) AS [AvailabilityMode], ISNULL(AR.backup_priority, -1) AS [BackupPriority], ISNULL(AR.primary_role_allow_connections, 4) AS [ConnectionModeInPrimaryRole], ISNULL(AR.secondary_role_allow_connections, 3) AS [ConnectionModeInSecondaryRole], ISNULL(arstates.connected_state, 2) AS [ConnectionState], ISNULL(AR.create_date, 0) AS [CreateDate], ISNULL(AR.modify_date, 0) AS [DateLastModified], ISNULL(AR.endpoint_url, N'') AS [EndpointUrl], ISNULL(AR.failover_mode, 3) AS [FailoverMode], ISNULL(arcs.join_state, 99) AS [JoinState], ISNULL(arstates.last_connect_error_description, N'') AS [LastConnectErrorDescription], ISNULL(arstates.last_connect_error_number,-1) AS [LastConnectErrorNumber], ISNULL(arstates.last_connect_error_timestamp, 0) AS [LastConnectErrorTimestamp], ISNULL(arstates.operational_state, 6) AS [OperationalState], suser_sname(AR.owner_sid) AS [Owner], ISNULL(AR.read_only_routing_url, '') AS [ReadonlyRoutingConnectionUrl], ISNULL(rorlists.read_only_routing_list, '') AS [ReadonlyRoutingListDelimited], ISNULL(arstates.role, 3) AS [Role], ISNULL(arstates.recovery_health, 2) AS [RollupRecoveryState], (case when arrollupstates.sync_state = 3 then 3 when (arrollupstates.effective_availability_mode = 1 or arrollupstates.role = 1) then arrollupstates.sync_state when arrollupstates.sync_state = 2 then 1 else 0 end) AS [RollupSynchronizationState], ISNULL(AR.session_timeout, -1) AS [SessionTimeout], AR.replica_id AS [UniqueId], ISNULL(AR.seeding_mode, 1) AS [SeedingMode] FROM #tmpag_availability_groups AS AG INNER JOIN #tmpar_availability_replicas AS AR ON (AR.replica_server_name IS NOT NULL) AND (AR.group_id=AG.group_id) LEFT OUTER JOIN #tmpar_availability_replica_states AS arstates ON AR.replica_id = arstates.replica_id LEFT OUTER JOIN #tmpar_availability_replica_cluster_states AS arcs ON AR.replica_id = arcs.replica_id LEFT OUTER JOIN #ror_list_delimited AS rorlists ON AR.replica_id = rorlists.replica_id LEFT OUTER JOIN #tmpar_replica_rollupstate AS arrollupstates ON AR.replica_id = arrollupstates.replica_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        DROP TABLE #tmpar_availability_replicas              DROP TABLE #tmpar_availability_replica_states              DROP TABLE #tmpar_availability_replica_cluster_states              DROP TABLE #ror_list_delimited       DROP TABLE #tmp_availability_read_only_routing_lists              DROP TABLE #tmpar_replica_rollupstate              drop table #tmpag_availability_groups       ",9,7,2,174,0,9
"(@_msparam_0 nvarchar(4000))       select * into #tmpag_availability_groups from master.sys.availability_groups        SELECT AGL.dns_name AS [Name] FROM #tmpag_availability_groups AS AG INNER JOIN master.sys.availability_group_listeners AS AGL ON AGL.group_id=AG.group_id WHERE (AG.name=@_msparam_0) ORDER BY [Name] ASC        drop table #tmpag_availability_groups       ",8,7,1,175,0,8
